---
comments: true
---

# 全局平衡二叉树学习笔记

哈哈，大战全局平衡二叉树一下午加一晚上加一上午最终写出了依托。

前置知识：树链剖分。

另外，本文可能会将全局平衡二叉树简写为 GBST（static globel balanced search tree）。

## 从重链剖分到全局平衡二叉树

回顾一下重链剖分最重要的性质：

> 任意一条从根开始的简单路径经过的重链条数不超过 $O(\log n)$。

证明大致就是每次跳轻边子树大小至少 $\times 2$，具体证明此处略过。

重链剖分本质就是在重链上维护数据结构，在上面这条引理的基础上，对链的操作可以做到 $O(B\log n)$ 的复杂度，其中 $B$ 是所用数据结构的复杂度。

但是全局平衡二叉树打破了“在链上维护数据结构”的常规，使用了类似于 LCT 的构造，得到了更优的复杂度。

具体来说，全局平衡二叉树仍然沿用了重链剖分，对每一条重链维护一棵二叉树，并且通过一些构造使得算上多棵树之间的虚边后整棵树的树高仍然是 $O(\log n)$，具体见下文。

另外，全局平衡二叉树也能维护子树信息，但是并没有什么显著优势，本文略过。

## 算法简述

对于一条重链，我们将轻儿子的大小也算上，就变成了一条带权的链。我们找到这条链的带权中点，将其作为根然后向两边递归。

这样得到了一个二叉树森林，我们用虚边（和 LCT 一样，认父亲不认儿子的边）将每条重链的二叉树根连到对应的结点上。不难发现这棵树的树高是 $O(\log n)$ 级别的。

那么我们如何在这棵树上维护信息呢？

以链加链查询为例，每条重链的前缀就是从点 $u$ 往上跳的若干个点和若干个左子树。那么可以子树打标记解决，通常使用标记永久化。查询同理，注意子树修改对子树查询的贡献要乘上一个子树大小。代码留坑待补。