---
comments: true
---

# 2023 暑期 NOIP 集训杂题

## 前言

时间好紧……

## CF319E Ping-Pong

[传送门](https://www.luogu.com.cn/problem/CF319E)

首先有包含、相交但不包含、不交三种情况。分别对应从小的往大的连有向边、连无向边、不连边。

显然我们可以把每个由无向边链接的连通块看成一个**等价区间**，下文**等价区间**均指连成连通块的区间。

- 结论 $1$：两等价区间不是包含就是不交。

挺显然的，假如等价区间 $A$ 与等价区间 $B$ 相交但不包含，那么必然存在区间 $a \in A$ 与区间 $b\in B$ 相交但不包含。那么 $A,B$ 其实是同一个等价区间。

- 结论 $2$：等价区间 $A$ 向等价区间 $B$ 连有向边当且仅当等价区间 $B$ 包含等价区间 $A$。

先证充分性，假如等价区间 $A$ 向等价区间 $B$ 连有向边，那么必然存在一个区间 $a\in A$ 被区间 $b \in B$ 包含。由结论 $1$，必定是 $A$ 包含 $B$ 或者 $B$ 包含 $A$。由于 $A$ 和 $B$ 是两个不同的等价区间，故 $A$ 中任意区间和 $B$ 中任意区间不是包含就是相离，由于 $a$ 已经被 $b$ 包含了，故 $A$ 必然也被 $b$ 包含，显然 $A$ 被 $B$ 包含。

再证必要性，假如等价区间 $B$ 包含等价区间 $A$，由于 $A$ 和 $B$ 是两个不同的等价区间，故 $A,B$ 中任意区间不是包含就是相离（复读），由于 $A$ 被 $B$ 包含，故 $A$ 必定向 $B$ 连有向边。

那么我们用并查集维护等价区间，再记录每个等价区间的左右端点，查询时直接查两个对应的等价区间是否包含即可，这个非常简单。

考虑如何维护等价区间，首先由于区间大小单调递增，故后面的区间不可能被前面的区间包含，我们只要考虑当前区间两端点被前面的哪些等价区间包含即可。

考虑维护一棵线段树套 `set`，线段树上每个结点用一个 `set` 维护这个区间被哪些等价区间完全包含，要用标记永久化思想，每次把经过的结点所有 `set` 全部加到当前取件的等价区间里。注意维护开区间。

由于每加一个区间最多打 $\log n$ 个标记，每个标记最多被删一次，势能分析得这部分复杂度为 $O(n\log n)$，由于标记删除时要用并查集维护故维护等价区间的复杂度为 $O(n\log^2 n)$，线段树复杂度为 $O(n \log n)$，故总复杂度为 $O(n\log^2 n)$。

/// details | 参考代码
    open: False
    type: success
```cpp
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof(a))
#define forup(i,s,e) for(int i=(s);i<=(e);i++)
#define fordown(i,s,e) for(int i=(s);i>=(e);i--)
using namespace std;
#define gc getchar()
inline int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=1e5+5,inf=0x3f3f3f3f;
int n,cnts,sz;
struct que{
	int x,y;
}s[N];
struct ask{
	int a,b,tt;
}q[N];
vector<int> lsh;
int fa[N],L[N],R[N];
int getfa(int x){return x==fa[x]?x:fa[x]=getfa(fa[x]);}
struct SegmentTree{
	#define mid ((l+r)>>1)
	#define lson l,mid,id<<1
	#define rson mid+1,r,id<<1|1
	set<int> mark[N<<2];
	void Update(int L,int R,int X,int l=1,int r=sz,int id=1){
		if(L<=l&&r<=R){
			mark[id].insert(X);
			return;
		}
		if(L<=mid) Update(L,R,X,lson);
		if(mid< R) Update(L,R,X,rson);
	}
	void Ask(int P,int U,int l=1,int r=sz,int id=1){
		for(auto i:mark[id]){
			int fi=getfa(i);
			if(fi!=U){
				fa[fi]=U;
				L[U]=min(L[U],L[fi]);
				R[U]=max(R[U],R[fi]);
			}
		}
		mark[id].clear();
		if(l==r){
			return ;
		}
		if(P<=mid) Ask(P,U,lson);
		else       Ask(P,U,rson);
	}
}mt;
signed main(){
	n=read();
	forup(i,1,n){
		int op=read();
		q[i].tt=op;
		if(op==1){
			s[++cnts].x=read();s[cnts].y=read();
			lsh.push_back(s[cnts].x);
			lsh.push_back(s[cnts].y);
			q[i].a=cnts;
		}else{
			q[i].a=read();q[i].b=read();
		}
	}
	sort(lsh.begin(),lsh.end());
	lsh.erase(unique(lsh.begin(),lsh.end()),lsh.end());
	forup(i,1,cnts){
		s[i].x=lower_bound(lsh.begin(),lsh.end(),s[i].x)-lsh.begin()+1;
		s[i].y=lower_bound(lsh.begin(),lsh.end(),s[i].y)-lsh.begin()+1;
	}
	sz=lsh.size();
	forup(i,1,cnts){
		fa[i]=i;L[i]=s[i].x;R[i]=s[i].y;
	}
	forup(i,1,n){
		if(q[i].tt==2){
			int fu=getfa(q[i].a),fv=getfa(q[i].b);
			if(L[fv]<=L[fu]&&R[fu]<=R[fv]){
				puts("YES");
			}else{
				puts("NO");
			}
		}else{
			int u=q[i].a,l=s[u].x,r=s[u].y;
			mt.Ask(l,u);mt.Ask(r,u);
			mt.Update(L[u]+1,R[u]-1,u);
		}
	}
}
```
///