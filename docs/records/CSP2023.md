---
comments: true
---

# CSP2023 考前杂题

## 前言

今天（9.20）看到了一道有意思的题，便突然有记杂题的想法了。

## 洛谷 P6018 [Ynoi2010] Fusion tree

[传送门](https://www.luogu.com.cn/problem/P6018)

科技题。

首先看到异或就要想到 01Trie，那么考虑如何维护。

假如给每个节点建一个 01Trie 存所有邻居显然是不行的，时间空间双双炸掉，考虑随便定个根，然后存每个结点所有儿子，修改和查询时额外把父亲加上就行了。

然后 01Trie 需要支持插入删除求异或和和整体 $+1$，前三个是简单的。第四个就是这道题需要用科技的地方了。

考虑在二进制上 $+1$ 相当于把最低位的 $0$ 变成 $1$，后面的 $1$ 全变成 $0$。那么假如我们的 01Trie 从低位往高位存储，这个操作就相当于交换结点左右儿子然后向 $0$ 递归。然后稍微注意一下另外三个操作的变化即可。

/// details | 代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof(a))
#define forup(i,s,e) for(int i=(s);i<=(e);i++)
#define fordown(i,s,e) for(int i=(s);i>=(e);i--)
using namespace std;
#define gc getchar()
inline int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=5e5+5,inf=0x3f3f3f3f;
int n,m,a[N],tg[N];
vector<int> e[N];
struct Trie{
	int son[N*22][2],wxor[N*22],num[N*22],root[N],cntn;
	int _New(){
		++cntn;
		son[cntn][0]=son[cntn][1]=0;
		wxor[cntn]=0;num[cntn]=0;
		return cntn;
	}
	void init(){cntn=0;forup(i,1,n) root[i]=_New();mem(son,0);}
	void _PushUp(int p){
		wxor[p]=num[p]=0;
		if(son[p][0]){
			wxor[p]^=(wxor[son[p][0]]<<1);
			num[p]+=num[son[p][0]];
		}
		if(son[p][1]){
			wxor[p]^=((wxor[son[p][1]]<<1)|(num[son[p][1]]&1));
			num[p]+=num[son[p][1]];
		}
	}
	void Insert(int p,int a,int q=0){
		if(q==21){
			++num[p];
			return;
		}
		if(!son[p][a&1]) son[p][a&1]=_New();
		Insert(son[p][a&1],a>>1,q+1);
		_PushUp(p);
	}
	void Erase(int p,int a,int q=0){
		if(q==21){
			--num[p];
			return;
		}
		Erase(son[p][a&1],a>>1,q+1);
		_PushUp(p);
	}
	void Add1(int p,int q=0){
		if(q==21) return;
		swap(son[p][0],son[p][1]);
		if(son[p][0]) Add1(son[p][0],q+1);
		_PushUp(p);
	}
}mt;
int f[N];
void dfs(int x,int fa){
	f[x]=fa;
	for(auto i:e[x]){
		if(i==fa) continue;
		dfs(i,x);
	}
}
signed main(){
	n=read();m=read();
	forup(i,1,n-1){
		int u=read(),v=read();
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(1,0);
	mt.init();
	forup(i,1,n){
		a[i]=read();
		if(i!=1) mt.Insert(mt.root[f[i]],a[i]);
	}
	forup(Case,1,m){
		int op=read();
		if(op==1){
			int x=read();tg[x]++;
			if(x!=1&&f[x]!=1){
				int ff=f[x];
				mt.Erase(mt.root[f[ff]],a[ff]+tg[f[ff]]);
				a[ff]++;
				mt.Insert(mt.root[f[ff]],a[ff]+tg[f[ff]]);
			}else if(x!=1){
				a[f[x]]++;
			}
			mt.Add1(mt.root[x]);
		}else if(op==2){
			int x=read(),v=read();
			if(x!=1){
				mt.Erase(mt.root[f[x]],a[x]+tg[f[x]]);
				a[x]-=v;
				mt.Insert(mt.root[f[x]],a[x]+tg[f[x]]);				
			}else{
				a[x]-=v;
			}
		}else{
			int x=read(),ans=mt.wxor[mt.root[x]];
			if(x!=1) ans^=a[f[x]]+tg[f[f[x]]];
			printf("%d\n",ans);
		}
	}
}
```
///

## P4198 楼房重建

[传送门](https://www.luogu.com.cn/problem/P4198)

首先显然是要维护斜率的，后面的大小比较都默认是说斜率了。

那么题意就是单点修改，求前缀最大值数量。

前缀最大值数量不具有结合律，乍一看不能用线段树维护，但是这道题就是要反其道而行。

首先考虑合并时左儿子的前缀最大值必定是整个区间的前缀最大值，那么只用考虑右儿子大于左儿子最大值的部分。

设右儿子为 $u$，左儿子为 $v$，$r_u$ 表示 $u$ 内的前缀最大值个数，$mx_u$ 表示 $u$ 内的最大值，$ls,rs$ 分别代表 $u$ 的左右儿子，那么分情况讨论：

若 $mx_v>mx_u$，右儿子对当前区间的贡献必为 $0$，直接等于左区间的 $r$。

若 $mx_{ls}<mx_v<mx_u$，那么 $ls$ 就没有贡献，递归查找 $rs$。

若 $mx_v<mx_{ls}$，那么 $rs$ 的贡献必定为 $r_u-r_{ls}$，递归查找 $ls$。

那么合并的复杂度就是 $O(\log n)$ 的，总复杂度 $O(n\log^2 n)$。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof(a))
#define forup(i,s,e) for(i64 i=(s);i<=(e);i++)
#define fordown(i,s,e) for(i64 i=(s);i>=(e);i--)
using namespace std;
using i64=long long;
#define gc getchar()
inline i64 read(){
    i64 x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const i64 N=1e5+5,inf=0x3f3f3f3f;
i64 n,m;
struct Node{
	i64 x,y;
	Node(i64 _x=1,i64 _y=-1):x(_x),y(_y){};
	bool operator <(const Node &r)const{return y*r.x<r.y*x;}
	bool operator >(const Node &r)const{return y*r.x>r.y*x;}
	bool operator <=(const Node &r)const{return y*r.x<=r.y*x;}
	bool operator >=(const Node &r)const{return y*r.x>=r.y*x;}
	bool operator ==(const Node &r)const{return y*r.x==r.y*x;}
};
struct SegTree{
	#define mid ((l+r)>>1)
	#define lson l,mid,id<<1
	#define rson mid+1,r,id<<1|1
	Node querymax[N<<2];
	i64 queryans[N<<2];
	i64 Getans(Node LMX,i64 l,i64 r,i64 id){
		if(queryans[id]==0){
			return 0;
		}
		if(l==r){
			return 1;
		}
		if(LMX<querymax[id<<1]){
			return Getans(LMX,lson)+queryans[id]-queryans[id<<1];
		}else{
			return Getans(LMX,rson);
		}
	}
	void Update(i64 P,Node X,i64 l=1,i64 r=n,i64 id=1){
		if(l==r){
			querymax[id]=X;
			queryans[id]=1;
			return;
		}
		if(P<=mid) Update(P,X,lson);
		else       Update(P,X,rson);
		querymax[id]=max(querymax[id<<1],querymax[id<<1|1]);
		if(querymax[id<<1]>=querymax[id<<1|1]){
			queryans[id]=queryans[id<<1];
		}else if(r==mid+1){
			queryans[id]=queryans[id<<1]+queryans[id<<1|1];
		}else{
			queryans[id]=queryans[id<<1]+Getans(querymax[id<<1],rson);
		}
	}
	i64 Ask(){
		return queryans[1];
	}
}mt; 
signed main(){
	n=read();m=read();
	forup(Case,1,m){
		i64 x=read(),y=read();
		mt.Update(x,Node(x,y));
		printf("%lld\n",mt.Ask());
	}
}
```

///

## 由于一些原因（指题目过多）后面的均为口胡，无代码（以后有时间再补吧）

## P7470 [NOI Online 2021 提高组] 岛屿探险

[传送门](https://www.luogu.com.cn/problem/P7470)

本文中 $\oplus$ 表示按位异或。

---

首先考虑把 $b_i>d_j$ 和 $b_i \le d_j$ 的分开考虑：

对于 $b_i>d_j$ 的，即为求 $a_i\oplus c_j\le d_j$ 的 $i$ 的个数，由于 $c,d$ 是知道的，这个可以直接 01Trie 维护，具体维护方式略。

对于 $b_i\le d_j$ 的，即为求 $c_j\oplus a_i\le b_i$ 的 $i$ 的个数，发现和上一种情况是对称的，那么考虑把询问塞到 01Trie 里面，然后统计改为给 Trie 的结点打标记，最后贡献即为根到叶子路径上标记的综合。

---

但是假如每次询问都这样做复杂度直接爆炸，大概是 $O(qn\log V)$ 的，那么考虑如何维护多次询问：

首先考虑全都是 $b_i>d_j$ 的（貌似有部分分），可以开一个可持久化 Trie，然后仿照可持久化权值线段树做前缀和即可。

然后假如全是 $b_i\le d_j$，我们可以把询问拆成 $[1,r]-[1,l-1]$，直接离线下来排序做即可。

这里离线下来指的是把所有 $c_j$ 插进 Trie 里，然后排序后遇到 $a_i$ 就打标记，遇到 $c_i$ 就查询路径上的标记和。

然后就转化成了一个偏序问题，直接套一层 CDQ 分治即可。

但是既然已经用了 CDQ 了，那可以把一维偏序当二维偏序做，就不需要可持久化 Trie 了。

---

复杂度分析：

$$T(n)=2T(\frac{n}{2})+O(n\log V)$$

那么 $T(n)$ 的渐进复杂度即为 $O(n\log n\log V)$，然后这里的 $n$ 取题目中的 $n+q$，所以复杂度即为 $O((n+q)\log(n+q)\log V)$。

/// details | 参考代码 updated on 22 Sept.
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof(a))
#define forup(i,s,e) for(int i=(s);i<=(e);i++)
#define fordown(i,s,e) for(int i=(s);i>=(e);i--)
using namespace std;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
inline int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=1e5+5,inf=0x3f3f3f3f;
int n,m,ans[N];
struct Trie1{
	int tag[N*25],son[N*25][2],cntn;
	void init(){
		mem(tag,0);mem(son,0);cntn=0;
	}
	void Clear(){
		forup(i,0,cntn){
			tag[i]=son[i][0]=son[i][1]=0;
		}
		cntn=0;
	}
	void Insert(int a){
		int p=0;
		fordown(i,23,0){
			if(!son[p][(a>>i)&1]) son[p][(a>>i)&1]=++cntn;
			p=son[p][(a>>i)&1];
		}
	}
	void Work(int a,int b){
		int p=0;
		fordown(i,23,0){
			if((b>>i)&1){
				if(son[p][(a>>i)&1]) tag[son[p][(a>>i)&1]]++;
				if(son[p][((a>>i)&1)^1]) p=son[p][((a>>i)&1)^1];
				else return;
			}else{
				if(son[p][(a>>i)&1]) p=son[p][(a>>i)&1];
				else return;
			}
		}
		tag[p]++;
	}
	int Get(int a){
		int p=0,res=0;
		fordown(i,23,0){
			res+=tag[p];
			p=son[p][(a>>i)&1];
		}
		res+=tag[p];
		return res;
	}
}t1;
struct Trie0{
	int son[N*25][2],cntn,cnt[N*25];
	void init(){
		mem(son,0);mem(cnt,0);
		cntn=0;
	}
	void Clear(){
		forup(i,0,cntn){
			son[i][0]=son[i][1]=cnt[i]=0;
		}
		cntn=0;
	}
	void Insert(int a){
		int p=0;
		fordown(i,23,0){
			cnt[p]++;
			if(!son[p][(a>>i)&1]) son[p][(a>>i)&1]=++cntn;
			p=son[p][(a>>i)&1];
		}
		cnt[p]++;
	}
	int Work(int a,int b){
		int res=0,p=0;
		fordown(i,23,0){
			if((b>>i)&1){
				if(son[p][(a>>i)&1]) res+=cnt[son[p][(a>>i)&1]];
				if(son[p][((a>>i)&1)^1]) p=son[p][((a>>i)&1)^1];
				else return res;
			}else{
				if(son[p][(a>>i)&1]) p=son[p][(a>>i)&1];
				else return res;
			}
		}
		res+=cnt[p];
		return res;
	}
}t0;
struct Node{
	int tp,r,f,a,b,pos;
}q[N<<2];
void cdq(int l,int r){
	if(l>=r){return;}
	int mid=(l+r)>>1;
	cdq(l,mid);cdq(mid+1,r);
	vector<Node> v0,v1;
	t0.Clear();t1.Clear();
	forup(i,l,mid){
		if(q[i].tp==0) v0.push_back(q[i]);
		else           v1.push_back(q[i]),t1.Insert(q[i].a);
	}
	int l0=0,l1=0;
	forup(i,mid+1,r){
		if(q[i].tp==0){
			while(l1<(int)v1.size()&&v1[l1].r<q[i].r){
				ans[v1[l1].pos]+=t1.Get(v1[l1].a)*v1[l1].f;
				++l1;
			}
			t1.Work(q[i].a,q[i].b);
		}else{
			while(l0<(int)v0.size()&&v0[l0].r<=q[i].r){
				t0.Insert(v0[l0].a);
				++l0;
			}
			ans[q[i].pos]+=t0.Work(q[i].a,q[i].b)*q[i].f;
		}
	}
	while(l1<(int)v1.size()){
		ans[v1[l1].pos]+=t1.Get(v1[l1].a)*v1[l1].f;
		++l1;
	}
	inplace_merge(q+l,q+mid+1,q+r+1,[](Node a,Node b){return a.r<b.r;});
}
signed main(){
	n=read();m=read();
	t1.init();t0.init();
	forup(i,1,n){
		q[i].tp=0;q[i].r=i;q[i].a=read();q[i].b=read();
	}
	forup(i,1,m){
		int l=read(),r=read(),c=read(),d=read(),tt=i*2+n-1;
		q[tt].tp=q[tt+1].tp=1;
		q[tt].a=q[tt+1].a=c;
		q[tt].b=q[tt+1].b=d;
		q[tt].pos=q[tt+1].pos=i;
		q[tt].r=l-1;q[tt].f=-1;
		q[tt+1].r=r;q[tt+1].f=1;
	}
	sort(q+1,q+m*2+n+1,[](Node a,Node b){return a.b>b.b;});
//	forup(i,1,m*2+n){
//		printf("%d %d %d %d %d %d||\n",q[i].tp,q[i].a,q[i].b,q[i].pos,q[i].r,q[i].f);
//	}
	cdq(1,m*2+n);
	forup(i,1,m){
		printf("%d\n",ans[i]);
	}
}
```

///
## P8349 [SDOI/SXOI2022] 整数序列

[传送门](https://www.luogu.com.cn/problem/P8349)

根号分治题。

题意就是说选一个区间内两种颜色数量相等，最大化权值和。

---

首先考虑暴力，把两种颜色取出来，设 $x$ 的总数量为 $len_x$，然后从前往后扫一遍，设一个前缀的权值是 $c_x-c_y+len_y$（$c_x$ 表示前缀中 $x$ 的个数，加上 $len_y$ 是为了防止负数下标），那么容易发现两个全职相同的前缀的差就是一个合法的区间，后面的维护是简单的。

复杂度为 $O(len_x+len_y)$。

---

设一个阈值 $K$，然后把 $len_x>K$ 的称为“大色”，$len_x\le K$ 的称为“小色”，那么可以把询问分为三种：

1. 小色对小色

直接暴力复杂度是 $O(K)$ 的，复杂度最多是 $O(qK)$。

2. 大色对大色

这样的颜色最多有 $\frac{n}{K}$ 种，本质不同的对数只有 $\frac{n}{K}^2$ 对，可以用 `unordered_map` 存起来。设有 $k$ 个大色，极限情况下 $\sum_{i=1}^k {len_i}=n$，那么共有 $\frac{k(k-1)}{2}$ 种本质不同的询问，总计算次数为 $\sum_{i\le i<j\le k}{len_i+len_j}=(k-1)\sum_{i=1}^k{len_i}=n(k-1)$。由于 $len_i\le K$，得到 $k\le \frac{n}{K}$，则极限复杂度为 $O(\frac{n^2}{K})$。

当然也可以感性理解，此处给了严谨证明就略过了。

3. 大色对小色

由于小色对应的点数和大色对应的点数差距悬殊，而题目要求选择的区间内两种颜色点数相同，大色里面有很多点都是不可能产生贡献的的。我们可以把两种颜色的点分成**有效点**与**无效点**两种。

为方便叙述，假设 $len_x\le K <len_y$

首先 $x$ 内所有点都是有效点（显然吧）。

然后考虑维护 $y$ 内有效点的集合，遍历 $x$，然后二分对应的下一个 $y$，这样也能找到一段极长的连续 $x$，设这一段的长度为 $l$，那么往前 $l$ 个 $y$，往后 $l$ 个 $y$ 都是有效点，然后注意跳过原本就是有效点的，这里可以用 `set` 维护，容易发现一个 $x$ 会对应至多 $2$ 个 $y$，故有效点的数量是 $O(K)$ 的，那么就可以直接暴力了。复杂度是 $O(len_x\log{len_y})$

考虑极限情况，设有 $k_1$ 个大色，其中第 $i$ 个大小为 $L_i$，有 $k_2$ 个小色，其中第 $i$ 个大小为 $l_i$，考虑到复杂度与小色的大小关系更大，那么我们用最大的 $\frac{q}{k_1}$ 个小色对大色询问，这样对于记忆化是最劣的，计算次数为 $\sum_{i=1}^{k_2}\sum_{j=1}^{k_1}l_i\log L_j\le k_1\log n\sum l_i$。

最强的情况，可以构造出约为 $\frac{n}{2K}$ 个长度略大于 $K$ 的大色，然后其余小色总长度约为 $\frac{n}{2}$，并且使每个大色对每个小色问一遍，此时 $k_1$ 约为 $O(\frac{n}{K})$，$\sum l_i$ 约为 $O(n)$，则总复杂度为 $\frac{n^2\log n}{B}$。

---

总复杂度约为 $O(qK+\frac{n^2\log n}{K})$，大对大的因为严格小于大对小可以直接忽略，据说 $K$ 取 $\sqrt{\frac{n^2\log n}{q}}$ 时最优，但是我个人觉得取 $\sqrt{n}$ 差不多得了（ ~~主要是我不会证明~~ ）。

好了现在我会证了，感谢 xx019。

根据均值不等式 $a+b\ge 2\sqrt{ab}$，$qK+\frac{n^2\log n}{K}\ge 2\sqrt{qn^2\log n}$，且在 $qK=\frac{n^2\log n}{K}$ 时取等，即 $K=\sqrt{\frac{n^2\log n}{q}}$，此时复杂度为 $O(n\sqrt{q\log n})$。

---

好了写出来了，$O(n\sqrt{q\log n})$ 没卡过去，学了下 $O(n\sqrt{q})$ 的写法。

具体来说，把大色对小色的离线到大色上，然后对于每个大色 $y$ 可以 $O(n)$ 预处理序列上每个数往前第一个 $y$ 和往后第一个 $y$。然后用栈维护连续段的个数，假如当前段的左端点比上一段右端点靠前就可以合并，再前缀和维护一下合并时没产生贡献的点数，把工薪额外加在当前区间的两端，最后和前面的做法一样，总的来说压掉了一个 $\sqrt{\log}$，就不用卡常了。

/// details | 参考代码 updated on 22 Sept.
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof(a))
#define forup(i,s,e) for(int i=(s);i<=(e);i++)
#define fordown(i,s,e) for(int i=(s);i>=(e);i--)
using namespace std;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
using i64=long long;
#define gc getchar()
inline int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=3e5+5,TT=300;
const i64 inf=1e18;
int n,q,a[N],b[N];
vector<int> pos[N];
i64 bkt[N],ans[1000005];
unordered_map<int,i64> mp[N];
vector<pii> quu[N];
int pre[N],nxt[N],cnt[N];
i64 calc(vector<int> &t1,vector<int> &t2){
	int l1=0,l2=0,sz=t1.size()+t2.size();
	forup(i,0,sz) bkt[i]=inf;
	int nw=t2.size();i64 res=-inf,sum=0;
	bkt[nw]=0;
	forup(i,1,sz){
		if(l1<(int)t1.size()&&(l2>=(int)t2.size()||t2[l2]>t1[l1])){
			++nw;
			sum+=b[t1[l1]];
			res=max(res,sum-bkt[nw]);
			bkt[nw]=min(bkt[nw],sum);
			++l1;
		}else{
			--nw;
			sum+=b[t2[l2]];
			res=max(res,sum-bkt[nw]);
			bkt[nw]=min(bkt[nw],sum);
			++l2;
		}
	}
	return res;
}
int id[N],ps[N];
signed main(){
//	freopen("ex_sequence2.in","r",stdin);
//	freopen("a.out","w",stdout);
	n=read();q=read();
	forup(i,1,n){
		a[i]=read();
		pos[a[i]].push_back(i);
	}
	forup(i,1,n){
		b[i]=read();
	}
	forup(Case,1,q){
		int x=read(),y=read();
		if(pos[x].size()>pos[y].size()||(pos[x].size()==pos[y].size()&&x>y)) swap(x,y);
		if(mp[x].count(y)){
			ans[Case]=mp[x][y];
			continue;
		}
		if((pos[x].size()<=TT&&pos[y].size()<=TT)||(pos[x].size()>TT&&pos[y].size()>TT)){
			mp[x][y]=ans[Case]=calc(pos[x],pos[y]);
		}else{
			quu[y].push_back(mkp(Case,x));
		}
	}
	forup(y,1,n){
		if(pos[y].size()<=TT) continue;
		forup(i,1,n) pre[i]=(a[i]==y?i:pre[i-1]);
		forup(i,1,n) cnt[i]=cnt[i-1]+(a[i]==y);
		nxt[n+1]=n+1;cnt[n+1]=cnt[n];
		fordown(i,n,1) nxt[i]=(a[i]==y?i:nxt[i+1]);
		ps[1]=0;id[0]=1;
		int cn=1;
		forup(i,1,n){
			if(a[i]==y){
				id[i]=++cn;
				ps[cn]=i;
			}
		}
		id[n+1]=++cn;
		ps[cn]=n+1;
		for(auto i:quu[y]){
			vector<pii> stk;
			int x=i.se,pp=i.fi;
			if(mp[x].count(y)){
				ans[pp]=mp[x][y];
				continue;
			}
			for(auto j:pos[x]){
				pii nw=mkp(pre[j],nxt[j]);
				while(stk.size()&&stk.back().se>=nw.fi){
					pii tp=stk.back();stk.pop_back();
					if(tp.fi<nw.fi) swap(nw.fi,tp.fi);
					if(tp.se>nw.se) swap(nw.se,tp.se);
					int num=cnt[tp.se]-(tp.fi?cnt[tp.fi-1]:0);
					nw.fi=ps[max(id[nw.fi]-num,1)];
					nw.se=ps[min(id[nw.se]+num,cn)];
				}
				stk.push_back(nw);
			}
			vector<int> v1;
			int l=2;
			for(auto j:stk){
				int st=j.fi,ed=j.se;
				if(l<id[st]-1) l=id[st]-1;
				while(l<cn&&l<=id[ed]+1){
					v1.push_back(ps[l++]);
				}
			}
			mp[x][y]=ans[pp]=calc(pos[x],v1);
		}
	}
	forup(i,1,q){
		printf("%lld\n",ans[i]);
	}
}
```

///


## P7739 [NOI2021] 密码箱

[传送门](https://www.luogu.com.cn/problem/P7739)

首先 $f(a)$ 相当于重复 $n-1$ 次把末项取倒数然后加在倒数第二项里再删掉这一项，设现在的末项为 $\frac{x}{y}$，倒数第二项为 $a_{n-1}$，容易发现假如 $\gcd(x,y)=1$，那么 $\gcd(y+a_{n-1}x,x)=1$（即加入下一项后的分子分母），又由于最开始 $y=1$，所以其实并不需要约分，那么只用考虑取模即可。

容易想到 $x,y$ 可以用矩阵乘法维护，先不考虑三种操作，假设序列 $a$ 固定，我们先把矩阵构造出来：

具体的，我们希望构造的矩阵 $A_i$ 满足以下式子：

$$A_i\times \begin{bmatrix}x\\\\y\end{bmatrix}=\begin{bmatrix}y+a_ix\\\\x\end{bmatrix}$$

由于每次是乘最后一个所以我设置为把一个列向量乘在右边，这样每次加入新的操作就是乘在右边的，比较符合直觉。

那么解一解方程，容易发现矩阵 $A_i$ 应该长这样：

$$\begin{bmatrix}a_i&1\\\\1&0\end{bmatrix}$$

---

但是现在 `W`，`E` 两种操作还是不好维护，我们希望这两种操作也能用矩阵概括。

首先是 `W`，我们设它对应的矩阵为 $W$，那么我们希望它满足以下式子：

$$\begin{bmatrix}b&1\\\\1&0\end{bmatrix}\times W=\begin{bmatrix}b+1&1\\\\1&0\end{bmatrix}$$

然后解一解方程可以发现：

$$W=\begin{bmatrix}1&0\\\\1&1\end{bmatrix}$$

但是对于 `E` 操作仍然不好维护，但是假如我们发现对于 $a_n=1$，`E` 的两种操作类型对答案的影响相同的话，就能维护了，记住，转换题意后一定记得回到原题意解题。

由于只要后面的一样就肯定肯定不影响前面的，我们不妨假设现在后面的算出来是 $\frac{x}{y}$，然后前面啥也没有，那么可以简单推一下：

1. 给倒数第二项加一。

$$
\begin{aligned}
f(a_1+1,1,\frac{x}{y})
=&f(a_1+1,\frac{x+y}{x})\\\\
=&f(\frac{(a_1+1)(x+y)+x}{x+y})\\\\
=&\frac{a_1(x+y)+2x+y}{x+y}
\end{aligned}
$$

2. 给最后一项减一，然后添两个 $1$

$$
\begin{aligned}
f(a_1,0,1,1,\frac{x}{y})
=&f(a_1,0,1,\frac{x+y}{x})\\\\
=&f(a_1,0,\frac{2x+y}{x+y})\\\\
=&f(a_1,\frac{x+y}{2x+y})\\\\
=&f(\frac{a_1(x+y)+2x+y}{x+y})\\\\
=&\frac{a_1(x+y)+2x+y}{x+y}
\end{aligned}
$$

显然这两个东西相等，那么 `E` 操作实际上就是：**先给数列的最后一项减 $1$，接着在数列尾再加两项，两项的值都是 $1$。**

那么仿照刚才算 $W$（真的仿了吗？如仿），$E$ 的矩阵如下：

$$E=\begin{bmatrix}1&0\\\\-1&1\end{bmatrix}\times\begin{bmatrix}1&1\\\\1&0\end{bmatrix}\times \begin{bmatrix}1&1\\\\1&0\end{bmatrix}=\begin{bmatrix}2&1\\\\-1&0\end{bmatrix}$$

好了，现在我们已经会维护 `APPEND` 操作了，✿✿ヽ(°▽°)ノ✿。

那么区间翻转和区间反转操作呢？首先翻转操作可以考虑文艺平衡树维护，但是反转操作呢？

其实是一样的，我们对于每个子树预处理**当前矩阵**，**操作反转的矩阵**，**操作翻转的矩阵**，**操作翻转后反转的矩阵**。然后和文艺平衡树一样打标记维护，每次下传标记就 `swap` 一下即可。复杂度 $O((n+q)\log (n+q)2^3)$。

最后考虑一下如何求答案，设最后整个操作序列乘出来的矩阵为 $B$，那么首先在前面乘上初始的两个数（这个很简单），考虑后面乘的一个初始向量是多少，设这个向量为 $V$，那么我们希望：

$$\begin{bmatrix}a_i&1\\\\1&0\end{bmatrix}\times V=\begin{bmatrix}a_i\\\\1\end{bmatrix}$$

容易得到：

$$V=\begin{bmatrix}1\\\\0\end{bmatrix}$$

所以最终答案为：

$$
\begin{aligned}
&A_0\times A_1\times B\times V\\\\
=&\begin{bmatrix}1&0\\\\1&1\end{bmatrix}\times B\times \begin{bmatrix}1\\\\0\end{bmatrix}
\end{aligned}
$$

然后总结一下，以后看到很难维护的操作应该考虑一下能不能转化成矩阵乘法。

/// details | 参考代码 updated on 22 Sept.
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof(a))
#define forup(i,s,e) for(int i=(s);i<=(e);i++)
#define fordown(i,s,e) for(int i=(s);i>=(e);i--)
using namespace std;
#define gc getchar()
inline int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=2e5+5,inf=0x3f3f3f3f,mod=998244353;
int n,q;
char str[N];
void adm(int &a,int b){
	a+=b;
	if(a>=mod) a-=mod;
	if(a<0) a+=mod;
}
struct Matrix{
	int c[2][2];
	Matrix(int _=1,int __=0,int ___=0,int ____=1){
		c[0][0]=_;
		c[0][1]=__;
		c[1][0]=___;
		c[1][1]=____;
	}
	Matrix operator *(const Matrix &b){
		Matrix res(0,0,0,0);
		forup(i,0,1){
			forup(j,0,1){
				forup(k,0,1){
					adm(res.c[i][j],1ll*c[i][k]*b.c[k][j]%mod);
				}
			}
		}
		return res;
	}
}W(1,0,1,1),E(2,1,-1,0);
mt19937 mr(time(0));
struct FHQTreap{
	private:
		int ls[N],rs[N],sz[N],root,cntn,hv[N];
		bool tv[N],itag[N],rtag[N];// true->E false->W
		Matrix ori[N],rev[N],inv[N],rinv[N];
		int _New(bool val){
			int id=++cntn;
			tv[id]=val;
			Matrix p=W,q=E;
			if(val) swap(p,q);
			ori[id]=rev[id]=p;
			inv[id]=rinv[id]=q;
			sz[id]=1;
			ls[id]=rs[id]=0;
			itag[id]=rtag[id]=0;
			hv[id]=mr();
			return id;
		}
		void _PushUp(int id){
			Matrix p=W,q=E;
			if(tv[id]) swap(p,q);
			sz[id]=sz[ls[id]]+1+sz[rs[id]];
			ori[id]=ori[ls[id]]*p*ori[rs[id]];
			inv[id]=inv[ls[id]]*q*inv[rs[id]];
			rev[id]=rev[rs[id]]*p*rev[ls[id]];
			rinv[id]=rinv[rs[id]]*q*rinv[ls[id]];
		}
		void _Reverse(int id){
			swap(ls[id],rs[id]);
			swap(ori[id],rev[id]);
			swap(inv[id],rinv[id]);
		}
		void _Inverse(int id){
			tv[id]^=1;
			swap(ori[id],inv[id]);
			swap(rev[id],rinv[id]);
		}
		void _PushDown(int id){
			if(itag[id]){
				if(ls[id]) _Inverse(ls[id]),itag[ls[id]]^=1;
				if(rs[id]) _Inverse(rs[id]),itag[rs[id]]^=1;
				itag[id]=0;
			}
			if(rtag[id]){
				if(ls[id]) _Reverse(ls[id]),rtag[ls[id]]^=1;
				if(rs[id]) _Reverse(rs[id]),rtag[rs[id]]^=1;
				rtag[id]=0;
			}
		}
		void _Split(int key,int id,int &x,int &y){
			if(!id){
				x=y=0;
				return;
			}
			_PushDown(id);
			if(sz[ls[id]]<key){
				x=id;
				_Split(key-sz[ls[id]]-1,rs[id],rs[x],y);
			}else{
				y=id;
				_Split(key,ls[id],x,ls[y]);
			}
			_PushUp(id);
		}
		int _Merge(int x,int y){
			if(!x||!y) return x|y;
			if(hv[x]>hv[y]){
				_PushDown(x);
				rs[x]=_Merge(rs[x],y);
				_PushUp(x);
				return x;
			}else{
				_PushDown(y);
				ls[y]=_Merge(x,ls[y]);
				_PushUp(y);
				return y;
			}
		}
	public:
		FHQTreap():root(0),cntn(0){}
		void Insert(char c){
			root=_Merge(root,_New(c=='E'));
		}
		void Inverse(int l,int r){
			int x,y,z;
			_Split(l-1,root,x,y);_Split(r-l+1,y,y,z);
			_Inverse(y);itag[y]^=1;
			root=_Merge(_Merge(x,y),z);
		}
		void Reverse(int l,int r){
			int x,y,z;
			_Split(l-1,root,x,y);_Split(r-l+1,y,y,z);
			_Reverse(y);rtag[y]^=1;
			root=_Merge(_Merge(x,y),z);
		}
		Matrix Ask(){
			return ori[root];
		}
}mt;
signed main(){
	n=read();q=read();
	scanf(" %s",str+1);
	forup(i,1,n){
		mt.Insert(str[i]);
	}
	Matrix ans=Matrix(1,0,1,1)*mt.Ask()*Matrix(1,0,0,0);
	printf("%d %d\n",ans.c[0][0],ans.c[1][0]);
	forup(Case,1,q){
		scanf(" %s",str+1);
		if(str[1]=='A'){
			char c;
			scanf(" %1c",&c);
			mt.Insert(c);
		}else if(str[1]=='F'){
			int l=read(),r=read();
			mt.Inverse(l,r);
		}else{
			int l=read(),r=read();
			mt.Reverse(l,r);
		}
		Matrix ans=Matrix(1,0,1,1)*mt.Ask()*Matrix(1,0,0,0);
		printf("%d %d\n",ans.c[0][0],ans.c[1][0]);
	}
}
```

///

## P7518 [省选联考 2021 A/B 卷] 宝石

[传送门](https://www.luogu.com.cn/problem/P7518)

设查询的路径为 $u,v$，且 $\operatorname{lca}(u,v)=t$，那么我们可以把每个询问分成 $u\to t,t\to v$ 三部分。

首先 $u\to t$ 的，这是一段上升的路径，那么我们可以利用倍增跳，具体地，设 $f_{u,i}$ 表示从 $u$ 开始，从 $w_u$ 的后继开始只向上走收集 $2^i$ 个宝石后到达哪个结点，预处理一下 $f_{u,0}$，然后后面就是正常倍增了。

然后考虑 $t\to v$，我们可以把所有询问以二元组 $(c_i,i)$ 离线到 $t$ 上，然后在 $v$ 处打一个结束标记，表示编号为 $i$ 的询问在 $t$ 之前拿到的最后一个宝石为 $c_i$，这里我们需要对每个宝石维护一个容器 $d_i$，表示该容器内所有询问现在最后一颗宝石为 $i$，这个容器具有以下功能：

1. 在进入结点 $k$ 时，将所有 $i$ 插入 $c_i$ 中。
2. 将 $w_k$ 的前驱和 $w_k$ 合并。
3. 对于所有结束标记，查询所在容器。
4. 在退出结点 $k$ 时，撤销所有操作。

显然，可以用可撤销并查集维护，复杂度 $O(q\log n+n\log q)$。

## CF1017G The Tree

[传送门](https://www.luogu.com.cn/problem/CF1017G)

首先，直接做要么修改是 $O(n)$ 的（暴力修改，单点查询），要么查询是 $O(n)$ 的（标记修改，往上跳查询），其中一个会被链卡另一个会被菊花图卡。

那么我们可以考虑均衡一下，让修改和查询都变成 $O(\sqrt{n})$ 的，很自然地想到分块。

思路是将询问分成 $\sqrt{q}$ 块，对于每一块建虚树，然后处理完一块后用虚树上的信息给原树染色。

这样要求块内每个操作复杂度不多于 $O(\sqrt{n})$，对每一块预处理和处理完一块后染色的复杂度不多于 $O(n)$。

首先是建虚树，但是为了维护操作 $1$ 需要处理虚树上每个关键点和它父亲中间有多少个白点，可以很板地（本来想说很简单，但虚树毕竟是个十级算法，还是要尊重一下的）$O(n+\sqrt{q}\log n)$ 处理，符合条件。

然后是三个操作，操作 $3$ 直接查即可，操作 $1$ 维护一下每条边上剩的白点数即可，假如全涂完了就往儿子递归，由于点数不超过 $\sqrt{q}$ 所以复杂度是对的，为了后面染回原树可能要维护一下每条边加了几个黑点，有没有被涂白过。操作 $2$ 就直接遍历即可，三个操作复杂度均不超过 $O(\sqrt{q})$。

然后是染色，我现在臆想的实现是遍历虚树，然后每次定位到原树的这个结点，分有没有涂白过把距离最近的若干个白点涂黑，或者把黑点刷白，复杂度是 $O(\sqrt{q}+n)$ 的。

然后就做完了，估计代码不会太好写。

## CF573E Bear and Bowling

[传送门](https://www.luogu.com.cn/problem/CF573E)

更毒瘤的题来了。

首先有个 $O(n^2)$ DP。

设 $dp_{i,j}$ 表示考虑前 $i$ 个，已经选了 $j$ 个能得到的最大值，转移是简单的：

$$dp_{i,j}=\max(dp_{i-1,j},dp_{i-1,j-1}+a_i\times j)$$

然后这道题由于是 CF 的，考虑到 Java Python 等常数较大的语言，时限开的巨大无比，已经可以日过去了。

但是我可不是那种不求甚解的人呐。

但是这道题还有爆踩标算的 $O(n)$ 贪心做法。可惜这是数据结构专题……

-----

这个方程看起来不太好优化，那么我们考虑猜结论：

$\forall i,\exists k\in[1,i]$，满足：

$$\forall j<k,dp_{i,j}=dp_{i-1,j}\\\\ \forall j\ge k,dp_{i,j}=dp_{i-1,j-1}+a_i\times j$$

证明：

考虑对 $dp_i$ 构造一个差分序列 $f_i$，其中 $f_{i,j}=dp_{i,j}-dp_{i,j-1}$，若猜想成立，则有 $dp_{i,k_i-1}\ge dp_{i-1,k_i-2}+a_i\times (k_i-1)$，且 $dp_{i-1,k_i}<dp_{i-1,k_i-1}+a_i\times k_i$，则 $\frac{f_{i-1,k_i-1}}{k_i-1}\ge a_i$，且 $\frac{f_{i-1,k_i}}{k_i}<a_i$。

容易发现前式对于所有 $j< k_i$ 均成立，后式对于所有 $j\ge k_i$ 均成立，而 $a_i$ 是一个定值，那么若 $\frac{f_{i-1,j}}{j}$ 关于 $j$ 单调不增，猜想成立（考虑假如 $\frac{f_{i-1,j}}{j}$ 全都小于 $a_i$ 那么 $k_i$ 取 $1$，假如全都大于等于 $a_i$ 那么 $k_i$ 取 $i$）。

若猜想成立，那么由 $dp_i$ 的值可知：

$$
\forall j< k_i,f_{i,j}=f_{i-1,j}\\\\
\forall j> k_i,f_{i,j}=f_{i-1,j}+a_i\\\\
f_{i,k_i}=a_i\times k_i
$$

证明考虑数学归纳法。

首先对于 $i=1$， $\frac{f_{i,j}}{j}$ 显然单调不增（长度为 $1$ 的序列显然单调不增吧）。

那么对于 $i=2$，猜想成立。

考虑若猜想成立，证明 $\frac{f_{i,j}}{j}$ 单调不增。

首先对于 $j<k_i$，$f_{i,j}=f_{i-1,j}$，显然单调不增。

对于 $j=k_i$，由于 $\forall j<k_i,\frac{f_{i,j}}{j}=\frac{f_{i-1,j}}{j}\ge a_i$，且 $\frac{f_{i,k_i}}{k_i}=\frac{a_i\times k_i}{k_i}=a_i$，单调性仍然存在。

对于 $j>k_i$：

首先结论长这样：

$$\frac{f_{i,j-1}}{j-1}>\frac{f_{i,j}}{j}$$

考虑 $f_{i,j-1}=f_{i-1,j-2}+a_i,f_{i,j}=f_{i-1,j-1}+a_i$。

那么上不等式等价于：

$$
\begin{aligned}
\frac{f_{i-1,j-2}+a_i}{j-1}&>\frac{f_{i-1,j-1}+a_i}{j}\\\\
f_{i-1,j-2}+a_i&>\frac{j-1}{j}(f_{i-1,j-1}+a_i)\\\\
f_{i-1,j-2}+a_i&>\frac{j-1}{j}f_{i-1,j-1}+\frac{j-1}{j}a_i\\\\
f_{i-1,j-2}&>\frac{j-1}{j}f_{i-1,j-1}-\frac{1}{j}a_i\\\\
\end{aligned}
$$

由于 $\frac{f_{i-1,j}}{j}\ge\frac{f_{i-1,j+1}}{j+1}$，那么 $f_{i-1,j}\ge \frac{j}{j+1}f_{i-1,j+1}$，所以 $f_{i-1,j-2}\ge\frac{j-2}{j-1}f_{i-1,j-1}$，那么：

$$
\begin{aligned}
&f_{i-1,j-2}-(\frac{j-1}{j}f_{i-1,j-1}-\frac{1}{j}a_i)\\\\
\ge&\frac{j-2}{j-1}f_{i-1,j-1}-(\frac{j-1}{j}f_{i-1,j-1}-\frac{1}{j}a_i)\\\\
=&\frac{\left[j(j-2)-(j-1)^2\right]f_{i-1,j-1}+(j-1)a_i}{j(j-1)}\\\\
=&\frac{(j-1)a_i-f_{i-1,j-1}}{j(j-1)}\\\\
\end{aligned}
$$

由于 $j>k_i$，则 $j-1\ge k_i$，那么 $\frac{f_{i-1,j-1}}{j-1}< a_i$（见前文），故 $(j-1)a_i-f_{i-1,j-1}>0$，则上式 $>0$。

故 $\frac{f_{i,j-1}}{j-1}>\frac{f_{i,j}}{j}$。

---

那么我们已经证出这个性质了，这个性质有什么用呢？考虑我们之前的推论：

$$
\forall j< k_i,f_{i,j}=f_{i-1,j}\\\\
\forall j> k_i,f_{i,j}=f_{i-1,j}+a_i\\\\
f_{i,k_i}=a_i\times k_i
$$

容易发现 $f_i$ 相当于前半部分继承 $f_{i-1}$，中间插入一个 $a_i\times k_i$，后半部分整体加上 $a_i$。

容易发现这是文艺平衡树能维护的信息，而且 $k_i$ 可以二分找到，那么直接闭着眼睛拍一棵文艺平衡树不就完了吗。

复杂度 $O(n\log n)$。

## P7811 [JRKSJ R2] 你的名字。

[传送门](https://www.luogu.com.cn/problem/P7811)

建议改为：【模板】比较毒瘤的根号分治（话说根号分治/根号均摊毕竟是一种思维方式，不太好找模板）

我不太喜欢这种码量远大于思维量的题，但在学校这样的题真的是消磨时间的好方法。

可以说是本套题里面最毒瘤的了。

---

看到取模运算应该先想到根号分治。

首先设一个阈值 $T$。

---
对于 $k\le T$，这样的 $k$ 最多有 $T$ 个，那么我们可以把询问离线挂到 $k$ 上，对于每个 $k$ 预处理 $a_i\bmod k$ 的区间最大值，线段树建树是 $O(n)$ 的，然后查询复杂度和询问次数有关，我们暂且记单次查询是 $O(\log n)$ 的，等会跟后面的操作取 $\max$，这部分总复杂度 $O(Tn)$。

---
对于 $k>T$，这部分就难搞了。

首先这样的 $k$ 的倍数个数肯定 $\le \frac{n}{T}$ 吧。

那么我们大体思路就是维护大于每个倍数 $p$ 的区间最小值。

具体一点，给序列里的数 $a$ 和所有倍数 $p$ 放到一起排序，从大到小扫一遍，每次遇到 $a$ 就插入一个支持区间查最小值的数据结构里，遇到 $p$ 就查询。

那么我们先考虑数据结构的选择，查询的次数上界是 $q\frac{V}{T}$，那我们询问只能是 $O(1)$ 的。考虑猫树或者 ST 表。但是我不会猫树，直接考虑 ST 表。

但是这里又有个问题，ST 不能快速地插入新数据，复杂度最优是 $O(n)$ 的（$2^0+2^1+\dots +2^{\log n}=n$）。那么我们又考虑根号均摊，先分块求出每一块的最小值，然后对块建立 ST 表，设块长为 $L$，这样复杂度就降到 $O(\frac{n}{L})$ 的了，然后对于散块我们可以 $O(L)$ 预处理前后缀最小值，这样查询就是 $O(1)$ 的了，对于每个询问就是 $O(\frac{V}{T})$ 的。

这又涉及到一个问题，假如某区间左右端点都在同一块里应该怎么做。这个操作需要我们跳出思维的陷阱，既然都在同一块里了那直接暴力复杂度是 $O(L)$ 的，我们把在同一块里的额外离线下来。

OK 刨开这个问题，我们又有另一个问题，这道题卡空间。

刚刚我们构想的算法空间复杂度是 $O(q\frac{V}{T})$ 的，这道题空间限制是 128MB，进行一些简单的计算容易发现最多开 $128\times 1024\times 1024\times \frac{1}{4}=33554432$ 个 `int` 型变量。如果要保证空间 $T$ 至少要开到 $\frac{q\times V}{33554432}\approx 900$，而且再算上栈空间之类的 $T$ 至少要开到 $2000$，那么前面 $O(Tn)$ 的时间复杂度就超了。

所以我们不能试图通过调整块长的方法解决空间问题。

那么考虑换一种思路。我们一眼就看到这道题值域比较小，那么我们把 $a$ 挂在值域上然后从大到小枚举每个数，对于每个数可以 $O(\sqrt{V})$ 地枚举因子，这样时间复杂度就在外部加上了一个 $O(V\sqrt{V})$，但是空间复杂度变成 $O(n+q)$ 的了，可以接受。

---

综合来说，我们分成三部分考虑：

1. $r-l+1\le L$，直接暴力。
2. $k\le T$，见上文第一类
3. $k> T$ 见上文第二类。


然后分析一下块长，这样做下来复杂度是 $O(V\sqrt{V}+q\max(\frac{V}{T},L)+\frac{n^2}{L}+Tn)$ 的。

由于不带 $\log$，我们考虑 $L$ 取 $\sqrt{n}$，$T$ 取 $\sqrt{V}$，那么复杂度就是 $O((n+V)\sqrt{V}+(n+q)\sqrt{n})$ 的了（大道至简了属于是）。

思维难度不高，但代码难度我的评价是毒瘤炒毒瘤佐炭烤毒瘤伴毒瘤酱，还配的是毒瘤酒调上毒瘤果汁，饭后甜点是毒瘤蛋糕加毒瘤布丁。

这道题代码的优先级估计得往后放一放。