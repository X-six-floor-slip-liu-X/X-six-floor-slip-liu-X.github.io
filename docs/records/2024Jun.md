---
comments: true
---

# 2024 6 月 杂题

鹅同节快乐。

## AT_dwacon5th_prelims_d Square Rotation

[传送门](https://www.luogu.com.cn/problem/AT_dwacon5th_prelims_d)

> 题意

- 在无限大的二维平面中有 $N$ 个黑点：$(x_1,y_1),(x_2,y_2),\dots,(x_N,y_N)$，剩余的点均为白点，你可以按以下规则进行无限次操作：
    - 选择一个边长为 $D$ 的正方形，并将其四个角上的点进行旋转，具体来说选择了一个左下角 $(x,y)$ 的正方形，会按以下顺序旋转：$(x,y)\rightarrow(x+D,y)\rightarrow(x+D,y+D)\rightarrow(x,y+D)\rightarrow(x,y)$
- 你需要通过任意次操作使得平面上切比雪夫距离最远的两黑点的距离最小，并输出这一最小距离。
- $2\le N\le 10^5,1\le D\le 1000$

> 题解

妙妙题。

乍一看一点思路都没有，考虑手模一下。

容易发现，这个修改方式只限制了每个点 $(x,y)$ 只能移动到 $(x',y')$ 满足 $x'\equiv x\pmod D,y'\equiv y\pmod D$，在满足这个条件的情况下是可以随便动的。具体构造考虑先把点移到充分远的地方，然后一个一个挪过来。

那么我们就只关心每个同余类有多少个黑点了。

容易发现这是一个**最小化最大值**的问题，考虑二分答案。那么思考如何 check。

首先切比雪夫距离最小可以认为是用一个正方形把所有点框住，考虑枚举正方形的左下角。

容易发现，同一个同余类在正方形中的出现次数只有三种（设正方形边长为 $L$，那么分别是 $\left\lfloor\frac{(L+1)}{D}\right\rfloor^2,(\left\lfloor\frac{(L+1)}{D}\right\rfloor+1)^2,\left\lfloor\frac{(L+1)}{D}\right\rfloor\times (\left\lfloor\frac{(L+1)}{D}\right\rfloor+1)$），并且三种分别是四个连续的矩形。于是容易想到用前缀和维护矩形内满足条件的同余类个数。

于是做完了，复杂度 $O(N+D^2\log V)$，其中 $V$ 是值域。这个已经能过了。

有没有更强力的做法？

考虑 $(\left\lfloor\frac{(L+1)}{D}\right\rfloor+1)^2$ 必须大于等于出现最多的同余类出现次数，而 $\left\lfloor\frac{(L+1)}{D}\right\rfloor^2$ 必定能小于等于出现最多的同余类出现次数，那么不妨设正方形边长为 $aD+b$，其中 $0\le b< D,a=\left\lceil\sqrt{mx}\right\rceil-1$，其中 $mx$ 是出现次数最多的同余类出现次数。

然后容易发现那个前缀和就不会变了，只是每次找的四个矩形会变。于是可以考虑先把 $b$ 赋为 $D-1$，枚举左下角然后每次尝试缩小 $b$，复杂度就缩到了 $O(N+D^2)$（注意到 $b$ 只会缩 $D$ 次，小于 $O(D^2)$）。

/// details | 参考代码
    open: False
    type: success

$O(N+D^2\log V)$

```cpp
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof(a))
#define forup(i,s,e) for(int i=(s);i<=(e);i++)
#define fordown(i,s,e) for(int i=(s);i>=(e);i--)
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
#define gc getchar()
inline int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=1005,inf=0x3f3f3f3f;
int n,d,cnt[N<<1][N<<1];
int sum[3][N<<1][N<<1];
int calc(int x1,int y1,int x2,int y2,int p){
	if(x2<x1||y2<y1) return 0;
	return sum[p][x2][y2]-(x1?sum[p][x1-1][y2]:0)-(y1?sum[p][x2][y1-1]:0)+(x1&&y1?sum[p][x1-1][y1-1]:0);
}
bool chk(int mm){
	int p=(mm+1)/d;
	forup(i,0,d*2-1){
		forup(j,0,d*2-1){
			sum[0][i][j]=(1ll*(p+1)*(p+1)>=cnt[i][j]);
			sum[1][i][j]=(1ll*p*(p+1)>=cnt[i][j]);
			sum[2][i][j]=(1ll*p*p>=cnt[i][j]);
			forup(k,0,2){
				if(i) sum[k][i][j]+=sum[k][i-1][j];
				if(j) sum[k][i][j]+=sum[k][i][j-1];
				if(i&&j) sum[k][i][j]-=sum[k][i-1][j-1];
			}
		}
	}
	forup(i,0,d*2-1){
		forup(j,0,d*2-1){
			msg("%d ",sum[2][i][j]);
		}msg("|\n");
	}
	int t=(mm+1)%d;
	msg("%d %d||\n",t,d);
	forup(x,0,d-1){
		forup(y,0,d-1){
			msg("%d %d %d||\n",x,y,calc(x,y,x+t-1,y+t-1,0)+calc(x+t,y,x+d-1,y+t-1,1)+calc(x,y+t,x+t-1,y+d-1,1)+calc(x+t,y+t,x+d-1,y+d-1,2));
			if(calc(x,y,x+t-1,y+t-1,0)+calc(x+t,y,x+d-1,y+t-1,1)+calc(x,y+t,x+t-1,y+d-1,1)+calc(x+t,y+t,x+d-1,y+d-1,2)==d*d) return true;
		}
	}
	return false;
}
signed main(){
	n=read();d=read();
	forup(i,1,n){
		int x=read(),y=read();
		++cnt[x%d][y%d];
	}
	forup(i,0,d-1){
		forup(j,0,d-1){
			cnt[i+d][j]=cnt[i][j+d]=cnt[i+d][j+d]=cnt[i][j];
		}
	}
	int ll=1,rr=1e9,mm;
	while(ll<rr){
		msg("%d %d====\n",ll,rr);
		mm=(ll+rr)>>1;
		if(chk(mm)) rr=mm;
		else ll=mm+1;
	}
	printf("%d\n",ll);
}
```

$O(N+D^2)$

```cpp
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof(a))
#define forup(i,s,e) for(int i=(s);i<=(e);i++)
#define fordown(i,s,e) for(int i=(s);i>=(e);i--)
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
#define gc getchar()
inline int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=1005,inf=0x3f3f3f3f;
int n,d,cnt[N<<1][N<<1];
int sum[3][N<<1][N<<1];
int calc(int x1,int y1,int x2,int y2,int p){
	if(x2<x1||y2<y1) return 0;
	return sum[p][x2][y2]-(x1?sum[p][x1-1][y2]:0)-(y1?sum[p][x2][y1-1]:0)+(x1&&y1?sum[p][x1-1][y1-1]:0);
}
bool chk(int x,int y,int t){
	return calc(x,y,x+t-1,y+t-1,0)+calc(x+t,y,x+d-1,y+t-1,1)+calc(x,y+t,x+t-1,y+d-1,1)+calc(x+t,y+t,x+d-1,y+d-1,2)==d*d;
}
signed main(){
	n=read();d=read();
	forup(i,1,n){
		int x=read(),y=read();
		++cnt[x%d][y%d];
	}
	int mx=0; 
	forup(i,0,d-1){
		forup(j,0,d-1){
			mx=max(mx,cnt[i][j]);
			cnt[i+d][j]=cnt[i][j+d]=cnt[i+d][j+d]=cnt[i][j];
		}
	}
	int a=ceil(sqrt(mx))-1,b=d-1;
	forup(i,0,d*2-1){
		forup(j,0,d*2-1){
			sum[0][i][j]=(1ll*(a+1)*(a+1)>=cnt[i][j]);
			sum[1][i][j]=(1ll*a*(a+1)>=cnt[i][j]);
			sum[2][i][j]=(1ll*a*a>=cnt[i][j]);
			forup(k,0,2){
				if(i) sum[k][i][j]+=sum[k][i-1][j];
				if(j) sum[k][i][j]+=sum[k][i][j-1];
				if(i&&j) sum[k][i][j]-=sum[k][i-1][j-1];
			}
		}
	}
	forup(x,0,d-1){
		forup(y,0,d-1){
			while(b>0&&chk(x,y,b)) --b;
		}
	}
	printf("%d\n",a*d+b);
}
```

///

## AT_dwacon6th_prelims_e Span Covering

[传送门](https://www.luogu.com.cn/problem/AT_dwacon6th_prelims_e)

![图示 1](../img/2024Jun_1.png)

图源模拟赛题解。

> 题意

- 你有一个区间 $[0,X)$，还有 $n$ 个黑色纸条，第 $i$ 个纸条长度为 $l_i$。
- 一张纸条可以覆盖一段 $[j,j+l_i)$ 的区间，纸条间可以重合。问有多少把所有纸条放完的方案能覆盖整个区间。
- $1\le n\le 100,1\le X\le 500$，对 $10^9+7$ 取模。

> 题解

貌似是套路题啊，赛时好多人都切了。

首先这种放若干个区间的可以考虑从长的开始放。这样就不会有后面的把前面的完全覆盖掉（恰好等长不算）的情况了。

那么任意一个时刻，显然纸条都会连成若干个连续块。

因为最后一定是连成一坨的，我们其实可以不关心每个纸条在序列上的具体位置，只用关心每个连续块内纸条的相对位置以及连续块的顺序。

那么容易想到一个 DP，设 $f_{i,j,k}$ 表示考虑前 $i$ 个（从大到小排序）纸条，形成了 $j$ 个连续块，总长度为 $k$ 的方案数。

然后分四种情况转移：

- 完全放在之前一块内：每一块都有 $l_i-1$ 个位置不能放，于是 $f_{i,j,k}\gets f_{i-1,j,k}\times (k-j(l_i-1))$。
- 与之前任何一块都不相交（挨着也算相交）：有 $j$ 个空格可以塞，于是 $f_{i,j,k}\gets f_{i-1,j-1,k-l_i}\times j$
- 与之前某一块相交：先枚举将那个块延长了多少，每一块可以向左或向右延长，于是 $f_{i,j,k}\gets \sum_{t=1}^{l_i}f_{i-1,j,k-t}\times 2(j-1)$。
- 将两块连在一起：还是枚举连起来两个块的距离，然后容易发现对于距离为 $t$，有 $l_i-t+1$ 种不同的放法，于是 $f_{i,j,k}\gets \sum_{t=1}^{l_i}f_{i-1,j+1,k-t}\times (j-1)(l_i-t+1)$。

然后容易发现对于 $l_i$，最多有 $\left\lfloor\frac{x}{l_i}\right\rfloor$ 段，原因是之前每一段长度都大于等于 $l_i$，DP 第一维有 $n$ 种，第二维有 $\left\lfloor\frac{x}{l_i}\right\rfloor$ 种，第三维有 $x$ 种，转移复杂度为 $l_i$，于是总复杂度 $O(nX^2)$。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof(a))
#define forup(i,s,e) for(int i=(s);i<=(e);i++)
#define fordown(i,s,e) for(int i=(s);i>=(e);i--)
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
#define gc getchar()
inline int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=505,inf=0x3f3f3f3f,mod=1e9+7;
int n,m,l[N],dp[2][N][N];
signed main(){
	n=read();m=read();
	forup(i,1,n){
		l[i]=read();
	}
	sort(l+1,l+n+1,greater<int>());
	dp[1][1][l[1]]=1;
	forup(i,2,n){
		int p=i&1,q=p^1;
		forup(j,1,m/l[i-1]+1){
			forup(k,1,m){
				(dp[p][j][k]+=1ll*dp[q][j][k]*(k-(l[i]-1)*j)%mod)%=mod;
				if(k+l[i]<=m) (dp[p][j+1][k+l[i]]+=1ll*dp[q][j][k]*(j+1)%mod)%=mod;
				forup(t,1,l[i]){
					if(k+t>m) break;
					(dp[p][j][k+t]+=2ll*dp[q][j][k]*j%mod)%=mod;
					(dp[p][j-1][k+t]+=1ll*dp[q][j][k]*(j-1)%mod*(l[i]-t+1)%mod)%=mod;
				}
				dp[q][j][k]=0;
			}
		}
	}
	printf("%d\n",dp[n&1][1][m]);
}
```

///