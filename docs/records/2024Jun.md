---
comments: true
---

# 2024 6 月 杂题

鹅同节快乐。

## AT_dwacon5th_prelims_d Square Rotation

[传送门](https://www.luogu.com.cn/problem/AT_dwacon5th_prelims_d)

> 题意

- 在无限大的二维平面中有 $N$ 个黑点：$(x_1,y_1),(x_2,y_2),\dots,(x_N,y_N)$，剩余的点均为白点，你可以按以下规则进行无限次操作：
    - 选择一个边长为 $D$ 的正方形，并将其四个角上的点进行旋转，具体来说选择了一个左下角 $(x,y)$ 的正方形，会按以下顺序旋转：$(x,y)\rightarrow(x+D,y)\rightarrow(x+D,y+D)\rightarrow(x,y+D)\rightarrow(x,y)$
- 你需要通过任意次操作使得平面上切比雪夫距离最远的两黑点的距离最小，并输出这一最小距离。
- $2\le N\le 10^5,1\le D\le 1000$

> 题解

妙妙题。

乍一看一点思路都没有，考虑手模一下。

容易发现，这个修改方式只限制了每个点 $(x,y)$ 只能移动到 $(x',y')$ 满足 $x'\equiv x\pmod D,y'\equiv y\pmod D$，在满足这个条件的情况下是可以随便动的。具体构造考虑先把点移到充分远的地方，然后一个一个挪过来。

那么我们就只关心每个同余类有多少个黑点了。

容易发现这是一个**最小化最大值**的问题，考虑二分答案。那么思考如何 check。

首先切比雪夫距离最小可以认为是用一个正方形把所有点框住，考虑枚举正方形的左下角。

容易发现，同一个同余类在正方形中的出现次数只有三种（设正方形边长为 $L$，那么分别是 $\left\lfloor\frac{(L+1)}{D}\right\rfloor^2,(\left\lfloor\frac{(L+1)}{D}\right\rfloor+1)^2,\left\lfloor\frac{(L+1)}{D}\right\rfloor\times (\left\lfloor\frac{(L+1)}{D}\right\rfloor+1)$），并且三种分别是四个连续的矩形。于是容易想到用前缀和维护矩形内满足条件的同余类个数。

于是做完了，复杂度 $O(N+D^2\log V)$，其中 $V$ 是值域。这个已经能过了。

有没有更强力的做法？

考虑 $(\left\lfloor\frac{(L+1)}{D}\right\rfloor+1)^2$ 必须大于等于出现最多的同余类出现次数，而 $\left\lfloor\frac{(L+1)}{D}\right\rfloor^2$ 必定能小于等于出现最多的同余类出现次数，那么不妨设正方形边长为 $aD+b$，其中 $0\le b< D,a=\left\lceil\sqrt{mx}\right\rceil-1$，其中 $mx$ 是出现次数最多的同余类出现次数。

然后容易发现那个前缀和就不会变了，只是每次找的四个矩形会变。于是可以考虑先把 $b$ 赋为 $D-1$，枚举左下角然后每次尝试缩小 $b$，复杂度就缩到了 $O(N+D^2)$（因为 $b$ 只会缩 $D$ 次）。

/// details | 参考代码
    open: False
    type: success

$O(N+D^2\log V)$

```cpp
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof(a))
#define forup(i,s,e) for(int i=(s);i<=(e);i++)
#define fordown(i,s,e) for(int i=(s);i>=(e);i--)
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
#define gc getchar()
inline int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=1005,inf=0x3f3f3f3f;
int n,d,cnt[N<<1][N<<1];
int sum[3][N<<1][N<<1];
int calc(int x1,int y1,int x2,int y2,int p){
	if(x2<x1||y2<y1) return 0;
	return sum[p][x2][y2]-(x1?sum[p][x1-1][y2]:0)-(y1?sum[p][x2][y1-1]:0)+(x1&&y1?sum[p][x1-1][y1-1]:0);
}
bool chk(int mm){
	int p=(mm+1)/d;
	forup(i,0,d*2-1){
		forup(j,0,d*2-1){
			sum[0][i][j]=(1ll*(p+1)*(p+1)>=cnt[i][j]);
			sum[1][i][j]=(1ll*p*(p+1)>=cnt[i][j]);
			sum[2][i][j]=(1ll*p*p>=cnt[i][j]);
			forup(k,0,2){
				if(i) sum[k][i][j]+=sum[k][i-1][j];
				if(j) sum[k][i][j]+=sum[k][i][j-1];
				if(i&&j) sum[k][i][j]-=sum[k][i-1][j-1];
			}
		}
	}
	forup(i,0,d*2-1){
		forup(j,0,d*2-1){
			msg("%d ",sum[2][i][j]);
		}msg("|\n");
	}
	int t=(mm+1)%d;
	msg("%d %d||\n",t,d);
	forup(x,0,d-1){
		forup(y,0,d-1){
			msg("%d %d %d||\n",x,y,calc(x,y,x+t-1,y+t-1,0)+calc(x+t,y,x+d-1,y+t-1,1)+calc(x,y+t,x+t-1,y+d-1,1)+calc(x+t,y+t,x+d-1,y+d-1,2));
			if(calc(x,y,x+t-1,y+t-1,0)+calc(x+t,y,x+d-1,y+t-1,1)+calc(x,y+t,x+t-1,y+d-1,1)+calc(x+t,y+t,x+d-1,y+d-1,2)==d*d) return true;
		}
	}
	return false;
}
signed main(){
	n=read();d=read();
	forup(i,1,n){
		int x=read(),y=read();
		++cnt[x%d][y%d];
	}
	forup(i,0,d-1){
		forup(j,0,d-1){
			cnt[i+d][j]=cnt[i][j+d]=cnt[i+d][j+d]=cnt[i][j];
		}
	}
	int ll=1,rr=1e9,mm;
	while(ll<rr){
		msg("%d %d====\n",ll,rr);
		mm=(ll+rr)>>1;
		if(chk(mm)) rr=mm;
		else ll=mm+1;
	}
	printf("%d\n",ll);
}
```

$O(N+D^2)$

```cpp
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof(a))
#define forup(i,s,e) for(int i=(s);i<=(e);i++)
#define fordown(i,s,e) for(int i=(s);i>=(e);i--)
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
#define gc getchar()
inline int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=1005,inf=0x3f3f3f3f;
int n,d,cnt[N<<1][N<<1];
int sum[3][N<<1][N<<1];
int calc(int x1,int y1,int x2,int y2,int p){
	if(x2<x1||y2<y1) return 0;
	return sum[p][x2][y2]-(x1?sum[p][x1-1][y2]:0)-(y1?sum[p][x2][y1-1]:0)+(x1&&y1?sum[p][x1-1][y1-1]:0);
}
bool chk(int x,int y,int t){
	return calc(x,y,x+t-1,y+t-1,0)+calc(x+t,y,x+d-1,y+t-1,1)+calc(x,y+t,x+t-1,y+d-1,1)+calc(x+t,y+t,x+d-1,y+d-1,2)==d*d;
}
signed main(){
	n=read();d=read();
	forup(i,1,n){
		int x=read(),y=read();
		++cnt[x%d][y%d];
	}
	int mx=0; 
	forup(i,0,d-1){
		forup(j,0,d-1){
			mx=max(mx,cnt[i][j]);
			cnt[i+d][j]=cnt[i][j+d]=cnt[i+d][j+d]=cnt[i][j];
		}
	}
	int a=ceil(sqrt(mx))-1,b=d-1;
	forup(i,0,d*2-1){
		forup(j,0,d*2-1){
			sum[0][i][j]=(1ll*(a+1)*(a+1)>=cnt[i][j]);
			sum[1][i][j]=(1ll*a*(a+1)>=cnt[i][j]);
			sum[2][i][j]=(1ll*a*a>=cnt[i][j]);
			forup(k,0,2){
				if(i) sum[k][i][j]+=sum[k][i-1][j];
				if(j) sum[k][i][j]+=sum[k][i][j-1];
				if(i&&j) sum[k][i][j]-=sum[k][i-1][j-1];
			}
		}
	}
	forup(x,0,d-1){
		forup(y,0,d-1){
			while(b>0&&chk(x,y,b)) --b;
		}
	}
	printf("%d\n",a*d+b);
}
```

///