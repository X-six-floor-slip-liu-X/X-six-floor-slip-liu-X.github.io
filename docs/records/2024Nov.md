---
comments: true
---

# 2024 年 11 月杂题

## 前言

模拟赛其实是在保护地球，因为少考一场模拟赛地球就爆炸了，同理晚自习训练是在保护银河系，因为少做一次晚自习训练银河系就毁灭了。

## P4352 [CERC2015] Greenhouse Growth

[传送门](https://www.luogu.com.cn/problem/P4352)

> 题意

- 给定一个长度为 $n$ 的序列 $a$，现在有 $m$ 个操作，每个操作如下：
    - 从左到右枚举 $i$，若 $a_i < a_{i-1}$ 则 $a_i\gets a_i+1$，否则不进行任何操作。
    - 从右到左枚举 $i$，若 $a_i < a_{i+1}$ 则 $a_i\gets a_i+1$，否则不进行任何操作。
- 求 $m$ 个操作后的最终序列。

> 题解

首先容易想到相同数字的连续段会同时增加，所以我们可以把相同数字的连续段视为一个点。不难发现，这样的连续段会依次合并。注意到合并次数显然是 $O(m)$ 的，于是考虑能不能维护段的合并。

一段在操作一中会加一当且仅当其左侧相邻的段严格大于它，操作二同理，于是我们可以对每一段维护一个二元组 $(a,b)(a,b\in\begin{Bmatrix}0,1\end{Bmatrix})$。自己手玩一下就能发现，若相邻的两段 $u,v$ 合并，那么除去合并得到的新一段外，每一段的 $(a,b)$ 是不变的，我们发现，**修改的信息量是 $O(1)$ 的**，那么我们只要能快速找出合并点即可。

考虑相邻两段的间隔，容易发现这两段只有在某个操作对这两段的影响不同时才可能合并，那么我们不妨对每个分界点再维护一个二元组 $(l,r)$ 表示操作 $1/2$ 是否会让这两段的差减小，再加上一些前缀和之类的操作我们就能 $O(1)$ 计算合并时间了，并且根据刚才的结论，显然需要修改的 $(l,r)$ 也是 $O(1)$ 的。

注意到经过多次合并，某一段的变化量应该是一个分段函数，但是显然我们只需要保留当前时刻最后一段，因为无论是计算合并还是计算最终答案，必然都只和最后一段有关。

那么我们只需要每次找出最早合并的两段，将其合并后更新其他段即可，段的合并可以使用双向链表维护。“找出最早合并的两段”可以使用堆做到 $O((n+m)\log m)$ 或者直接存下每个时刻的合并点做到 $O(n+m)$，但因为要用 `std::vector` 之类的东西我感觉不见得会比带 $\log$ 的快。所以我写的带 $\log$ 的。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=3e5+5,inf=0x3f3f3f3f;
int n,m,a[N],b[N];
char str[N];
int cntn=0;
struct Node{
    int pre,nxt,lf,rt,l,r,st,be;
}s[N];
int val[N];
priority_queue<pii,vector<pii>,greater<pii> > q;
int posl[N],posr[N];
int sumb[N];
int get(int u,int t){
    int len=t-s[u].be,ca=sumb[t]-sumb[s[u].be];
    return ca*s[u].lf+(len-ca)*s[u].rt;
}
int calc(int u,int t){
    if(!u) return 0;
    return s[u].st+get(u,t);
}
void work(int u){
    int v=s[u].pre;
    int l=s[u].lf^s[v].lf,r=s[u].rt^s[v].rt,hu=s[u].st,hv=s[v].st;
    int t=max(s[u].be,s[v].be),len=m-t,ca=sumb[m]-sumb[t];
    if(s[u].be<t){
        hu+=get(u,t);
    }
    if(s[v].be<t){
        hv+=get(v,t);
    }
    int sub=abs(hu-hv);
    val[u]=inf;
    if(l&&r){
        if(sub<=len){
            val[u]=sub+t;
            q.push(mkp(val[u],u));
        }
    }else if(l){
        if(sub<=ca){
            val[u]=posl[sub+sumb[t]];
            q.push(mkp(val[u],u));
        }
    }else if(r){
        if(sub<=len-ca){
            val[u]=posr[sub+t-sumb[t]];
            q.push(mkp(val[u],u));
        }
    }
}
signed main(){
    n=read();m=read();
    forup(i,1,n){
        a[i]=read();
    }
    scanf(" %s",str+1);
    forup(i,1,m){
        b[i]=(str[i]=='A');
        sumb[i]=sumb[i-1]+b[i];
        if(b[i]){
            posl[sumb[i]]=i;
        }else{
            posr[i-sumb[i]]=i;
        }
    }
    int lst=1;
    forup(i,1,n){
        if(a[i]!=a[lst]){
            ++cntn;
            s[cntn].l=lst;s[cntn].r=i-1;
            s[cntn].pre=cntn-1;
            s[cntn].st=a[lst];
            s[cntn].be=0;
            s[cntn].lf=a[lst-1]>a[lst];
            s[cntn-1].nxt=cntn;
            s[cntn-1].rt=a[lst]>a[lst-1];
            lst=i;
        }
    }
    if(lst==1){
        forup(i,1,n){
            printf("%d ",a[i]);
        }
        return 0;
    }
    ++cntn;
    s[cntn].l=lst;s[cntn].r=n;
    s[cntn].pre=cntn-1;
    s[cntn].st=a[lst];
    s[cntn].lf=a[lst-1]>a[lst];
    s[cntn-1].nxt=cntn;
    s[cntn-1].rt=a[lst]>a[lst-1];
    s[0].pre=cntn;
    forup(i,2,cntn){
        work(i);
    }
    while(q.size()){
        int u=q.top().se,vv=q.top().fi;q.pop();
        if(val[u]!=vv) continue;
        int v=s[u].pre,pp=s[v].pre,nn=s[u].nxt,t=val[u];
        val[u]=inf;
        int hp=calc(pp,t),hn=calc(nn,t),hh=calc(u,t);
        s[v].r=s[u].r;
        s[v].nxt=nn;s[nn].pre=v;
        s[v].lf=hp>hh;s[v].rt=hn>hh;
        s[v].st=hh;s[v].be=t;
        if(pp){
            s[pp].rt=hh>hp;s[pp].st=hp;s[pp].be=t;
            work(v);
        }
        if(nn){
            s[nn].lf=hh>hn;s[nn].st=hn;s[nn].be=t;
            work(nn);
        }
    }
    for(int i=s[0].nxt;i;i=s[i].nxt){
        int val=calc(i,m);
        forup(j,s[i].l,s[i].r){
            printf("%d ",val);
        }
    }
    puts("");
}
```

///

## P4006 小 Y 和二叉树

[传送门](https://www.luogu.com.cn/problem/P4006)

> 题意

- 给定一棵二叉树，但是我们不知道哪个点是根，也不知道每个点的左右儿子分别是哪一个。
- 现在需要你定一个根，并且为每个点确定左右儿子，使得这棵树的中序遍历的字典序最小。
- $1\le n\le 10^6$，每个点的度数不超过 $3$。

> 题解

最小化字典序，很难不想到贪心。

考虑中序遍历第一个点 $k$ 肯定是确定的，即**编号最小的度数小于等于 $2$ 的点**。

于是考虑逐个往上确定父亲，对于每个点，若（除去上一个点到这个点的连边以外，下同）只连了一条边，那么要么这个点就是根，要么下一个点是这个点的父亲，取决于下一个点**作为子树能得到的字典序最小值的第一个点**是否小于它，同样地，若连了两条边，则要考虑哪个是父亲，显然是**作为子树能得到的字典序最小值的第一个点**更大的那个。

那么我们需要确定这个值，显然只需要以 $k$ 为根简单 DP 就行了。

复杂度 $O(n)$，常数略大。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=1e6+5;
int n;
vector<int> e[N];
int rt,dp[N];
void dfs(int x,int fa){
    dp[x]=n+1;
    int cnt=0;
    for(auto i:e[x]){
        if(i==fa) continue;
        ++cnt;
        dfs(i,x);
        dp[x]=min(dp[x],dp[i]);
    }
    if(cnt<2){
        dp[x]=min(dp[x],x);
    }
}
void print(int x,int fa){
    vector<int> son;
    for(auto i:e[x]){
        if(i==fa) continue;
        son.push_back(i);
    }
    if(son.empty()){
        printf("%d ",x);
    }else if(son.size()==2){
        if(dp[son[0]]>dp[son[1]]) swap(son[0],son[1]);
        print(son[0],x);
        printf("%d ",x);
        print(son[1],x);
    }else{
        if(dp[son[0]]>x){
            printf("%d ",x);
            print(son[0],x);
        }else{
            print(son[0],x);
            printf("%d ",x);
        }
    }

}
void work(int x,int fa){
    vector<int> son;
    for(auto i:e[x]){
        if(i==fa) continue;
        son.push_back(i);
    }
    printf("%d ",x);
    if(son.empty()){
        return;
    }else if(son.size()==1){
        int v=son[0];
        if(v>dp[v]){
            print(v,x);
        }else{
            work(v,x);
        }
    }else{
        if(dp[son[0]]>dp[son[1]]) swap(son[0],son[1]);
        print(son[0],x);
        work(son[1],x);
    }
}
signed main(){
    n=read();
    forup(u,1,n){
        int k=read();
        if(k<=2&&!rt){
            rt=u;
        }
        forup(j,1,k){
            int v=read();
            e[u].push_back(v);
        }
    }
    dfs(rt,0);
    work(rt,0);
}
```

///

## 模拟赛神秘题目【1031 B组】D 后缀数组

> 题意

- 我们称一个由数字构成的序列是字符串当且仅当不存在某个小于序列最大值的正整数没在序列中出现过。
- 给定长度为 $n$ 的后缀数组 $sa_i$，即 $\forall 1\le i < j\le n,s[i:n] < s[j:n]$，其中这个小于表示字典序比较，我们认为空字符小于一切字符。
- 求符合后缀数组 $sa$ 的字符串 $s$ 的数量。
- 但我们不直接给出 $a$，我们初始化 $a_i=i$，然后有以下操作共 $m$ 次：
    - $0\;l\;r$：将 $sa$ 中区间 $[l,r]$ 平移到序列开头。
    - $1\;l\;r$：将 $sa$ 中区间 $[l,r]$ 左右翻转。
- $1\le n\le 10^9,1\le m\le 10^5$

> 题解

我去，$1\le n\le 10^9$，这怎么做。

为方便叙述设 $rk$ 是 $sa$ 的逆排列，即任意 $i$ 满足 $rk_{sa_i}=sa_{rk_i}=i$，考虑固定 $sa$ 后怎么做。

显然 $s_{sa_i}\le s_{sa_{i+1}}$，并且不难想到 $s_{sa_{i+1}}$ 要么等于 $s_{sa_i}$，要么等于 $s_{sa_i}+1$，否则就不满足值域连续的条件了。容易发现 $s_{sa_i}= s_{sa_{i+1}}$ 仅当 $rk_{sa_i+1} < rk_{sa_{i+1}+1}$，而由于 $rk$ 是固定的，所以每个 $s_{sa_i+1}$ 有一种还是两种填法也是固定的，那么答案大致是 $2^p$ 的形式，其中 $p$ 是满足 $rk_{sa_i+1} < rk_{sa_{i+1}+1}$ 的位置数。

容易想到，满足 $|sa_i-sa_{i+1}|=1$ 的连续段除去首尾外全都满足条件而两个操作都是容易用平衡树维护的，那么用平衡树维护连续段（每个结点维护一段，这时候又能体现 FHQ 的优越了，分裂结点的实现是自然的），每一段的首尾再额外考虑一下就行了。

代码较为难写，复杂度 $O(n\log n)$。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=3e5+5,inf=0x3f3f3f3f,mod=998244353;
int n,m,p2[N];
mt19937 mr(time(0));
vector<int> pos;
vector<pii> cor;
int ans;
map<int,int> rk;
struct Treap{
    struct Node{
        int l,r,ls,rs,hv;
    }tr[N];
    int cntn,mark[N],sum[N],root;
    vector<int> stk;
    int New(int l,int r){
        int nw;
        if(stk.size()){
            nw=stk.back();stk.pop_back();
        }else{
            nw=++cntn;
        }
        tr[nw]=Node{l,r,0,0,(int)mr()};
        mark[nw]=0;
        sum[nw]=abs(r-l)+1;
        return nw;
    }
    void Modi(int id){
        swap(tr[id].ls,tr[id].rs);
        swap(tr[id].l,tr[id].r);
        mark[id]^=1;
    }
    void PushDown(int id){
        if(!mark[id]) return;
        if(tr[id].ls) Modi(tr[id].ls);
        if(tr[id].rs) Modi(tr[id].rs);
        mark[id]=0;
    }
    void PushUp(int id){
        sum[id]=abs(tr[id].r-tr[id].l)+1;
        if(tr[id].ls) sum[id]+=sum[tr[id].ls];
        if(tr[id].rs) sum[id]+=sum[tr[id].rs];
    }
    int Merge(int u,int v){
        if(!u||!v) return u|v;
        PushDown(u);PushDown(v);
        if(tr[u].hv>tr[v].hv){
            tr[u].rs=Merge(tr[u].rs,v);
            PushUp(u);
            return u;
        }else{
            tr[v].ls=Merge(u,tr[v].ls);
            PushUp(v);
            return v;
        }
    }
    void Split(int id,int key,int &x,int &y){
        if(!id){
            x=y=0;
            return;
        }
        PushDown(id);
        int len=abs(tr[id].r-tr[id].l)+1;
        if(tr[id].ls&&sum[tr[id].ls]>=key){
            y=id;
            Split(tr[id].ls,key,x,tr[y].ls);
            PushUp(y);
        }else if(sum[tr[id].ls]+len<=key){
            x=id;
            int p=sum[tr[id].ls]+len;
            Split(tr[id].rs,key-p,tr[x].rs,y);
            PushUp(x);
        }else{
            if(tr[id].ls) key-=sum[tr[id].ls];
            int l=tr[id].l,r=tr[id].r,ls=tr[id].ls,rs=tr[id].rs;
            stk.push_back(id);
            if(l<r){
                int mid=l+key-1;
                if(l<=mid){
                    x=Merge(ls,New(l,mid));
                }else{
                    x=ls;
                }
                if(mid<r){
                    y=Merge(New(mid+1,r),rs);
                }else{
                    y=rs;
                }
            }else{
                int mid=l-key+1;
                if(l>=mid){
                    x=Merge(ls,New(l,mid));
                }else{
                    x=ls;
                }
                if(mid>r){
                    y=Merge(New(mid-1,r),rs);
                }else{
                    y=rs;
                }
            }
            return;
        }
    }
    void Insert(int l,int r){
        root=Merge(root,New(l,r));
    }
    void Reverse(int l,int r){
        int x,y,z;
        Split(root,l-1,x,y);Split(y,r-l+1,y,z);
        Modi(y);
        root=Merge(Merge(x,y),z);
    }
    void Move(int l,int r){
        int x,y,z;
        Split(root,l-1,x,y);Split(y,r-l+1,y,z);
        root=Merge(Merge(y,x),z);
    }
    void get(int id,int len){
        PushDown(id);
        if(tr[id].ls){
            get(tr[id].ls,len);
            len+=sum[tr[id].ls];
        }
        int l=tr[id].l,r=tr[id].r,plen=abs(r-l)+1;
        if(plen>2){
            ans=1ll*ans*p2[plen-2]%mod;
        }
        if(l!=r){
            if(l<r){
                cor.push_back(mkp(r-1,r));
            }else{
                cor.push_back(mkp(l,l-1));
            }
        }
        rk[l]=len+1;
        rk[r]=len+plen;
        if(l+1<r){
            rk[l+1]=len+2;
        }else if(r+1<l){
            rk[r+1]=len+plen-1;
        }
        pos.push_back(l);
        pos.push_back(r);
        if(tr[id].rs) get(tr[id].rs,len+plen);
    }
}mt;
signed main(){
    n=read();m=read();
    ans=1;
    p2[0]=1;
    forup(i,1,m*3){
        p2[i]=2ll*p2[i-1]%mod;
    }
    mt.Insert(1,n);
    forup(i,1,m){
        int op=read(),l=read(),r=read();
        if(op==0){
            mt.Move(l,r);
        }else{
            mt.Reverse(l,r);
        }
    }
    rk[n+1]=0;
    mt.get(mt.root,0);
    for(int i=2;i<(int)pos.size();i+=2){
        if(rk[pos[i-1]+1]<rk[pos[i]+1]){
            ans=2ll*ans%mod;
        }
    }
    for(auto i:cor){
        if(rk[i.fi+1]<rk[i.se+1]){
            ans=2ll*ans%mod;
        }
    }
    printf("%d\n",ans);
}
```

///

## P10764 [BalticOI 2024] Wall

[传送门](https://www.luogu.com.cn/problem/P10764)

> 题意

- 有一堵长度为 $n$ 的墙，点 $i$ 位置墙的高度 $h_i$ 可能是 $a_i$ 或者 $b_i$（二选一）。
- 下了一场水量充分多的雨，每个地方可能会积水，点 $i$ 的积水高度为 $H_i$。形式化地，$H_i$ 为最大的整数满足存在两整数 $l,r(1\le l\le i\le r\le n)$，使得 $h_l\ge H_i$ 并且 $h_r\ge H_i$，我们认为积水量为 $\sum_{i=1}^nH_i-h_i$。
- 求总共 $2^n$ 种修墙策略的积水量之和。
- $1\le n\le 5\times 10^5,1\le a_i,b_i\le 10^9,a_i\ne b_i$，答案对 $998244353$ 取模。

> 题解

一个显然的想法是把贡献拆成 $\sum H_i-\sum h_i$，容易发现 $\sum\sum h_i=\sum_{i=1}^n(a_i+b_i)2^{n-1}$，于是只考虑前者。

我想过一个矩阵维护 DP 的做法，设 $f_{i,j,0/1}$ 表示从左到右考虑前 $i$ 个，前缀最大值为 $j$ 的方案数/积水量之和 $g$ 表示从右到左，转移可以线段树维护矩阵做，然后枚举全局最大值，这样左侧就只和前缀有关，右侧只和后缀有关，于是后将前后缀合在一起，复杂度 $O(n\log n 2^3)$，但是太难写了没写完，而且很多实现细节没搞清楚。

考虑 $H_i$ 有多少种情况恰好等于 $p$，设这个数是 $cnt_{p,i}$，那么答案就是 $\sum_{p}p\sum_{i=1}^ncnt_{p,i}=\sum_{p}\sum_{i=1}^n\sum_{q\ge p}cnt_{q,i}$，即 $H_i$ 大于等于 $p$ 的情况数之和，设 $\sum_{q\ge p}cnt_{q,i}=ans_{p,i}$。

关于求 $ans_p$，不难想到一个简单容斥，设 $s_i=[a_i < p]+[b_i < p]$。那么 $ans_{p,i}=2^n-2^{i-1}\prod_{j=i}^ns_j-2^{n-i}\prod_{j=1}^is_j+\prod_{j=1}^ns_j$，即总的减去某一边不合法的加上两边都不合法的。

考虑枚举 $p$，容易发现随着 $p$ 的改变，$2^n+\prod_{j=1}^ns_j$ 是容易维护的，注意到每个 $s_i$ 的修改对 $2^{i-1}\prod_{j=i}^ns_j$ 和 $2^{n-i}\prod_{j=1}^is_j$ 的影响是一段前缀/后缀，那么可以线段树维护。

然后我们发现从小到大枚举是不可维护的，于是考虑从大到小枚举。

于是做完了，复杂度 $O(n\log n)$。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=5e5+5,inf=0x3f3f3f3f,mod=1e9+7,inv2=5e8+4;
int n,a[N],b[N],s[N],p2[N];
vector<int> lsh;
vector<int> pos[N*2];
int sz,sum1,sum2;
struct SegTree{
    #define mid ((l+r)>>1)
    #define lson l,mid,id<<1
    #define rson mid+1,r,id<<1|1
    int sum[N<<2],mark[N<<2];
    void PushUp(int id){
        sum[id]=(sum[id<<1]+sum[id<<1|1])%mod;
    }
    void Modi(int id,int X){
        mark[id]=1ll*mark[id]*X%mod;
        sum[id]=1ll*sum[id]*X%mod;
    }
    void PushDown(int id){
        Modi(id<<1,mark[id]);
        Modi(id<<1|1,mark[id]);
        mark[id]=1;
    }
    void Build(int l=1,int r=n,int id=1){
        mark[id]=1;
        if(l==r){
            sum[id]=p2[n];
            return;
        }
        Build(lson);Build(rson);
        PushUp(id);
    }
    void Update(int L,int R,int X,int l=1,int r=n,int id=1){
        if(L<=l&&r<=R){
            Modi(id,X);
            return;
        }
        if(mark[id]!=1) PushDown(id);
        if(L<=mid) Update(L,R,X,lson);
        if(mid< R) Update(L,R,X,rson);
        PushUp(id);
    }
}t1,t2;
int ans=0;
signed main(){
    n=read();
    p2[0]=1;
    forup(i,1,n) p2[i]=2ll*p2[i-1]%mod;
    forup(i,1,n){
        a[i]=read();
        lsh.push_back(a[i]);
    }
    forup(i,1,n){
        b[i]=read();
        lsh.push_back(b[i]);
        if(a[i]>b[i]) swap(a[i],b[i]);
    }
    sort(lsh.begin(),lsh.end());
    lsh.erase(unique(lsh.begin(),lsh.end()),lsh.end());
    sz=lsh.size();
    forup(i,1,n){
        int pa=lower_bound(lsh.begin(),lsh.end(),a[i])-lsh.begin(),pb=lower_bound(lsh.begin(),lsh.end(),b[i])-lsh.begin();
        pos[pa].push_back(i);pos[pb].push_back(i);
        s[i]=2;
    }
    sum1=sum2=p2[n];
    t1.Build();t2.Build();
    fordown(i,sz-1,0){
        for(auto j:pos[i]){
            --s[j];
            if(s[j]==1){
                sum2=1ll*sum2*inv2%mod;
                t1.Update(1,j,inv2);t2.Update(j,n,inv2);
            }else{
                sum2=0;
                t1.Update(1,j,0);t2.Update(j,n,0);
            }
        }
        int del=(t1.sum[1]+t2.sum[1])%mod,pval=1ll*(sum1+sum2)*n%mod;
        int val=(pval+mod-del)%mod,cnt=(i?lsh[i]-lsh[i-1]:lsh[i]);
        (ans+=1ll*val*cnt%mod)%=mod;
    }
    forup(i,1,n){
        ans=(ans+mod-1ll*(a[i]+b[i])*p2[n-1]%mod)%mod;
    }
    printf("%d\n",ans);
}
```

///

## [ABC155F] Perils in Parallel

[传送门](https://www.luogu.com.cn/problem/AT_abc155_f)

> 题意

- 有一条路，上面有 $n$ 盏路灯。第 $i$ 盏路灯在 $a_i$ 位置，现在状态是 $b_i$（$b=1/0$ 表示明灭）。
- 有 $m$ 个开关，每个开关可以将一个区间 $[l_i,r_i]$ 内所有路灯的状态反转。
- 问是否能把所有路灯灭掉，若能，输出方案（将要操作的开关的编号从小到大输出），否则输出 `-1`。
- $1\le n\le 10^5,1\le m\le 2\times 10^5,1\le a_i,l_i,r_i\le 10^9,l_i\le r_i$

> 题解

首先显然可以不管 $a_i$，将灯看作连续的序列，然后每个开关控制一个区间的灯。

显然区间修是不好做的，不妨差分一下（异或差分，设差分数组为 $c_i$）变成两个单点修，容易想到将每个修改 $[l,r)$（这里的 $l,r$ 指的是从左到右的路灯编号而非坐标）视作一条无向边 $(l,r)$，显然每个连通块是独立的。

注意到会有 $r > n$ 的情况，此时就相当于点 $l$ 可以单点修改，称这样的点为特殊点。

容易发现有解当且仅当每个连通块都有偶数个 $c_i=1$（必要性显然，充分性考虑构造，一个构造是两两配对随便找条连接两点的路径将其上的边全部操作一次，具体构造考虑找棵生成树用树上路径），若有奇数个就尝试使用特殊点调整。

然后做完了，复杂度 $O(n)$，但我写的比较丑，用了并查集。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=1e5+5,M=2e5+5,inf=0x3f3f3f3f;
int n,m,co[N];
pii s[N];
vector<int> seq;
vector<int> ans;
vector<pii> e[N];
int a[N];
int fa[N];
int getfa(int x){return x==fa[x]?x:fa[x]=getfa(fa[x]);}
bool merge(int u,int v){
    u=getfa(u);v=getfa(v);
    if(u==v) return false;
    fa[u]=v;
    return true;
}
int cnt,pp,pf[N],dp[N];
void dfs1(int x,int fa){
    cnt+=a[x];
    if(!pp&&co[x]) pp=x;
    for(auto i:e[x]){
        int v=i.fi;
        if(v==fa) continue;
        pf[v]=i.se;
        dfs1(v,x);
    }
}
void dfs2(int x,int fa){
    dp[x]=a[x];
    for(auto i:e[x]){
        int v=i.fi;
        if(v==fa) continue;
        dfs2(v,x);
        dp[x]^=dp[v];
    }
    if(dp[x]) ans.push_back(pf[x]);
}
void work(int rt){
    pp=cnt=0;
    dfs1(rt,0);
    if(cnt&1){
        if(pp){
            a[pp]^=1;
            ans.push_back(co[pp]);
        }else{
            puts("-1");
            exit(0);
        }
    }
    dfs2(rt,0);
}
signed main(){
    n=read();m=read();
    forup(i,1,n){
        s[i].fi=read();s[i].se=read();
        seq.push_back(s[i].fi);
        fa[i]=i;
    }
    sort(seq.begin(),seq.end());
    sort(s+1,s+n+1);
    forup(i,1,n){
        a[i]=s[i].se;
    }
    fordown(i,n,1){
        a[i]^=a[i-1];
    }
    forup(i,1,n){
        msg("%d ",a[i]);
    }msg("|\n");
    forup(i,1,m){
        int l=read(),r=read();
        l=lower_bound(seq.begin(),seq.end(),l)-seq.begin()+1;
        r=upper_bound(seq.begin(),seq.end(),r)-seq.begin()+1;
        msg("%d %d|\n",l,r);
        if(l>n||l==r) continue;
        if(r>n){
            co[l]=i;
        }else{
            if(merge(l,r)){
                e[l].push_back(mkp(r,i));
                e[r].push_back(mkp(l,i));
            }
        }
    }
    forup(i,1,n){
        if(fa[i]==i){
            work(i);
        }
    }
    printf("%d\n",(int)ans.size());
    sort(ans.begin(),ans.end());
    for(auto i:ans){
        printf("%d ",i);
    }puts("");
}
```

///

## [ABC163F] path pass i

[传送门](https://www.luogu.com.cn/problem/AT_abc163_f)

> 题意

- 有一棵 $n$ 个点的树，每个点有颜色 $c_i$。
- 对于每个颜色 $1\le i\le n$，求出包含至少一个颜色为 $i$ 的点的简单路径数。
- $1\le n\le 2\times 10^5,1\le c_i\le n$

> 题解

简单题。

容易想到容斥，一条简单路径没有包含颜色 $i$ 当且仅当删掉所有颜色 $i$ 的点形成若干连通块，这条简单路径两端点在同一连通块内。称这样的连通块为“$i$ 的关键连通块”

于是对每个点的所有连通块计算大小即可。首先，全树的根节点是所有颜色关键连通块的根，此外每个点是其父亲颜色连通块的根，每个关键连通块的大小是容易计算的，而显然关键连通块总数是 $O(n)$ 的。

于是复杂度 $O(n)$。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(i64 i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(i64 i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<i64,i64>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
i64 read(){
    i64 x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const i64 N=2e5+5;
i64 n,c[N];
vector<i64> e[N];
vector<i64> pos[N];
i64 sz[N];
void dfs1(i64 x,i64 fa){
    sz[x]=1;
    if(fa){
        pos[c[fa]].push_back(x);
    }
    for(auto i:e[x]){
        if(i==fa) continue;
        dfs1(i,x);
        sz[x]+=sz[i];
    }
}
i64 ans,cc,cnt[N],crt[N];
int pre[N];
void dfs2(i64 x,i64 fa){
    if(pre[c[x]]!=1){
        cnt[pre[c[x]]]-=sz[x];
    }else{
        crt[c[x]]-=sz[x];
    }
    int sv=pre[c[x]];
    for(auto i:e[x]){
        if(i==fa) continue;
        pre[c[x]]=i;
        dfs2(i,x);
    }
    pre[c[x]]=sv;
}
signed main(){
    n=read();
    forup(i,1,n){
        c[i]=read();
    }
    forup(i,1,n-1){
        i64 u=read(),v=read();
        e[u].push_back(v);
        e[v].push_back(u);
    }
    dfs1(1,0);
    forup(i,1,n){
        cnt[i]=sz[i];
        pre[i]=1;
        crt[i]=n;
    }
    dfs2(1,0);
    forup(i,1,n){
        ans=n*(n+1)/2;
        cnt[1]=n;
        cc=i;
        for(auto j:pos[i]){
            ans-=cnt[j]*(cnt[j]+1)/2;
        }
        ans-=crt[i]*(crt[i]+1)/2;
        printf("%lld\n",ans);
    }
}
```

///

## P9039 [PA2021] Drzewo czerwono-czarne

[传送门](https://www.luogu.com.cn/problem/P9039)

> 题意

- 给定一棵 $n$ 个点的树，每个点是黑色或者白色。
- 你可以进行以下操作若干次：
    - 选择一条边，将其一端点改成另一端点的颜色。
- 给定两个序列 $a_i,b_i$，表示每个点的起始颜色和终止颜色，求能否通过操作使得每个点从起始颜色变为终止颜色。
- $1\le n\le 10^5$，带多测，$\sum n\le 10^6$

> 题解

我是猜结论高手。

首先如果图是一条链是好做的，（假设链是 $1,2,3,\dots,n$）有解当且仅当将相邻的相同颜色合为一个点后得到序列 $a',b'$，$b'$ 序列是 $a'$ 序列的子序列。因为元素只有 $0/1$ 就是说 $b'$ 的序列长度小于 $a'$ 或者两序列完全相同。

如果不是链呢？我们大胆猜测，不是链的必定有解，因为我们可以看作有一个分叉的链，如果需要将链上某个连续段断开那么挪到分叉点即可。

显然是不对的，注意到一个反例：

```
7
0000001
1010101
1 2
2 3
3 4
4 5
3 6
3 7
```

那么我们再限制一下 $b$ 至少有一个连通块大小大于 $1$ 即可。

然后就随便做了复杂度 $O(n)$。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123=(e);i<=E123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123=(e);i>=E123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
	int x=0,f=1;char c;
	while(!isdigit(c=gc)){if(c=='-')f=-1;}
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const int N=1e5+5,inf=0x3f3f3f3f;
int n,a[N],b[N],pa[2],pb[2];
char str[N];
struct edge{
	int v,nxt;
}e[N<<1];
int head[N],cnte,deg[N];
void adde(int u,int v){
	e[++cnte]=edge{v,head[u]};head[u]=cnte;
	e[++cnte]=edge{u,head[v]};head[v]=cnte;
	++deg[u];++deg[v];
}
bool chk0(){
	forup(u,1,n){
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].v;
			if(b[v]==b[u]) return true;
		}
	}
	return false;
}
bool chk(){
	forup(u,1,n){
		if(deg[u]>2) return true;
	}
	return false;
}
int prea,cnta,preb,cntb;
int cnt;
void dfs(int x,int fa){
	if(!cnta||prea!=a[x]){prea=a[x];++cnta;}
	if(!cntb||preb!=b[x]){preb=b[x];++cntb;}
	if(fa==0) cnt=0;
	++cnt;
	for(int i=head[x];i;i=e[i].nxt){
		int v=e[i].v;
		if(v==fa) continue;
		dfs(v,x);
	}
}
void solve(){
	n=read();
	cnte=0;
	pa[0]=pb[0]=pa[1]=pb[1]=0;
	forup(i,1,n){
		head[i]=deg[i]=0;
	}
	scanf(" %s",str+1);
	forup(i,1,n){
		a[i]=(str[i]=='1');
		pa[a[i]]=1;
	}
	scanf(" %s",str+1);
	bool flag=true;
	forup(i,1,n){
		b[i]=(str[i]=='1');
		pb[b[i]]=1;
		if(a[i]!=b[i]) flag=false;
	}
	forup(i,1,n-1){
		int u=read(),v=read();
		adde(u,v);
	}
	if(flag){
		puts("TAK");
		return;
	}
	if(!chk0()){
		puts("NIE");
		return;
	}
	if((pb[0]&&!pa[0])||(pb[1]&&!pa[1])){
		puts("NIE");
		return;
	}
	if(chk()){
		puts("TAK");
		return;
	}
	prea=preb=0;
	cnta=cntb=0;
	forup(i,1,n){
		if(deg[i]==1){
			dfs(i,0);
			break;
		}
	}
	if(cnta>cntb||(cnta==cntb&&prea==preb)){
		puts("TAK");
	}else{
		puts("NIE");
	}
}
signed main(){
	int t=read();
	while(t--){
		solve();
	}
}
```

///

##  黑暗爆炸-4770 图样

[传送门](https://vjudge.net/problem/%E9%BB%91%E6%9A%97%E7%88%86%E7%82%B8-4770)

> 题意

- 有一张 $n$ 个点的完全图，点有点权 $a_i$，边 $(u,v)$ 的边权为 $a_u\oplus a_v$。其中 $\oplus$ 表示按位异或。
- 现在每个点的点权在 $[0,2^m)$ 中随机取值，求最小生成树的期望边权和。
- $1\le n\le 50,0\le m\le 8$，答案对 $258280327$ 取模（这是质数）

> 题解

神秘。

考虑固定点权怎么做，从小到大枚举位数 $i$，显然任意时刻**更高位全部相同**的点应该连成了连通块，每一层都只会将所有更高位全部相同，但这一层不同的连通块二元组两两合并。

容易想到设 $dp_{i,x}$ 表示考虑到前 $i$ 层，所有合并出一个大小为 $x$ 的连通块的方案的代价之和。转移就枚举这一位全为 $1$ 的连通块大小，然后合并。

考虑这一次合并的代价，容易发现除去必定在 $[2^{i-1},2^i)$ 之间我们啥都不知道，但是因为 DP 概括了**所有方案**，那么我们只要求出所有方案的代价和即可，转移形如：

$$
dp_{i,j}=2dp_{i-1,j}+\sum_{p=1}^{(j-1)(i-1)}\binom{j}{p}(dp_{i-1,p}2^{j-p}+dp_{i-1,j-p}2^{p(i-1)}+g(i-1,p,j-p)+2^{i-1}\times 2^{j(i-1)})
$$

其中 $g(i,l,r)$ 表示所有将两大小分别为 $l,r$，并且大于 $i$ 的二进制位全都相同（就是不考虑大于 $i$ 的位）的连通块合并的情况的贡献和。

考虑怎么算 $g$，显然不好算，考虑设 $f(i,l,r,v)$ 表示只考虑前 $i$ 位，将两连通块合并的代价为 $v$ 的方案数。$f$ 是能 DP 求出的，具体来说，枚举左右连通块这一位 $1$ 的个数，显然除去一边全 $0$ 另一边全 $1$ 以外，必定是两 $0$ 合并或者两 $1$ 合并，实现细节自己考虑。

直接算复杂度是 $O(n^4m2^m)$ 的，但是注意到本质不同询问只有 $400$ 种，打表即可。

/// details | 参考打表代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=55,M=2e4+5,mod=258280327,inv2=(mod+1)/2;
int n=50,m=8,f[9][N][N][1<<8|5],suf[9][N][N][1<<8|5],g[9][N][N],dp[9][N];
int p2[M],ip2[M],binom[N][N];
signed main(){
    p2[0]=ip2[0]=1;
    forup(i,1,2e4){
        p2[i]=2ll*p2[i-1]%mod;
        ip2[i]=1ll*ip2[i-1]*inv2%mod;
    }
    forup(i,0,n){
        binom[i][0]=1;
        forup(j,1,i){
            binom[i][j]=(binom[i-1][j]+binom[i-1][j-1])%mod;
        }
    }
    forup(i,1,n){
        forup(j,1,n-i){
            f[0][i][j][0]=suf[0][i][j][0]=1;
            g[0][i][j]=0;
        }
    }
    forup(i,1,m){
        forup(l,1,n){
            forup(r,1,n-l){
                forup(v,0,(1<<(i-1))-1){
                    forup(p,1,l-1){
                        forup(q,1,r-1){
                            int val=1ll*binom[l][p]*binom[r][q]%mod;
                            (f[i][l][r][v]+=1ll*f[i-1][p][q][v]*suf[i-1][l-p][r-q][v]%mod*val%mod)%=mod;
                            (f[i][l][r][v]+=1ll*f[i-1][l-p][r-q][v]*suf[i-1][p][q][v+1]%mod*val%mod)%=mod;
                        }
                    }
                    forup(q,1,r){
                        (f[i][l][r][v]+=2ll*f[i-1][l][q][v]*binom[r][q]%mod*p2[(i-1)*(r-q)]%mod)%=mod;
                    }
                    forup(p,1,l-1){
                        (f[i][l][r][v]+=2ll*f[i-1][p][r][v]*binom[l][p]%mod*p2[(i-1)*(l-p)]%mod)%=mod;
                    }
                    (f[i][l][r][v+(1<<(i-1))]+=2ll*f[i-1][l][r][v]%mod)%=mod;
                }
                fordown(v,(1<<i)-1,0){
                    suf[i][l][r][v]=(suf[i][l][r][v+1]+f[i][l][r][v])%mod;
                    (g[i][l][r]+=1ll*f[i][l][r][v]*v%mod)%=mod;
                }
            }
        }
        msg("%d|\n",i);
    }
    forup(v,0,3){
        msg("%d ",f[2][1][2][v]);
    }msg("|\n");
    forup(i,1,n){
        dp[0][i]=0;
    }
    forup(i,1,m){
        forup(j,1,n){
            dp[i][j]=(dp[i-1][j]+dp[i-1][j])%mod;
            forup(p,1,j-1){
                int val=(1ll*p2[(j-p)*(i-1)]*dp[i-1][p]%mod+1ll*p2[p*(i-1)]*dp[i-1][j-p]%mod)%mod;
                (val+=g[i-1][p][j-p]+1ll*p2[j*(i-1)]*p2[i-1]%mod)%=mod;
                (dp[i][j]+=1ll*binom[j][p]*val%mod)%=mod;
            }
        }
    }
    msg("%lld %lld||\n",1ll*dp[2][2]*ip2[4]%mod,1ll*dp[3][10]*ip2[30]%mod);
    forup(i,0,m){
        msg("{");
        forup(j,0,n){
            msg("%lld",1ll*dp[i][j]*ip2[i*j]%mod);
            // msg("%d",dp[i][j]);
            if(j<n)msg(",");
        }
        msg("},\n");
    }
}
```

///

## QOJ-1870 Command and Conquer: Red Alert 2 

[传送门](https://vjudge.net/problem/QOJ-1870)

> 题意

- 有一个三维坐标系，一个人从三个维度坐标都充分小的点出发，要到达三个维度坐标都充分大的点，每一步只能让三个坐标其中一个 $+1$。
- 坐标系中有 $n$ 个敌人，第 $i$ 个敌人的坐标是 $(x_i,y_i,z_i)$，这个人有一杆猎枪，子弹充分多，射程为 $k$，从坐标 $(x_0,y_0,z_0)$ 能击杀坐标 $(x_1,y_1,z_1)$ 的敌人当且仅当 $\max(|x_0-x_1|,|y_0-y_1|,|z_0-z_1|)\le k$。
- 求要击杀所有敌人的最小射程 $k$。
- $1\le n\le 5\times 10^5,0\le x_i,y_i,z_i\le 10^9$ 带多测，$\sum n\le 2\times 10^6$

> 题解

神秘，全 CW 竟无一人场切。

考虑攻击范围是个正方体，我们不妨认为这个人攻击距离是 $2k$，但是只能往正方向打。设这样得到的答案是 $K$，那么实际答案就是 $\left\lceil\frac{K}{2}\right\rceil$。

容易发现啊，如果我们走到了某个点 $(x_1,y_1,z_1)$，那么任意满足 $x' < x\lor y' < y\lor z' < z$ 的点 $(x',y',z')$，都必须被干掉，不然就永远干不掉了。设 $x$ 最小的点为 $A(x_a,y_a,z_a)$，$y$ 最小的为 $B(x_b,y_b,z_b)$，$z$ 最小的为 $C(x_c,y_c,z_c)$，那么我们必须在走到 $(x_a,y_b,z_c)$ 之前干掉 $A,B,C$ 其中一个。不难想到恰好从 $(x_a,y_b,z_c)$ 开枪是不劣的（在必须干掉三者前能得到的最大坐标），这时候我们贪心地把距离最小的击杀，更新 $K$，然后将这个点删掉。

这个贪心显然是正确的，复杂度 $O(n\log n)$，瓶颈在排序。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=5e5+5,inf=0x3f3f3f3f;
int n;
int a[N],b[N],c[N],vis[N];
int sa[N],sb[N],sc[N];
int pa,pb,pc;
void solve(){
    n=read();
    forup(i,1,n){
        a[i]=read();b[i]=read();c[i]=read();
        sa[i]=sb[i]=sc[i]=i;
        vis[i]=0;
    }
    sort(sa+1,sa+n+1,[&](int l,int r){return a[l]<a[r];});
    sort(sb+1,sb+n+1,[&](int l,int r){return b[l]<b[r];});
    sort(sc+1,sc+n+1,[&](int l,int r){return c[l]<c[r];});
    int ans=0;
    pa=pb=pc=1;
    forup(i,1,n){
        while(vis[sa[pa]]) ++pa;
        while(vis[sb[pb]]) ++pb;
        while(vis[sc[pc]]) ++pc;
        int na=sa[pa],nb=sb[pb],nc=sc[pc];
        int va=max(abs(b[nb]-b[na]),abs(c[nc]-c[na]));
        int vb=max(abs(a[na]-a[nb]),abs(c[nc]-c[nb]));
        int vc=max(abs(a[na]-a[nc]),abs(b[nb]-b[nc]));
        if(va<=vb&&va<=vc){
            ans=max(ans,va);
            vis[na]=1;
        }else if(vb<=vc){
            ans=max(ans,vb);
            vis[nb]=1;
        }else{
            ans=max(ans,vc);
            vis[nc]=1;
        }
    }
    printf("%d\n",(ans+1)/2);
}
signed main(){
    int t=read();
    while(t--){
        solve();
    }
}
```

///

## QOJ-2549 King's Palace 

[传送门](https://vjudge.net/problem/QOJ-2549)

> 题意

- 有 $n$ 个点，每个点可能是红色，绿色，蓝色。
- 有 $m$ 个限制，每个限制形如 $(u,x,v,y)$，表示**点 $u$ 的颜色不是 $x$ 或者点 $v$ 的颜色不是 $y$（就是说 $u$ 的颜色是 $x$ 和 $v$ 的颜色是 $y$ 不能同时成立）**。
- 求合法染色数。
- $1\le n\le 22,0\le m\le 9\binom{n}{2}$。

> 题解

也很厉害吧，赛时一车人爆搜过了。

首先爆搜剪枝可过（而且是已知做法里面最快的）。

然后有个折半搜索，按 $1:2$ 分成两半，设小的那半大小为 $p$，用一个 $2^{3p}$ 二进制数表示这一半每个点可以是哪种颜色，复杂度大致是 $O(p2^{3p}+3^{n-p}+3^{p})$，跑的比下面的这个做法快，但是需要玄学剪枝，我不是很喜欢。

用 $0,1,2$ 表示三种颜色。

考虑先确定哪些点是 $2$，可以 $2^n$ 枚举，那么我们就能确定一部分点是 $0$ 还是 $1$ 了，剩下没确定的点就和这些无关了，设 $f(S)$ 表示只考虑 $S$ 中的点，只能填 $0,1$ 的方案数。

$f(S)$ 求法也类似，先枚举一个点，将有关的找出来，剩下 $S'$，从 $S'$ 转移。

复杂度 $O(2^n(n+m))$，跑的比较慢，但是时限 6s。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=25;
int n,m;
struct edge{
    int v,w,nxt;
}e[N*N*20];
int head[N][3],cnte;
void adde(int u,int p,int v,int w){
    e[++cnte]=edge{v,w,head[u][p]};head[u][p]=cnte;
}
i64 f[1<<22];
int val[N];
int chk(int msk,int p){
    int u=__builtin_ctz(msk)+1;
    val[u]=p;
    queue<int> q;q.push(u);
    int res=msk;
    res^=(1<<(u-1));
    while(q.size()){
        int u=q.front();q.pop();
        for(int i=head[u][val[u]];i;i=e[i].nxt){
            int v=e[i].v,w=e[i].w;
            if(!(msk&(1<<(v-1)))||w==2) continue;
            if(res&(1<<(v-1))){
                val[v]=w^1;
                q.push(v);
                res^=(1<<(v-1));
            }else{
                if(val[v]==w){
                    return -1;
                }
            }
        }
    }
    return res;
}
i64 ans;
void work(int msk){
    mem(val,-1);
    queue<int> q;
    int nxt=(1<<n)-1;
    forup(i,1,n){
        if(msk&(1<<(i-1))){
            q.push(i);
            val[i]=2;
        }
    }
    while(q.size()){
        int u=q.front();q.pop();
        nxt^=(1<<(u-1));
        for(int i=head[u][val[u]];i;i=e[i].nxt){
            int v=e[i].v,w=e[i].w;
            if(val[v]==w) return;
            if(~val[v]||w==2) continue;
            w^=1;
            val[v]=w;
            q.push(v);
        }
    }
    ans+=f[nxt];
}
signed main(){
    n=read();m=read();
    forup(i,1,m){
        int u,x,v,y;char c;
        u=read();scanf(" %1c",&c);
        x=(c=='R'?0:c=='G'?1:2);
        v=read();scanf(" %1c",&c);
        y=(c=='R'?0:c=='G'?1:2);
        adde(u,x,v,y);
        adde(v,y,u,x);
    }
    f[0]=1;
    forup(i,1,(1<<n)-1){
        if(__builtin_popcount(i)==1){
            f[i]=2;
            continue;
        }
        int res=chk(i,0);
        if(res!=-1) f[i]+=f[res];
        res=chk(i,1);
        if(res!=-1) f[i]+=f[res];
    }
    forup(msk,0,(1<<n)-1){
        work(msk);
    }
    printf("%lld\n",ans);
}
```

///

## QOJ-7509 01tree

[传送门](https://vjudge.net/problem/QOJ-7509)

> 题意

- 有一棵 $n$ 个点的树，每个点是黑色或者白色。
- 你可以进行以下操作任意次：
    - 选择一条边 $(u,v)$ 满足 $u,v$ 颜色相同，将两点的颜色反转。
- 初始每个点 $i$ 的颜色分别 $a_i$，求至少多少次操作才能把颜色序列变成 $b_i$，无解则为 $0$。
- 但是 $a,b$ 中都有一些点没确定，即 $a,b$ 均是由 `0,1,?` 构成的字符串，其中 `?` 可以随意替换成 `0,1`，求所有替换方案的贡献和。
- $1\le n\le 10^5$，带多测，$\sum n\le 10^5$，答案对 $10^9+7$ 取模。

> 题解

神秘题。但是赛时因为数据问题一车人 $30\to 50$ 或者 $50\to 100$。

不妨设 $1$ 为根。

先考虑没有 `?` 的情况。有神秘构造（或许是套路？）设 $s_i=a_i\oplus (dpt_i\bmod 2)$（其中 $dpt_i$ 表示点 $i$ 的深度，$\oplus$ 表示按位异或），$t_i=b_i\oplus(dpt_i\bmod 2)$，那么一次操作就是选择一条 $s_u\ne s_v$ 的边 $(u,v)$，将两点颜色互换。

显然地，$s_i$ 和 $a_i$ 是一一对应的，那么我们只需要关注 $s,t$ 了。不妨认为 $s_i=1$ 的点上有一个黑色棋子，$t_i=1$ 的点上有一个白色棋子，那么我们的目的就是将黑白棋子一一配对，设 $z_i$ 表示点 $i$ 子树中黑色棋子个数减去白色棋子个数，容易发现有解当且仅当 $z_1=0$，并且最小代价为 $\sum |z_i|$（考虑有多少个棋子会经过这个点，可以认为黑白棋子都只会向上移动，在 $\mathrm{lca}$ 处相遇）。

接下来处理 `?`，首先容易发现 $a$ 中的 `?` 在 $s$ 中也是 $0,1$ 任选的，$t$ 里面的也是一样，于是考虑推一下组合数。

设 $A$ 表示 $s$ 中的 `?` 数量，$B$ 表示 $t$ 中的 `?` 数量，已知部分的权值和为 $C$（$s_i=1$ 提供 $+1$ 权值，$t_i=1$ 提供 $-1$ 权值）。点 $i$ 子树中 $s$ 的 `?` 数量为 $x$，$t$ 的 `?` 数量为 $y$，点 $i$ 子树已知部分的权值和为 $z$，则点 $i$ 的贡献为：

$$
\sum_{i=0}^x\sum_{j=0}^y\sum_{k=0}^{A-x}\sum_{l=0}^{B-y}[C+i-j+k-l=0]|z+i-j|\binom{x}{i}\binom{y}{j}\binom{A-x}{k}\binom{B-y}{l}
$$

即枚举子树内 $s,t$ 分别有多少个 `?` 变成了 $1$，后面那坨组合数就是对应个数的方案数。我去，这么一大坨怎么做。

注意到我们只关注 $i-j$ 和 $k-l$，设 $p=i-j,q=k-l$，注意到 $\sum_{i=p}^x\binom{x}{i}\binom{y}{i-p}=\sum_{i=p}^x\binom{x}{x-i}\binom{y}{i-p}=\binom{x+y}{x-p}$（考虑组合意义），同理有 $\sum_{k=q}^{A-x}\binom{A-x}{k}\binom{B-y}{k-q}=\binom{A+B-x-y}{A-x-q}$。于是上式等于：

$$
\begin{aligned}
&\sum_{p}\sum_{q}[C+p+q=0]|z+p|\binom{x+y}{x-p}\binom{A+B-x-y}{A-x-q}\\\\
=&\sum_{p}|z+p|\binom{x+y}{x-p}\binom{A+B-x-y}{A-x+C+p}
\end{aligned}
$$

然后就能 $O(n^2)$ 计算了，注意枚举的上下界，不要搞出没有意义的组合数。

然后我们只看式子了，为了让式子好看一点，不妨令 $p:=x-p$，则上式等于 $\sum_{p}|z+x-p|\binom{x+y}{p}\binom{A+B-x-y}{A+C-p}$，设 $f(x,y)=\sum_{i}|y-i|\binom{x}{i}\binom{X-x}{Y-i}$，其中 $X=A+B,Y=A+C$，那么上式就是 $f(x+y,x+z)$，于是我们只关注 $f(x,y)$ 如何计算了。

接下来的思路非常神奇，注意到重链剖分后，对于一条重链，链尾到链顶的过程中 $x,y$ 的变化量和链顶的子树大小是一个级别的（分别乘个至多两倍的常数），那么假如我们能从 $f(x,y)$ 低复杂度（比如 $O(1)$）推到 $f(x,y+1),f(x,y-1)$ 和 $f(x+1,y)$ 就能 $O(n\log n)$ 计算了。

那么怎么做呢？先把绝对值拆了，于是 $f(x,y)=\left(\sum_i\binom{x}{i}\binom{X-x}{Y-i}(i-y)\right)+2\left(\sum_{i\le y}\binom{x}{i}\binom{X-x}{Y-i}(y-i)\right)$，注意到：

$$
\begin{aligned}
\sum_i\binom{x}{i}\binom{X-x}{Y-i}(i-y)&=\sum_i\binom{x}{i}\binom{X-x}{Y-i}i-y\sum_i\binom{x}{i}\binom{X-x}{Y-i}\\\\
&=-y\binom{X}{Y}+\sum_{i}\frac{x!}{i!(x-i)!}\binom{X-x}{Y-i}i\\\\
&=-y\binom{X}{Y}+\sum_{i}x\frac{(x-1)!}{(i-1)!((x-1)-(i-1))!}\binom{X-x}{Y-i}\\\\
&=-y\binom{X}{Y}+x\sum_{i}\binom{x-1}{i-1}\binom{X-x}{Y-i}\\\\
&=-y\binom{X}{Y}+x\sum_{i}\binom{x-1}{i}\binom{X-x}{Y-1-i}\\\\
&=-y\binom{X}{Y}+x\binom{X-1}{Y-1}\\\\
\end{aligned}
$$

倒数第二步就是 $i:=i-1$。

那么就能 $O(1)$ 计算了。考虑 $\sum_{i\le y}\binom{x}{i}\binom{X-x}{Y-i}(y-i)$，就是 $y\sum_{i\le y}\binom{x}{i}\binom{X-x}{Y-i}-\sum_{i\le y}\binom{x}{i}\binom{X-x}{Y-i}i$，于是只考虑 $\sum_{i\le y}\binom{x}{i}\binom{X-x}{Y-i}i$，把 $\binom{x}{i}$ 和上面类似地，可以发现这个等于 $x\sum_{i\le y}\binom{x-1}{i-1}\binom{X-x}{Y-i}=x\sum_{i\le y-1}\binom{x-1}{i}\binom{X-x}{Y-(i+1)}$。

于是我们只需要关注 $g(x,y)=\sum_{i\le y}\binom{x}{i}\binom{X-x}{Y-i}$（和 $g'(x,y)=\sum_{i\le y}\binom{x}{i}\binom{P-x}{Q-i}$，其中 $P=X-1,Q=Y-1$，上面的 $x\sum_{i\le y-1}\binom{x-1}{i}\binom{X-x}{Y-(i+1)}$ 就等于 $x\cdot g'(x-1,y-1)$）。

于是考虑怎么从 $g(x,y)$ 推到 $g(x+1,y)$ 和 $g(x,y\pm 1)$。

从 $g(x,y)$ 推到 $g(x,y+1)$ 是容易的，加上 $\binom{x}{y+1}\binom{X-x}{Y-(y+1)}$ 即可。考虑如何从 $g(x,y)$ 推到 $g(x+1,y)$。有组合意义：$g(x,y)$ 相当于从 $X$ 个球中选 $Y$ 个染色，前 $x$ 个球中至多 $y$ 个被染了。于是 $g(x,y)-g(x+1,y)$ 就是前 $x$ 个球被染了 $y$ 个，且第 $x+1$ 个球**必须**被染的方案数（因为某个方案不属于后者仅当前 $x+1$ 个球中有超过 $y$ 个，又属于前者就说明第 $x+1$ 个就是被染的），那么就是 $\binom{x}{y}\binom{X-x-1}{Y-y-1}$。这个在一堆边界情况需要特判。

$g'$ 也是类似的，然后我们能得到：

$$
f(x,y)=-y\binom{X}{Y}+x\binom{X-1}{Y-1}+2y\cdot g(x,y)-2x\cdot g'(x-1,y-1)
$$

于是就能做了，复杂度 $O(n\log n)$。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=5e5+5,mod=1e9+7;
int ksm(int a,int b){
    int c=1;
    while(b){
        if(b&1) c=1ll*a*c%mod;
        a=1ll*a*a%mod;
        b>>=1;
    }
    return c;
}
int n,s[N],t[N];
vector<int> e[N];
char str[N];
int A,B,C,dpt[N];
int z[N],x[N],y[N];
int fact[N<<1],finv[N<<1];
void init(int n){
    fact[0]=1;
    forup(i,1,n) fact[i]=1ll*fact[i-1]*i%mod;
    finv[n]=ksm(fact[n],mod-2);
    fordown(i,n-1,0) finv[i]=1ll*finv[i+1]*(i+1)%mod;
}
int binom(int n,int m){
    if(n<m||n<0||m<0) return 0;
    return 1ll*fact[n]*finv[m]%mod*finv[n-m]%mod;
}
int sz[N],son[N],hig[N],dfn[N],Tm,ff[N];
void dfs(int u,int fa){
    dpt[u]=dpt[fa]+1;
    ff[u]=fa;sz[u]=1;
    if(s[u]!=2){
        s[u]^=(dpt[u]&1);
        z[u]+=s[u];
    }else{
        ++x[u];
    }
    if(t[u]!=2){
        t[u]^=(dpt[u]&1);
        z[u]-=t[u];
    }else{
        ++y[u];
    }
    for(auto i:e[u]){
        if(i==fa) continue;
        dfs(i,u);
        sz[u]+=sz[i];
        if(!son[u]||sz[son[u]]<sz[i]) son[u]=i;
        z[u]+=z[i];
        x[u]+=x[i];
        y[u]+=y[i];
    }
}
int X,Y;
struct Caclg{
    int gv,gx,gy,P,Q;
    void initg(int x,int y){
        gv=0;
        gx=x;gy=y;
        forup(i,max(Q-(P-gx),0),min(gy,gx)){
            (gv+=1ll*binom(gx,i)*binom(P-gx,Q-i)%mod)%=mod;
        }
    }
    void workg(int x,int y){
        y=min(y,x);
        while(gx<x){
            if(gy<0){
                gv=0;
            }else if(gy<Q){
                gv=(gv+mod-1ll*binom(gx,gy)*binom(P-1-gx,Q-1-gy)%mod)%mod;
            }else{
                gv=binom(P,Q);
            }
            ++gx;
        }
        if(y<0){
            gy=y;
            gv=0;
        }else{
            if(gy<=0){
                gy=0;
                gv=binom(P-x,Q);
            }
            while(gy<y){
                (gv+=1ll*binom(gx,gy+1)*binom(P-x,Q-(gy+1))%mod)%=mod;
                ++gy;
            }
            while(gy>y){
                gv=(gv+mod-1ll*binom(gx,gy)*binom(P-x,Q-gy)%mod)%mod;
                --gy;
            }
        }
    }
}g1,g2;
vector<int> lf;
void dfs2(int x,int fa,int hh){
    hig[x]=hh;dfn[x]=++Tm;
    if(son[x]){
        dfs2(son[x],x,hh);
    }else{
        lf.push_back(x);
    }
    for(auto i:e[x]){
        if(i==fa||i==son[x]) continue;
        dfs2(i,x,i);
    }
}
int ans;
int calcf(int x,int y){
    int res=0;
    res=(res+mod-1ll*y*binom(X,Y)%mod)%mod;
    (res+=1ll*x*binom(X-1,Y-1)%mod)%=mod;
    (res+=2ll*y*g1.gv%mod)%=mod;
    res=(res+mod-2ll*x*g2.gv%mod)%mod;
    return res;
}
void work(int u){
    int nx=x[u]+y[u],ny=x[u]+z[u];
    g2.initg(nx-1,ny-1);
    g1.initg(nx,ny);
    while(1){
        nx=x[u]+y[u];ny=x[u]+z[u];
        g2.workg(nx-1,ny-1);
        g1.workg(nx,ny);
        int val=calcf(nx,ny);
        (ans+=val)%=mod;
        if(u==hig[u]) break;
        u=ff[u];
    }
}
void solve(){
    n=read();
    lf.clear();
    forup(i,1,n){
        e[i].clear();
        son[i]=0;ff[i]=0;
        z[i]=x[i]=y[i]=0;
    }
    ans=0;
    forup(i,1,n-1){
        int u=read(),v=read();
        e[u].push_back(v);
        e[v].push_back(u);
    }
    scanf(" %s",str+1);
    forup(i,1,n){
        if(str[i]=='?'){
            s[i]=2;
        }else{
            s[i]=(str[i]-'0');
        }
    }
    scanf(" %s",str+1);
    forup(i,1,n){
        if(str[i]=='?'){
            t[i]=2;
        }else{
            t[i]=(str[i]-'0');
        }
    }
    dfs(1,0);
    A=x[1];B=y[1];C=z[1];
    X=A+B;Y=A+C;
    g1.P=X;g1.Q=Y;
    g2.P=X-1;g2.Q=Y-1;
    dfs2(1,0,1);
    for(auto u:lf){
        work(u);
    }
    printf("%d\n",ans);
}
signed main(){
    init(1e6);
    int t=read();
    while(t--){
        solve();
    }
}
```

///

## P2048 [NOI2010] 超级钢琴

[传送门](https://www.luogu.com.cn/problem/P2048)

> 题意

- 有一个长度为 $n$ 的整数序列 $a_i$，代表钢琴上的键，称一个“和弦”为一个长度在 $[L,R]$ 之间的区间，其权值为区间内的整数之和。
- 选出 $m$ 个和弦，最大化权值和。
- $1\le n\le 5\times 10^5,-1000\le a_i\le 1000$

> 题解

感觉想到了就挺简单的。

首先考虑前缀和一下，这样可以很方便地求出以每个点为右端点的最大和弦。

然后发现最大值把左端点区间分成两半后，次大值必定是两边其中一个区间的最大值。这个可以用 ST 表简单维护。

那么对每个右端点用堆维护最优的左端点，然后类似于 shopping plans，每次将全局最大值拎出来（还是用堆维护），更新对应右端点的答案，显然也只需要更新最大值的区间。

注意 ST 表需要预处理 $[0,n]$ 的区间。

复杂度 $O((n+m)\log n)$。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=5e5+5,inf=0x3f3f3f3f;
int n,m,L,R;
int a[N],sum[N];
priority_queue<pii> mx;
struct Node{
    int l,r,mn;
    bool operator <(const Node &p)const{return sum[mn]>sum[p.mn];}
};
priority_queue<Node> q[N];
int st[19][N];
int Query(int l,int r){
    int len=31^__builtin_clz(r-l+1);
    return sum[st[len][l]]<sum[st[len][r-(1<<len)+1]]?st[len][l]:st[len][r-(1<<len)+1];
}
void work(int u){
    Node nw=q[u].top();q[u].pop();
    int l=nw.l,r=nw.r,mm=nw.mn;
    if(l<mm) q[u].push(Node{l,mm-1,Query(l,mm-1)});
    if(mm<r) q[u].push(Node{mm+1,r,Query(mm+1,r)});
    if(q[u].size()) mx.push(mkp(sum[u]-sum[q[u].top().mn],u));
}
signed main(){
    n=read();m=read();L=read();R=read();
    st[0][0]=0;
    forup(i,1,n){
        a[i]=read();
        sum[i]=sum[i-1]+a[i];
        st[0][i]=i;
    }
    forup(i,0,17){
        forup(j,0,n-(1<<(i+1))+1){
            st[i+1][j]=(sum[st[i][j]]<sum[st[i][j+(1<<i)]]?st[i][j]:st[i][j+(1<<i)]);
        }
    }
    forup(i,L,n){
        int ll=max(i-R,0),rr=i-L;
        int gt=Query(ll,rr);
        q[i].push(Node{ll,rr,gt});
        mx.push(mkp(sum[i]-sum[gt],i));
    }
    i64 res=0;
    forup(i,1,m){
        pii nw=mx.top();mx.pop();
        res+=nw.fi;
        work(nw.se);
    }
    printf("%lld\n",res);
}
```

///

## Gym-104120H Homework

[传送门](https://codeforces.com/gym/104120/problem/H)

> 题意

- 给定一张 $n$ 个点 $m$ 条边的图，其中一些边已经定向了，另一些边没有定向。
- 给每条边定向，使得这张图能被划分为若干个不共用边的有向环。
- $1\le n\le 300,1\le m\le \binom{n}{2}$，保证两个点之间至多有一条连边。

> 题解

挺套路的。

首先一个图能被划分为若干个不共用边的有向环当且仅当它的每个极大连通子图都有欧拉回路。

这个又当且仅当每个点的出度等于入度。

那么我们就能判掉一堆无解情况（度数是奇数，或者已经确定的入度/出度过大），转化成一个类似二分图匹配的问题，只不过第 $i$ 个右部点要匹配 $a_i$ 条边。

dinic 解决，复杂度 $O(m\sqrt{m})=O(n^3)$，用的是“dinic 复杂度不会超过 $O(C\sqrt{C})$，其中 $C$ 是网络流图容量和”的结论。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=305,inf=0x3f3f3f3f;
int n,m,cntn;
namespace flow{
    struct edge{
        int v,rst,nxt;
    }e[N*N*8];
    int head[N*N+N],cur[N*N+N],dpt[N*N+N],cnte=1,s,t;
    void adde(int u,int v,int rst){
        e[++cnte]=edge{v,rst,head[u]};head[u]=cnte;
        e[++cnte]=edge{u,rst,head[v]};head[v]=cnte;
    }
    bool bfs(){
        forup(i,1,cntn){
            cur[i]=head[i];
            dpt[i]=-1;
        }
        dpt[s]=0;
        queue<int> q;
        q.push(s);
        while(q.size()){
            int u=q.front();q.pop();
            for(int i=head[u];i;i=e[i].nxt){
                int v=e[i].v,rst=e[i].rst;
                if((~dpt[v])||!rst) continue;
                dpt[v]=dpt[u]+1;
                q.push(v);
            }
        }
        return ~dpt[t];
    }
    int dfs(int x,int flow){
        if(x==t||!flow) return flow;
        int res=0;
        for(int i=cur[x];i;i=e[i].nxt){
            cur[x]=i;
            int v=e[i].v,rst=e[i].rst;
            if(dpt[v]!=dpt[x]+1||!rst) continue;
            int gt=dfs(v,min(flow-res,rst));
            if(gt){
                e[i].rst-=gt;
                e[i^1].rst+=gt;
                res+=gt;
                if(res==flow) break;
            }
        }
        return res;
    }
    int dinic(){
        int ans=0;
        while(bfs()){
            ans+=dfs(s,inf);
        }
        return ans;
    }
}
int rd[N],cd[N],deg[N];
signed main(){
    n=read();m=read();
    flow::s=n+1;flow::t=n+2;
    cntn=flow::t;
    forup(i,1,m){
        int u=read(),v=read(),d=read();
        if(d){
            ++cd[u];++rd[v];
        }else{
            int nd=++cntn;
            flow::adde(nd,u,1);flow::adde(nd,v,1);
            flow::adde(flow::s,nd,1);
            ++deg[u];++deg[v];
        }
    }
    int sum=0;
    forup(i,1,n){
        if((cd[i]+rd[i]+deg[i])&1){
            puts("NO");
            return 0;
        }
        int v=(cd[i]+rd[i]+deg[i])/2;
        if(rd[i]>v||cd[i]>v){
            puts("NO");
            return 0;
        }
        flow::adde(i,flow::t,v-rd[i]);
        sum+=v-rd[i];
    }
    int res=flow::dinic();
    puts(res==sum?"YES":"NO");
}
```

///

## [AGC003F] Fraction of Fractal

[传送门](https://www.luogu.com.cn/problem/AT_agc003_f)

> 题意

- 给定一个 $n\times m$ 的 $01$ 矩阵 $a$，有一个矩阵 $s$，初始为大小 $1\times 1$，并且 $s_{1,1}=1$，进行 $k$ 次以下操作：
    - 将 $s$ 中所有 $1$ 替换成矩阵 $a$，所有 $0$ 替换成 $n\times m$ 的全 $0$ 矩阵。
- 称操作 $p$ 次得到的矩阵是 $2^p$ 求 $s^k$ 中有多少 $1$ 的四连通块。
- $1\le n,m\le 1000,0\le k\le 10^{18}$，**保证 $a$ 中的所有 $1$ 形成一个四连通块**，答案对 $10^9+7$ 取模。

> 题解

一开始想复杂了。

先手玩一下，可以发现：

- 如果 $\exists i,a_{1,i}=a_{n,i}=1$，那么将两个 $a$ 上下放置，会连在一起，称这样的 $a$ 是“上下连通的”。
- 如果 $\exists i,a_{i,1}=a_{i,m}=1$，那么将两个 $a$ 左右放置，会连在一起，称这样的 $a$ 是“左右连通的”。

容易发现，若 $a$ 既上下连通又左右连通，那么最终必定只有一个连通块，同理，若既不上下连通，又不左右连通，那么最终必定有 $c^{k-1}$ 个连通块（其中 $c$ 是 $a$ 中 $1$ 的个数，就是最终图中有多少个 $a$）。

于是只需要考虑一边连通一边不连的情况了，不妨认为是左右连通的。

不难想到点边容斥，即“$a$ 的数量”减去“与左侧矩阵连通的 $a$ 的数量”，前者是好算的，快速幂即可。考虑后者。

$k=0$ 特判，考虑从 $s^1$ 开始，容易发现 $a$ 中每有一个形如 $11$ 的结构，就会产生一次贡献，但是 $s_2$ 时，需要考虑 $s^2$ 左边缘的所有 $a$ 和右边缘的 $a$ 的贡献，其实就是 $a_{i,1}=a_{i,m}=1$ 的 $i$ 的数量。

于是我们需要维护“左右边缘的匹配数量”和“总匹配数量”，不难想到用矩阵乘法概括，具体略。

复杂度 $O(2^3\log k)$。

另外 $a$ 不连通貌似也能做（我一开始就没考虑 $a$ 连通），大概要平面图欧拉定理，感觉巨复杂无比。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(i64 i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(i64 i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<i64,i64>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
i64 read(){
    i64 x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const i64 N=1005,mod=1e9+7;
struct Matrix{
    i64 c[2][2];
    void init(bool p=0){
        mem(c,0);
        if(p){
            forup(i,0,1){
                c[i][i]=1;
            }
        }
    }
    Matrix operator*(const Matrix &r){
        Matrix res;res.init();
        forup(i,0,1){
            forup(j,0,1){
                forup(k,0,1){
                    (res.c[i][j]+=1ll*c[i][k]*r.c[k][j]%mod)%=mod;
                }
            }
        }
        return res;
    }
    void print(){
        msg("=====\n");
        forup(i,0,1){
            forup(j,0,1){
                msg("%lld ",c[i][j]);
            }msg("|\n");
        }msg("=====\n");
    }
}tr;
Matrix ksm(Matrix a,i64 b){
    Matrix c;c.init(1);
    while(b){
        if(b&1) c=a*c;
        a=a*a;
        b>>=1;
    }
    return c;
}
i64 ksm(i64 a,i64 b){
    i64 c=1;
    while(b){
        if(b&1) c=1ll*a*c%mod;
        a=1ll*a*a%mod;
        b>>=1;
    }
    return c;
}
i64 n,m,k,a[N][N],cnt0,cntc,cntr;
char str[N];
signed main(){
    n=read();m=read();k=read();
    if(k==0){
        puts("1");
        return 0;
    }
    forup(i,1,n){
        scanf(" %s",str+1);
        forup(j,1,m){
            a[i][j]=(str[j]=='#');
            cnt0+=a[i][j];
            if(i>1) cntr+=(a[i][j]&a[i-1][j]);
            if(j>1) cntc+=(a[i][j]&a[i][j-1]);
        }
    }
    tr.init();
    i64 c0=0,c1=0;
    forup(i,1,n){
        if(a[i][1]&&a[i][m]){
            ++c0;
        }
    }
    forup(i,1,m){
        if(a[1][i]&&a[n][i]){
            ++c1;
        }
    }
    if(c0==0&&c1==0){
        printf("%lld\n",ksm(cnt0,k-1));
    }else if(c0&&c1){
        puts("1");
    }else{
        if(c1){swap(c0,c1);swap(cntc,cntr);}
        tr.c[0][0]=c0;
        tr.c[0][1]=cntc;
        tr.c[1][1]=cnt0;
        tr.print();
        Matrix res=ksm(tr,k-1);
        res.print();
        i64 cntn=0,cnte=0;
        cntn=res.c[1][1];
        cnte=res.c[0][1];
        printf("%lld\n",(cntn+mod-cnte)%mod);
    }
}
```

///

## QOJ#1288 Tokens on the Tree

[传送门](https://qoj.ac/problem/1288)

> 题意

- 有一棵 $n$ 树，上面有 $w$ 个白色棋子和 $b$ 个黑色棋子，称一个摆放方式是合法的当且仅当白色棋子和黑色棋子均连成了连通块，并且每个格子上至多有一个棋子。
- 现在你可以进行任意次以下操作：
    - 选择一个棋子，将其移动到与某和它同色的棋子相邻的空格。
- 显然无论怎么操作这个摆放方式都是合法的。
- 称两摆放方式等价，当且仅当两摆放方式可以通过若干上述操作互相转化。
- 给定一棵 $n$ 个点的树，设 $f(w,b)$ 表示 $w$ 个白子和 $b$ 个黑子摆放方式的等价类个数，求：

    $$
    \left(\sum_{w=1}^{n-1}\sum_{b=1}^{n-w}f(w,b)\times w\times b\right)\bmod (10^9+7)
    $$

- $1\le n\le 2\times 10^5$

> 题解

神秘构造。

不妨设 $w\ge b$，将 $w > b$ 的贡献乘以二即可。

设 $mx_i$ 表示将点 $i$ 删掉后得到的连通块里面最大的那个。容易发现若 $w > mx_i$，则点 $i$ 上面必定有一颗白子，将所有满足上述条件的点删掉，此时 $f(w,b)$ 就是剩下的连通块里面大小大于等于 $b$ 的个数。

若不存在这样的点，容易发现答案只可能是 $1,2$，并且是一当且仅当存在一个点 $u$，将其删掉后连通块的前两大值都大于等于 $w$，并且第三大值大于等于 $b$。

那么我们找到 $mx_i$ 的最小值 $m$，小于等于 $m$ 的 $w$ 和大于 $w$ 的分开维护，具体实现细节略，可以做到 $O(n)$，但是我求前三大值用了排序，是 $O(n\log n)$ 的。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=2e5+5,mod=1e9+7;
int n;
vector<int> e[N],vec[N];
int sz[N],mx[N];
int rt;
int pmx[N];
void dfs(int x,int fa){
    sz[x]=1;mx[x]=0;
    for(auto i:e[x]){
        if(i==fa) continue;
        dfs(i,x);
        mx[x]=max(mx[x],sz[i]);
        sz[x]+=sz[i];
        vec[x].push_back(sz[i]);
    }
    mx[x]=max(mx[x],n-sz[x]);
    vec[x].push_back(n-sz[x]);
    sort(vec[x].begin(),vec[x].end(),greater<int>());
    if(mx[x]<=n/2){
        rt=x;
    }
}
int calc(int l,int r){
    if(l>r) return 0;
    return (1ll*(r-l+1)*(l+r)/2)%mod;
}
vector<int> add[N],del[N];
int ff[N];
void dfs2(int x,int fa){
    ff[x]=fa;sz[x]=1;
    for(auto i:e[x]){
        if(i==fa) continue;
        dfs2(i,x);
        sz[x]+=sz[i];
    }
}
void solve(){
    n=read();
    forup(i,1,n+1){
        e[i].clear();vec[i].clear();
        add[i].clear();del[i].clear();
        pmx[i]=ff[i]=0;
    }
    forup(i,2,n){
        int f=read();
        e[i].push_back(f);
        e[f].push_back(i);
    }
    if(n==2){
        puts("2");
        return;
    }
    rt=0;
    dfs(1,0);
    dfs2(rt,0);
    int m=vec[rt][0];
    forup(u,1,n){
        if(vec[u].size()>=3){
            pmx[vec[u][1]]=max(pmx[vec[u][1]],vec[u][2]);
        }
        if(mx[u]==m) continue;
        add[mx[ff[u]]+1].push_back(sz[u]);
        del[mx[u]+1].push_back(sz[u]);
    }
    int ans=0;
    fordown(i,n,1){
        pmx[i]=max(pmx[i],pmx[i+1]);
    }
    forup(w,1,m){
        (ans+=2ll*calc(1,min(w-1,pmx[w]))%mod*w%mod)%=mod;
        (ans+=4ll*calc(pmx[w]+1,w-1)%mod*w%mod)%=mod;
        if(w<=pmx[w]) (ans+=1ll*w*w%mod)%=mod;
        else (ans+=2ll*w*w%mod)%=mod;
    }
    int val=0;
    for(auto i:add[m]){
        (val+=calc(1,i))%=mod;
    }
    for(auto i:del[m]){
        val=(val+mod-calc(1,i))%mod;
    }
    forup(w,m+1,n-1){
        for(auto i:add[w]){
            (val+=calc(1,i))%=mod;
        }
        for(auto i:del[w]){
            val=(val+mod-calc(1,i))%mod;
        }
        (ans+=2ll*w*val%mod)%=mod;
    }
    printf("%d\n",ans);
}
signed main(){
    int t=read();
    while(t--){
        solve();
    }
}
```

///

## QOJ#5020 举办乘凉州喵，举办乘凉州谢谢喵

[传送门](https://qoj.ac/problem/5020)

> 题意

- 给定一棵 $n$ 个点的树，有 $m$ 次查询，每次查询与链 $x\to y$ 距离小于等于 $d$ 的点个数。
- 点和链的距离定义如下：
    - 设这条链占据点集 $S$，定义点 $u$ 和这条链的距离为 $\min_{v\in S}dist(u,v)$，其中 $dist(u,v)$ 表示 $u,v$ 之间简单路径上的边数。
- $1\le n,q\le 2\times 10^5$

> 题解

很 cool 的一道题。

考虑链上询问常见做法是用差分转化成若干个 $1\to u$ 的问题，考虑这道题怎么做。

不妨用 $f(x,y,d)$ 表示“与链 $x\to y$ 距离小于等于 $d$ 的点个数”，不难发现：

$$
f(x,y,d)=f(1,x,d)+f(1,y,d)-2f(1,p,d)+f(p,p,d)
$$

其中 $p=\mathrm{lca}(x,y)$。

发现 $f(p,p,d)$ 可以点分治求出，于是只关注 $f(1,u,d)$ 怎么求。

处理链信息不难想到重链剖分，容易发现整链我们只需要算轻儿子的贡献，而两链之间的轻边简单容斥即可，不妨设 $g(x,d)$ 表示 $x$ 所有轻儿子中距离 $x$ 小于等于 $d$ 的点数，$h(x,d)$ 表示以 $x$ 为根的子树中距离 $x$ 小于等于 $d$ 的点数 $son_u$ 表示 $u$ 的重儿子。设从 $u$ 到根经过了 $m$ 条重链，其中第 $i$ 条重链是从 $s_i$ 进入到 $t_i$（即重链链顶）走出，有：

$$
f(1,u,d)=dpt_u+h(son_u,d-1)+\sum_{i=1}^m\left(\sum_{j\in(s_i,t_i)}g(j,d)\right)+h(son_{s_i},d-1)-h(t_i,d-1)
$$

其中 $j\in(s_i,t_i)$ 表示 $j$ 枚举 $s_i\to t_i$ 路径上所有点。

由于每个点轻儿子的个数总和是 $O(n\log n)$ 级别的，那么可以在进行 dfs 的途中暴力遍历轻儿子用树状数组维护 $g$，而 $h$ 可以 DSU on tree $+$ 树状数组解决，因为 $m$ 是 $O(\log n)$ 级别的，所以要进行 $O(q\log n)$ 次查询，复杂度 $O(n\log^2 n)$。

注意树状数组边界情况。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123=(e);i<=E123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123=(e);i>=E123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
	int x=0,f=1;char c;
	while(!isdigit(c=gc)){if(c=='-')f=-1;}
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const int N=2e5+5,inf=0x3f3f3f3f;
int n,m;
vector<int> e[N];
int ans[N];
vector<pii> q[N];
int sz[N],mx[N],als,rt;
int vis[N];
void dfs1(int x,int fa){
    sz[x]=1;mx[x]=0;
    for(auto i:e[x]){
        if(i==fa||vis[i]) continue;
        dfs1(i,x);
        sz[x]+=sz[i];
        mx[x]=max(mx[x],sz[i]);
    }
    mx[x]=max(mx[x],als-sz[x]);
    if(mx[x]<=als/2) rt=x;
}
int cnt[N];
void dfs2(int x,int fa,int dis){
    ++cnt[dis];
    for(auto i:e[x]){
        if(i==fa||vis[i]) continue;
        dfs2(i,x,dis+1);
    }
}
vector<pii> qu;
void dfs3(int x,int fa,int dis){
    --cnt[dis];
    for(auto i:q[x]){
        if(i.fi>=dis){
            qu.push_back(mkp(i.fi-dis,i.se));
        }
    }
    for(auto i:e[x]){
        if(i==fa||vis[i]) continue;
        dfs3(i,x,dis+1);
    }
}
void dfz(int x,int ps){
    dfs2(x,0,0);
    vis[x]=1;
    sort(q[x].begin(),q[x].end());
    int pl=0,sum=0;
    for(auto i:q[x]){
        while(pl<=i.fi&&pl<=ps){
            sum+=cnt[pl];++pl;
        }
        ans[i.se]+=sum;
    }
    for(auto i:e[x]){
        if(vis[i]) continue;
        qu.clear();
        dfs3(i,x,1);
        sort(qu.begin(),qu.end());
        int pl=0,sum=0;
        for(auto i:qu){
            while(pl<=i.fi&&pl<=ps){
                sum+=cnt[pl];++pl;
            }
            ans[i.se]+=sum;
        }
        dfs2(i,x,1);
    }
    forup(i,0,ps) cnt[i]=0;
    for(auto i:e[x]){
        if(vis[i]) continue;
        rt=0;als=(sz[i]<sz[x]?sz[i]:ps-sz[x]);
        dfs1(i,x);
        dfz(rt,als);
    }
}
int dfn[N],Tm,siz[N],son[N],hig[N],dpt[N],ff[N],mp[N];
void _0dfs(int x,int fa){
    siz[x]=1;dpt[x]=dpt[fa]+1;
    ff[x]=fa;
    for(auto i:e[x]){
        if(i==fa) continue;
        _0dfs(i,x);
        siz[x]+=siz[i];
        if(!son[x]||siz[i]>siz[son[x]]) son[x]=i;
    }
}
void _1dfs(int x,int fa,int hh){
    dfn[x]=++Tm;hig[x]=hh;
    mp[dfn[x]]=x;
    if(son[x]){
        _1dfs(son[x],x,hh);
    }
    for(auto i:e[x]){
        if(i==fa||i==son[x]) continue;
        _1dfs(i,x,i);
    }
}
int lca(int u,int v){
    while(hig[u]!=hig[v]){
        if(dpt[hig[u]]<dpt[hig[v]]) swap(u,v);
        u=ff[hig[u]];
    }
    if(dpt[u]<dpt[v]) swap(u,v);
    return v;
}
struct Node{
    int d,val,pos;
};
vector<Node> q1[N],q2[N];
void getqu(int x,int d,int i,int v){
    ans[i]+=v*dpt[x];
    q1[x].push_back(Node{d,v,i});
    while(x){
        if(son[x]) q2[son[x]].push_back(Node{d-1,v,i});
        q2[hig[x]].push_back(Node{d-1,-v,i});
        x=ff[hig[x]];
    }
}
struct BIT{
    int c[N];
    void upd(int x,int k){for(;x<=n;x+=x&-x)c[x]+=k;}
    int sum(int x){int res=0;for(;x>0;x-=x&-x)res+=c[x];return res;}
}t1,t2;
void dfs4(int x,int fa){
    for(auto i:e[x]){
        if(i==fa||i==son[x]) continue;
        forup(j,dfn[i],dfn[i]+siz[i]-1){
            int u=mp[j];
            t1.upd(dpt[u]-dpt[x],1);
        }
    }
    for(auto i:q1[x]){
        msg("A %d %d %d|\n",x,i.d,t1.sum(i.d));
        ans[i.pos]+=i.val*t1.sum(i.d);
    }
    for(auto i:e[x]){
        if(i==fa||i==son[x]) continue;
        dfs4(i,x);
        forup(j,dfn[i],dfn[i]+siz[i]-1){
            int u=mp[j];
            t2.upd(dpt[u],-1);
        }
    }
    if(son[x]){
        dfs4(son[x],x);
    }
    for(auto i:e[x]){
        if(i==fa||i==son[x]) continue;
        forup(j,dfn[i],dfn[i]+siz[i]-1){
            int u=mp[j];
            t2.upd(dpt[u],1);
        }
    }
    t2.upd(dpt[x],1);
    for(auto i:q2[x]){
        msg("B %d %d %d|\n",x,i.d,t2.sum(min(n,dpt[x]+i.d)));
        ans[i.pos]+=i.val*t2.sum(min(n,dpt[x]+i.d));
    }
    for(auto i:e[x]){
        if(i==fa||i==son[x]) continue;
        forup(j,dfn[i],dfn[i]+siz[i]-1){
            int u=mp[j];
            t1.upd(dpt[u]-dpt[x],-1);
        }
    }
}
signed main(){
	n=read();
	forup(i,1,n-1){
		int u=read(),v=read();
		e[u].push_back(v);
		e[v].push_back(u);
	}
    _0dfs(1,0);
    _1dfs(1,0,1);
    forup(i,1,n){
        msg("%d ",hig[i]);
    }msg("|\n");
	m=read();
    forup(i,1,m){
        int x=read(),y=read(),d=read();
        if(x!=y){
            int p=lca(x,y);
            q[p].push_back(mkp(d,i));
            getqu(x,d,i,1);getqu(y,d,i,1);
            getqu(p,d,i,-2);
        }else{
            q[x].push_back(mkp(d,i));
        }
        msg("%d|\n",ans[i]);
    }
    rt=0;als=n;
    dfs1(1,0);
    dfz(rt,als);
    dfs4(1,0);
    forup(i,1,m){
        printf("%d\n",ans[i]);
    }

}
```

///

## P8863 「KDOI-03」构造数组

[传送门](https://www.luogu.com.cn/problem/P8863)

> 题意

- 给定一个数组 $b$，你可以进行若干次以下操作：
    - 选择两个数 $i,j$ 满足 $b_i > 0,b_j > 0,i < j$，$b_i\gets b_i-1,b_j\gets b_j-1$，这个操作记为二元组 $(i,j)$。
- 问有多少种操作方式能让 $b$ 变为全 $0$，我们认为两操作方式不同当且仅当存在一个 $x$，使得两操作方式中第 $x$ 步选择的二元组不同。
- $1\le n\le 5000,1\le b_i\le 30000,\sum b_i\le 30000$，答案对 $998244353$ 取模。时限 4s。

> 题解

其实这道题很简单，但是赛时放模拟赛 T4，然后 T3 因为本地机子太慢一直在卡常就没认真想，唉。

设 $m=\sum b_i$，首先显而易见的，若 $m\bmod 2=1$ 则显然无解，否则相当于把 $m$ 个小球放进若干个盒子里，每个盒子都要放两个不同颜色的小球，盒子有标号小球无标号。

发现这其实是经典的 DP，设 $f_{i,j,k,l}$ 表示考虑前 $i$ 种颜色的小球，现在有 $j$ 个盒子放了两颗，$k$ 个放了一个，$l$ 个空盒子。转移就枚举这 $b_i$ 个小球有多少放进有一个小球的，多少放进空盒，乘一个组合数即可。

不难发现 $j,k,l$ 只要确定了 $i$ 和其中一个就能确定剩下两个，那么状态数是 $O(nm)$ 的，又注意到转移时需要枚举 $b_i$，但是 $b_i$ 的总和是 $m$，所以复杂度 $O(m^2)$，然后滚动数组优化一下空间就能过了。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=5005,M=30005,mod=998244353;
int ksm(int a,int b){
    int c=1;
    while(b){
        if(b&1) c=1ll*a*c%mod;
        a=1ll*a*a%mod;
        b>>=1;
    }
    return c;
}
int n,m,a[N],sum;
int dp[2][M];
int fact[M],finv[M];
int binom(int n,int m){
    if(n<m) return 0;
    return 1ll*fact[n]*finv[m]%mod*finv[n-m]%mod;
}
signed main(){
    n=read();
    forup(i,1,n){
        a[i]=read();
        sum+=a[i];
    }
    if(n==1||(sum&1)){
        puts("0");
        return 0;
    }
    if(n==2){
        if(a[1]==a[2]){
            puts("1");
        }else{
            puts("0");
        }
        return 0;
    }
    fact[0]=1;
    forup(i,1,sum) fact[i]=1ll*fact[i-1]*i%mod;
    finv[sum]=ksm(fact[sum],mod-2);
    fordown(i,sum-1,0) finv[i]=1ll*finv[i+1]*(i+1)%mod;
    m=sum/2;
    sum=0;
    dp[0][0]=1;
    forup(i,1,n){
        int p=i&1,q=p^1;
        mem(dp[p],0);
        sum+=a[i];
        forup(j,max(sum-m,0),sum/2){
            int k=sum-j*2,l=m-j-k;
            forup(c1,max(0,a[i]-k),min(a[i],j)){
                int c2=a[i]-c1;
                int j1=j-c1,k1=k+c1-c2;
                if(j1*2+k1!=sum-a[i]) continue;
                (dp[p][j]+=1ll*dp[q][j-c1]*binom(k+c1-c2,c1)%mod*binom(l+c2,c2)%mod)%=mod;
            }
        }
    }
    printf("%d\n",dp[n&1][m]);
}
```

///

## 模拟赛神秘题目 【1112 B组】D 逃脱

《》

> 题意

- 有一棵树，每个度数为 $1$ 的点视为出口，上面有一个逃脱者和若干个围堵者，围堵者初始只能从某出口出发。
- 每回合逃脱者和所有围堵者同时移动到相邻的格子（可以不动），当逃脱者和任意围堵者处于同一格时逃脱者胜利，否则，若逃脱者处于任意出口，则逃脱者胜利。
- 现在对于逃脱者的所有 $n$ 个起点，求至少需要多少个围堵者才能让逃脱者必败。
- $1\le n\le 7\times 10^4$

> 题解

首先若逃脱者出生就在出口则只需要一个，因为可以在这个出口安排一个围堵者。

否则我们将逃脱者出生点视为根，不难发现围堵者一直往上走是不劣的。

因为我们需要让逃脱者往任意方向走都会被堵住，假设逃脱者看准了一个叶子直着冲过去，那么它就会在根和叶子的中点被拦下。

那么我们可以认为所有叶子和根的中点会对这个根产生一次贡献，但是显然若某个点的祖先中已经有贡献点了就不会再产生一次贡献，那么不妨把限制放宽一点，**一个点产生贡献当且仅当它和最近的叶子的距离比和根的距离进，且祖先中没有贡献点**。

然后我们不认为出生点是根，限制就变成了出生点到这个点的路径上没有贡献点，预处理每个点和最近叶子的距离后不难用点分治维护（每个连通块考虑从点到根和从根到点的两段都不能有），复杂度 $O(n\log n)$，注意特判在叶子出生的情况。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=7e4+5,inf=0x3f3f3f3f;
int n,ans[N];
vector<int> e[N];
int mn[N];
void dfs(int x,int fa){
    mn[x]=inf;
    if(e[x].size()==1) mn[x]=0;
    for(auto i:e[x]){
        if(i==fa) continue;
        dfs(i,x);
        mn[x]=min(mn[x],mn[i]+1);
    }
}
void dfs0(int x,int fa){
    for(auto i:e[x]){
        if(i==fa) continue;
        mn[i]=min(mn[i],mn[x]+1);
        dfs0(i,x);
    }
}
int sz[N],mx[N],vis[N],als,rt;
void dfs1(int x,int fa){
    sz[x]=1;mx[x]=0;
    for(auto i:e[x]){
        if(i==fa||vis[i]) continue;
        dfs1(i,x);
        sz[x]+=sz[i];
        mx[x]=max(mx[x],sz[i]);
    }
    mx[x]=max(mx[x],als-sz[x]);
    if(mx[x]<=als/2) rt=x;
}
int val[N],vv[N],dd[N];
void dfs2(int x,int fa,int p){
    int pl=max(mn[x]-dd[x],0),pr=pl-1;
    for(int i=max(mn[x]-dd[x],0);i<=als;++i){
        if(vv[i]) break;
        vv[i]=1;pr=i;
        val[i]+=p;
    }
    for(auto i:e[x]){
        if(i==fa||vis[i]) continue;
        dd[i]=dd[x]+1;
        dfs2(i,x,p);
    }
    forup(i,pl,pr){
        vv[i]=0;
    }
}
void dfs3(int x,int fa,int mxd){
    mxd=min(mxd,dd[x]+mn[x]);
    if(dd[x]>=mxd) return;
    ans[x]+=val[dd[x]];
    for(auto i:e[x]){
        if(i==fa||vis[i]) continue;
        dfs3(i,x,mxd);
    }
}
void dfz(int x,int ps){
    dd[x]=0;
    dfs2(x,0,1);
    msg("[%d]",x);
    forup(i,0,ps){
        msg("%d ",val[i]);
    }msg("|\n");
    ans[x]+=val[0];
    for(int i=max(mn[x]-dd[x],0);i<=als;++i){
        vv[i]=1;
    }
    for(auto i:e[x]){
        if(vis[i]) continue;
        dfs2(i,x,-1);
        dfs3(i,x,als);
        dfs2(i,x,1);
    }
    forup(i,0,ps){
        val[i]=vv[i]=0;
    }
    vis[x]=1;
    for(auto i:e[x]){
        if(vis[i]) continue;
        rt=0;als=sz[i]<sz[x]?sz[i]:ps-sz[x];
        dfs1(i,x);
        dfz(rt,als);
    }
}
signed main(){
    n=read();
    forup(i,1,n-1){
        int u=read(),v=read();
        e[u].push_back(v);
        e[v].push_back(u);
    }
    dfs(1,0);
    dfs0(1,0);
    als=n;rt=0;
    dfs1(1,0);
    dfz(rt,als);
    forup(i,1,n){
        if(e[i].size()==1){
            printf("1 ");
        }else{
            printf("%d ",ans[i]);
        }
    }
}
```

///

## [AGC018C] Coins

[传送门](https://www.luogu.com.cn/problem/AT_agc018_c)

> 题意

- 有 $x+y+z$ 个人，每个人手上有 $a_i$ 个金币，$b_i$ 个银币，$c_i$ 个铜币。
- 现在你要选 $x$ 个人把金币给你，从剩下的里面选 $y$ 个人把银币给你，剩下 $z$ 个人把铜币给你。
- 问你最多能拿到多少个钱币。
- $1\le x,y,z\le 10^5,x+y+z\le 10^5,1\le a_i,b_i,c_i\le 10^9$

> 题解

容易想到模拟网络流，但是过于难写了，调了好久调破防了遂看题解。

考虑假设每个人最初把铜币给你，然后选 $x$ 个人获得 $a_i-c_i$ 的贡献，从剩下的人里面选择 $y$ 个获得 $b_i-c_i$ 的贡献，不妨设 $e_i=a_i-c_i,f_i=b_i-c_i$。

考虑一个类似邻项交换法的东西，若 $e_i+f_j\ge e_j+f_i$，则 $e_i-f_i\ge e_j-f_j$，那么按这个排序就能发现应是一个前缀前 $x$ 大的 $e$ 和后缀前 $y$ 大的 $f$ 贡献，随便维护一下即可。

用堆复杂度是 $O(n\log n)$，其中 $n=x+y+z$。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(i64 i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(i64 i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<i64,i64>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
i64 read(){
    i64 x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const i64 N=1e5+5,inf=1e18;
i64 x,y,z,n,a[N],b[N],c[N],ans;
struct Node{
    i64 a,b;
}s[N];
i64 pre[N],suf[N];
priority_queue<i64,vector<i64>,greater<i64>> q;
signed main(){
    x=read();y=read();z=read();
    n=x+y+z;
    forup(i,1,n){
        a[i]=read();b[i]=read();c[i]=read();
        ans+=c[i];
        s[i]=Node{a[i]-c[i],b[i]-c[i]};
    }
    sort(s+1,s+n+1,[&](Node a,Node b){return a.a-a.b>b.a-b.b;});
    i64 sum=0;
    forup(i,1,x){
        q.push(s[i].a);
        sum+=s[i].a;
    }
    pre[x]=sum;
    forup(i,x+1,n){
        sum+=s[i].a;q.push(s[i].a);
        sum-=q.top();q.pop();
        pre[i]=sum;
    }
    while(q.size()) q.pop();
    sum=0;
    fordown(i,n,n-y+1){
        q.push(s[i].b);
        sum+=s[i].b;
    }
    suf[n-y+1]=sum;
    fordown(i,n-y,1){
        sum+=s[i].b;q.push(s[i].b);
        sum-=q.top();q.pop();
        suf[i]=sum;
    }
    i64 mx=-inf;
    forup(i,x,n-y){
        mx=max(mx,pre[i]+suf[i+1]);
    }
    printf("%lld\n",ans+mx);
}
```

///

## [AGC007F] Shik and Copying String

[传送门](https://www.luogu.com.cn/problem/AT_agc007_f)

> 题意

- 给定两个长度为 $n$ 的字符串 $s^0,t$，定义 $s^k$ 为一个字符串满足 $s^k_i$ 不等于 $s^{k-1}_i$ 就等于 $s^k_{i-1}$，求让 $s^k=t$ 的最小的 $k$，无解输出 $-1$。
- $1\le n\le 10^6$

> 题解

贪心。

把每种字符视为一种颜色，不难找到每个颜色最终需要覆盖到哪个位置，从右往左贪心向右匹配即可。

注意到任意时刻这个颜色的连续段都不能跨过右侧下一个颜色，不难发现暴力往右走是最优的，那么我们可以维护每个时刻下个颜色的左端点。

又注意到颜色的左端点在时刻上其实是若干连续段的形式，那么我们只需要维护连续段交界点即可。然后显然地，若这个颜色始终紧贴下一颜色，那么每个连续段必定左右端点都是下个颜色的向右平移一个时刻，可以打懒标记维护。

那么何时不会紧贴呢？首先开头时可能不紧贴，其次是末尾某段假如已经到了自己的匹配点，那么一直向下即可。

答案就是匹配过程中找到的连续段最大的连续段右端点，复杂度 $O(n)$。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=1e6+5;
int n;
char s[N],t[N];
int pr[N];
signed main(){
    n=read();
    scanf(" %s",s+1);
    scanf(" %s",t+1);
    queue<int> q;
    fordown(i,n,1){
        q.push(i);
        if(t[q.front()]==s[i]){
            pr[i]=q.front();
            while(q.size()&&t[q.front()]==s[i]) q.pop();
        }
    }
    if(q.size()){
        puts("-1");
        return 0;
    }
    deque<pii> vec;
    int ans=0,pre=n+1,adx=0,ady=0;
    fordown(i,n,1){
        if(!pr[i]) continue;
        if(pr[i]==i){
            vec.clear();adx=ady=0;
        }
        adx+=1;ady-=1;
        while(vec.size()&&vec.back().se+ady>=pr[i]) vec.pop_back();
        if(vec.empty()) adx=ady=0;
        if(pre>i+1) vec.push_front(mkp(1-adx,i-ady));
        if(vec.size()) ans=max(ans,vec.back().fi+adx);
        pre=i;
    }
    printf("%d\n",ans);
}
```

///

## [AGC009D] Uninity

[传送门](https://www.luogu.com.cn/problem/AT_agc009_d)

> 题意

- 定义一棵 $0$ 阶树为一个点的无根树，一棵 $i$ 阶树为一个点上连了 $x\ge 0$ 棵 $i-1$ 阶树的无根树。
- 显然任意 $k$ 阶树也是 $k+1,k+2,\dots$ 阶树，给定一棵 $n$ 个点的树，求这棵树至少是多少阶树。
- $1\le n\le 10^5$

> 题解

妙妙贪心题。

首先第一眼看过去哇塞这不是点分治板题吗，然后仔细想一下发现不对，因为一棵树可能有俩重心，从两个地方分开答案可能不同。

然后假如顺着这个思路想就寄了。发现点分治求最优点分树并不好做，考虑能不能丢弃题目原有的限制，抽象出一个相对独立的充要条件。

《容易》发现相当于给每个点赋一个 $d$ 表示这个点是第几阶树的根，满足任意两相等的 $d_u,d_v$ 之间的简单路径上都有至少一个 $d_x > d_u$。设 $d$ 的最大值为 $k$，显然可以直接从这个编号构造出 $k$ 阶树，并且任意 $k$ 阶树都能由这样的编号概括，于是就充分必要了。

那么怎么求答案呢？随便定一个根，然后 dfs 的过程中维护每个点都在**不与子树冲突的情况下取最小值**，因为你容易发现一个较大值对全局最大值的影响必定大于任意多个较小值，于是贪心地最小化每个点是正确的。

具体实现考虑一些位运算，对每个点维护一个 $msk_u$ 表示子树内和 $u$ 之间路径上没有更大值的 $d$ 的集合，注意到 $d$ 的上界是 $\left\lfloor\log_2 n\right\rfloor$，所以直接用一个整数状压即可。每个 $u$ 的限制就能不能取儿子 $msk$ 的并集中的点，并且必须大于最大的 $d'$ 满足至少两儿子的 $msk$ 中含有这个数。然后对 $msk_u$ 小于 $d_u$ 的部分推平即可，用一些位运算复杂度能做到 $O(n)$。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=1e5+5,inf=0x3f3f3f3f;
int n,p,ans;
vector<int> e[N];
int msk[N],dp[N];
void dfs(int x,int fa){
    int OR=0;
    int cnt=0;
    dp[x]=0;
    for(auto i:e[x]){
        if(i==fa) continue;
        ++cnt;
        dfs(i,x);
        if(OR&msk[i]){
            dp[x]=max(dp[x],(31^__builtin_clz(OR&msk[i]))+1);
        }
        OR|=msk[i];
    }
    while(OR&(1<<dp[x])) ++dp[x];
    OR=OR&((1<<p)-(1<<dp[x]));
    OR|=(1<<dp[x]);
    msk[x]=OR;
    ans=max(ans,dp[x]);
}
signed main(){
    n=read();
    p=(31^__builtin_clz(n))+1;
    forup(i,1,n-1){
        int u=read(),v=read();
        e[u].push_back(v);
        e[v].push_back(u);
    }
    dfs(1,0);
    printf("%d\n",ans);
}
```

///

## NIKKEI Programming Contest 2019 F-Jewels

[传送门](https://atcoder.jp/contests/nikkei2019-qual/tasks/nikkei2019_qual_f)

> 题意

- 有 $n$ 个物品，每个物品有一个颜色 $c_i(1\le c_i\le m)$ 和一个价值 $v_i$。
- 对于任意一种颜色，都不能恰好只选 $1$ 个该颜色的物品（即要么不选要么至少选两个）。
- 对于 $i=1\sim n$，求选恰好 $i$ 个物品的最大价值，无解输出 $-1$。
- $1\le n\le 2\times 10^5,1\le m\le \frac{n}{2},1\le v_i\le 10^9$，保证每种颜色至少出现两次。

> 题解

很趣味的一道题。

首先 $i=1$ 无解，然后若每种颜色都出现恰好两次则奇数无解，否则对于 $i=2\sim n$ 必定有解。

一个显然的观察是每个颜色必定是选择价值最大的若干个。考虑如何从选 $i$ 个推到 $i+1$ 个。假设我们已经求出了选 $i$ 个的最优答案。

首先最多只会增加一个已有颜色，假如增加超过一个，那么需要对其它位置进行一些操作使得总物品数减少一个。设减少的权值为 $v$，增加的两个分别为 $u_1,u_2$（不妨设 $u_1\ge u_2$），因为 $u_1+u_2-v > u_1$，则 $u_2 > v$，那么 $u_1 > v$，则从选 $p$ 个的情况中去掉 $v$ 再加上 $u_1$ 是更优的，并且显然无论 $u_1,u_2$ 颜色是否相同这个操作都合法，与先前的“最优”矛盾。

然后最多只会减少一个已有颜色（不考虑减掉之后这个颜色消失的情况），首先当减少时，其它增加的必定只能增加原先没有的颜色，否则可以简单调整得到更优解（即与最优矛盾），那么假设我们减少了两个，则必定是某个原先没有的颜色增加三个，设增加的是 $v_1,v_2,v_3$，减少的是 $u_1,u_2$（同理不一定同色，钦定 $u_1\ge u_2$），因为这个比减一增二优（减去 $u_2$，增加 $v_1,v_2$），则 $v_3 > u_1$，，于是 $v_1 > v_2 > v_3 > u_1 >u_2$，则 $v_1+v_2 > u_1+u_2$，调整过去更优，与“最优”矛盾。减三增四就更简单了，因为只能新增两对同颜色的（直接增加四个同色的等价于减二增三加上情况一），那么较小的那对必定大于减去的三个里面较小的两个，于是调整过去更优。

然后任意情况下，每次都最多减少三个，超过三个的时候必定是减去若干个 $2$ 和至多一个 $1$（注意 $1$ 能和某个 $2$ 颜色相同），增加的时候也只能是若干个 $2$ 和至多一个 $1$（同理）。因为减去的至少有四个，则必然有至少一个颜色原本就只有两个，增加的也是同理，可以直接调整过去。

于是综合下来，不难发现只有以下四种情况：

- 增加一个已有颜色。
- 减少一个已有（$\ge 3$）颜色，增加一对原先没有的。
- 减去一个选了且只选了 $3$ 个的颜色，增加两对原先没有的。
- 减去一个选了且只选了 $2$ 个的颜色，新增 $3$ 个某种没选的颜色。

用若干个堆或者 `set` 维护一下即可。复杂度 $O(n\log n)$。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(i64 i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(i64 i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<i64,i64>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
i64 read(){
    i64 x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const i64 N=2e5+5,inf=1e18;
i64 n,m,ans[N],pl[N];
vector<i64> vec[N];
set<pii> s02,s03,s2,s3,sdl,sad;
void add(i64 u){
    if(pl[u]==0){
        if(vec[u].size()>=2) s02.insert(mkp(vec[u][0]+vec[u][1],u));
        if(vec[u].size()>=3) s03.insert(mkp(vec[u][0]+vec[u][1]+vec[u][2],u));        
    }else{
        if(pl[u]>2) sdl.insert(mkp(vec[u][pl[u]-1],u));
        if(2<=pl[u]&&pl[u]<=vec[u].size()-1) sad.insert(mkp(vec[u][pl[u]],u));
        if(pl[u]==2) s2.insert(mkp(vec[u][0]+vec[u][1],u));
        if(pl[u]==3) s3.insert(mkp(vec[u][0]+vec[u][1]+vec[u][2],u));        
    }
}
void del(i64 u){
    if(pl[u]==0){
        if(vec[u].size()>=2) s02.erase(mkp(vec[u][0]+vec[u][1],u));
        if(vec[u].size()>=3) s03.erase(mkp(vec[u][0]+vec[u][1]+vec[u][2],u));        
    }else{
        if(pl[u]>2) sdl.erase(mkp(vec[u][pl[u]-1],u));
        if(2<=pl[u]&&pl[u]<=vec[u].size()-1) sad.erase(mkp(vec[u][pl[u]],u));
        if(pl[u]==2) s2.erase(mkp(vec[u][0]+vec[u][1],u));
        if(pl[u]==3) s3.erase(mkp(vec[u][0]+vec[u][1]+vec[u][2],u));        
    }
}
signed main(){
    n=read();m=read();
    forup(i,1,n){
        i64 c=read(),v=read();
        vec[c].push_back(v);
    }
    bool flag=true;
    forup(i,1,m){
        sort(vec[i].begin(),vec[i].end(),greater<i64>());
        add(i);
        if(vec[i].size()>2) flag=false;
    }
    if(flag){
        vector<i64> seq;
        forup(i,1,m){
            if(vec[i].size()==2){
                seq.push_back(vec[i][0]+vec[i][1]);
            }
        }
        sort(seq.begin(),seq.end(),greater<i64>());
        i64 sum=0;
        forup(i,1,n){
            if(i&1){
                puts("-1");
            }else{
                sum+=seq[i/2-1];
                printf("%lld\n",sum);
            }
        }
        return 0;
    }
    ans[1]=-1;
    ans[2]=prev(s02.end())->fi;
    i64 u=prev(s02.end())->se;
    del(u);
    pl[u]=2;
    add(u);
    forup(i,3,n){
        ans[i]=ans[i-1];
        i64 val0=-inf,val1=-inf,val2=-inf,val3=-inf;
        if(sad.size()) val0=prev(sad.end())->fi;
        if(s2.size()&&s03.size()) val1=(prev(s03.end())->fi)-(s2.begin()->fi);
        if(s02.size()>1&&s3.size()) val2=(prev(s02.end())->fi)+(prev(prev(s02.end()))->fi)-(s3.begin()->fi);
        if(s02.size()&&sdl.size()) val3=(prev(s02.end())->fi)-(sdl.begin()->fi);
        if(val0>=val1&&val0>=val2&&val0>=val3){
            ans[i]+=val0;
            i64 u=prev(sad.end())->se;
            del(u);
            ++pl[u];
            add(u);
        }else if(val1>=val2&&val1>=val3){
            ans[i]+=val1;
            i64 u=(prev(s03.end()))->se,v=s2.begin()->se;
            del(u);del(v);
            pl[v]=0;pl[u]=3;
            add(u);add(v);
        }else if(val2>=val3){
            ans[i]+=val2;
            i64 a=prev(s02.end())->se,b=prev(prev(s02.end()))->se,c=s3.begin()->se;
            del(a);del(b);del(c);
            pl[a]=pl[b]=2;pl[c]=0;
            add(a);add(b);add(c);
        }else{
            ans[i]+=val3;
            i64 u=prev(s02.end())->se,v=sdl.begin()->se;
            del(u);del(v);
            pl[u]=2;--pl[v];
            add(u);add(v);
        }
    }
    forup(i,1,n){
        printf("%lld\n",ans[i]);
    }
}
```

///

## 模拟赛神秘题目 【1116 B组】C 异或

> 题意

- 有一个集合 $S$，所有数在 $[0,2^n)$ 之间，满足 $\forall a,b\in S$ 有 $a\oplus b\in S$，其中 $\oplus$ 表示按位异或，下同。
- 现在给定 $m$ 个限制，形如“集合中第 $x$ 小的数是 $y$”（题目要求最小的数是第 $1$ 小），求合法的集合数。
- $1\le n\le 120,1\le m\le 10^5,0\le x,y < 2^n$

> 题解

妙妙题。

考虑这个集合相当于是一个张成空间，而张成空间第 $i$ 小有经典套路。

具体来说，我们求出该线性空间的线性基，对线性基消元成为行最简型矩阵，得到 $p$ 个代表元。然后第 $k$ 小（注意到题设中若 $S$ 非空最小的数必定是 $0$，我们认为 $0$ 是第 $0$ 小的，即对题目给的 $x$ 全部 $-1$）就是 $k$ 二进制中 $1$ 的位置上的代表元异或起来，证明考虑按位贪心。

那么不难发现，假设第 $x_1$ 小的数为 $y_1$，第 $x_2$ 小的数为 $y_2$，则第 $x_1\oplus x_2$ 小的数为 $y_1\oplus y_2$（注意这里往后的 $x$ 都是题目给的 $x-1$）。

于是我们对 $x$ 维护线性基，同时额外维护每一个代表元对应的 $y$，若 $x$ 与之前的代表元已经线性相关，那么对应的 $y'$ 异或起来必定等于 $x$，否则无解，具体实现考虑插入时同时对 $x,y$ 进行异或，大概这样：

/// details | 参考代码
    open: False
    type: note

```cpp
i128 a[130],b[130];
bool insert(i128 x,i128 y){
    fordown(i,n-1,0){
        if((x>>i)&1){
            if(a[i]){
                x^=a[i];y^=b[i];
                if(!x) break;
            }else{
                a[i]=x;b[i]=y;
                return true;
            }
        }
    }
    return y==0;
}
```

///

这个函数返回 $\mathrm{false}$ 就说明无解。

然后我们就能求出 $O(n)$ 个有用的限制了（即只保留这个线性基求出的代表元）。每个限制形如“线性基 $x$ 中 $1$ 位置的代表元异或起来等于 $y$”，并且要求该线性基是行最简的。

考虑从小到大确定线性基中第 $i$ 小的代表元，若存在一个 $x$ 最高位是 $i$，不难发现该代表元是唯一确定的，因为我们需要 $x$ 中 $1$ 的位置异或起来是 $y$，而其余的 $1$ 全都被确定了（注意是从小到大确定的），想要得到 $y$ 这个代表元就只有一种填法。并且第 $i$ 位代表元的位数已经被确定了。

但是有一些问题，因为我们要求线性基行最简，那么若第 $p$ 位存在一个代表元，则这一列就只有 $p$ 可以是 $1$。放到题目里就是若 $k\in x$（就是说 $x$ 这一位为 $1$），那么若第 $k$ 小的代表元对应位置是 $p$，则 $y$ 的第 $p$ 为必定是 $1$。同理若 $k\notin x$，则 $y$ 的第 $p$ 位必定是 $0$。

于是我们就又能知道若干个“第 $i$ 小的代表元不能是 $j$”的限制，容易发现在这两个限制后，剩下的位就能随便乱填了。于是设 $dp_{i,j}$ 表示第 $i$ 小的代表元最高位为 $j$ 的方案数，若存在 $x$ 最高位为 $i$ 就只有一种填法，否则转移系数形如 $2^p$。

复杂度 $O(nm+n^3)$。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using i128=__int128;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
i128 read(){
    i128 x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=1e5+5,inf=0x3f3f3f3f,mod=998244353;
int n,m,p2[130],mxb=-1;
i128 a[130],b[130];
bool insert(i128 x,i128 y){
    fordown(i,n-1,0){
        if((x>>i)&1){
            if(a[i]){
                x^=a[i];y^=b[i];
                if(!x) break;
            }else{
                a[i]=x;b[i]=y;
                return true;
            }
        }
    }
    return y==0;
}
int my_log2(i128 a){
    int res=-1;
    while(a){
        a>>=1;++res;
    }
    return res;
}
bool ava[130][130];
void work(){
    forup(i,0,n-1){
        if(a[i]){
            mxb=i;
            int p=my_log2(b[i]);
            ava[i][p]=1;
            forup(j,0,i-1){
                if((a[i]>>j)&1){
                    forup(k,0,p-1){
                        if(!((b[i]>>k)&1)){
                            ava[j][k]=0;
                        }
                    }
                }else{
                    forup(k,0,p-1){
                        if((b[i]>>k)&1){
                            ava[j][k]=0;
                        }
                    }
                }
            }
        }else{
            forup(j,i,n-1){
                ava[i][j]=1;
            }
        }
    }
}
int get(int i,int j){
    return a[i]?1:p2[j-i];
}
int dp[130][130];
signed main(){
    n=read();m=read();
    p2[0]=1;
    forup(i,1,n) p2[i]=2ll*p2[i-1]%mod;
    forup(i,1,m){
        i128 x=read(),y=read();
        --x;
        if(!insert(x,y)){
            puts("0");
            return 0;
        }
    }
    work();
    forup(i,0,n-1) if(ava[0][i]) dp[0][i]=get(0,i);
    forup(i,1,n-1){
        forup(j,i,n-1){
            if(!ava[i][j]) continue;
            int f=get(i,j);
            forup(k,0,j-1){
                (dp[i][j]+=1ll*dp[i-1][k]*f%mod)%=mod;
            }
        }
    }
    int ans=0;
    if(mxb==-1) ans=1,mxb=0;
    forup(i,mxb,n-1){
        forup(j,i,n-1){
            (ans+=dp[i][j])%=mod;
        }
    }
    printf("%d\n",ans);
}
```

///

## [ARC126E] Infinite Operations

[传送门](https://www.luogu.com.cn/problem/AT_arc126_e)

> 题意

- 给定一个长度为 $n$ 的序列 $a$，我们这样计算序列的权值：
    - 选择 $i,j$ 满足 $a_i\ne a_j$，钦定 $a_i < a_j$。
    - 选择一个实数 $x$ 满足 $a_i+x \le a_j-x$，$a_i\gets a_i+x,a_j\gets a_j-x$，并将 $x$ 累加进权值。
    - 进行上述操作直至无法操作为止。
- 设这样能得到的最大权值为 $f(a)$，有 $m$ 次 $a$ 的单点修改，每次修改后输出 $f(a)$，注意计算权值并不会真正改变序列。
- $1\le n,m\le 3\times 10^5,1\le a_i\le 10^9$

> 题解

妙妙题，一开始想简单了，写完了才发现，最后还是看了题解。

钦定 $a$ 是单调不降的，即升序排列。

显然最后所有数都会变成全局平均数 $\bar{a}$。考虑怎样最大化权值。

如果你要从 $a_j$ 向 $a_i$ 扔 $x$，那么最优的必定是每次传给 $j-1$，这样能产生 $x(i-j)$ 的贡献。

那么每个 $i$ 能产生的贡献就是有多少数需要经过它运送，不难发现这个就等于 $\sum_{j=i}^na_i-\bar{a}$，然后随便推一推容易发现，答案就是：

$$
\begin{aligned}
&\sum_{i=1}^ni\cdot a_i-\frac{n(n+1)}{2}\bar{a}\\\\
=&\sum_{i=1}^ni\cdot a_i-\frac{(n+1)}{2}\sum_{i=1}^n a
\end{aligned}
$$

后面的是好算的，前面的就是排名乘值，为了避免重复问题我们需要钦定相同数的排名不同，然后就变成了 $\sum x_iy_i$ 的问题了，其中 $x$ 单点修改，$y$ 区间修改，可以直接线段树维护，复杂度 $O((n+m)\log(n+m))$。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=3e5+5,mod=998244353,inv2=(mod+1)/2;
int ksm(int a,int b){
    int c=1;
    while(b){
        if(b&1) c=1ll*a*c%mod;
        a=1ll*a*a%mod;
        b>>=1;
    }
    return c;
}
int n,m,a[N],nd[N],sum,cnt[N<<1];;
vector<int> lsh;
int sz;
struct opr{
    int x,y;
}s[N];
struct SegTree{
    #define mid ((l+r)>>1)
    #define lson l,mid,id<<1
    #define rson mid+1,r,id<<1|1
    int sum[N<<3],num[N<<3],mark[N<<3];
    void PushUp(int id){
        sum[id]=(sum[id<<1]+sum[id<<1|1])%mod;
        num[id]=(num[id<<1]+num[id<<1|1])%mod;
    }
    void PushDown(int id){
        sum[id<<1]=(sum[id<<1]+1ll*num[id<<1]*mark[id]%mod)%mod;
        sum[id<<1|1]=(sum[id<<1|1]+1ll*num[id<<1|1]*mark[id]%mod)%mod;
        (mark[id<<1]+=mark[id])%=mod;
        (mark[id<<1|1]+=mark[id])%=mod;
        mark[id]=0;
    }
    void Modify(int L,int R,int X,int l=1,int r=n+m,int id=1){
        if(L<=l&&r<=R){
            (mark[id]+=X)%=mod;
            (sum[id]+=1ll*X*num[id]%mod)%=mod;
            return;
        }
        if(mark[id]) PushDown(id);
        if(L<=mid) Modify(L,R,X,lson);
        if(mid< R) Modify(L,R,X,rson);
        PushUp(id);
    }
    void Update(int P,int X,int l=1,int r=n+m,int id=1){
        if(l==r){
            (num[id]+=X)%=mod;
            (sum[id]+=1ll*X*mark[id]%mod)%=mod;
            return;
        }
        if(mark[id]) PushDown(id);
        if(P<=mid) Update(P,X,lson);
        else       Update(P,X,rson);
        PushUp(id);
    }
}mt;
signed main(){
    n=read();m=read();
    forup(i,1,n){
        a[i]=read();
        lsh.push_back(a[i]);
    }
    forup(i,1,m){
        s[i].x=read();s[i].y=read();
        lsh.push_back(s[i].y);
    }
    sort(lsh.begin(),lsh.end());
    lsh.erase(unique(lsh.begin(),lsh.end()),lsh.end());
    sz=lsh.size();
    forup(i,1,n){
        int p=lower_bound(lsh.begin(),lsh.end(),a[i])-lsh.begin()+1;
        (sum+=a[i])%=mod;
        ++cnt[p];
    }
    forup(i,1,m){
        int p=lower_bound(lsh.begin(),lsh.end(),s[i].y)-lsh.begin()+1;
        ++cnt[p];
    }
    forup(i,1,sz) cnt[i]+=cnt[i-1];
    forup(i,1,n){
        int p=lower_bound(lsh.begin(),lsh.end(),a[i])-lsh.begin()+1;
        nd[i]=cnt[p]--;
        mt.Update(nd[i],a[i]);mt.Modify(nd[i],n+m,1);
    }
    forup(i,1,m){
        int x=s[i].x,y=s[i].y;
        mt.Update(nd[x],mod-a[x]);mt.Modify(nd[x],n+m,mod-1);
        sum=(sum+mod-a[x])%mod;
        a[x]=y;
        int p=lower_bound(lsh.begin(),lsh.end(),a[x])-lsh.begin()+1;
        nd[x]=cnt[p]--;
        mt.Update(nd[x],a[x]);mt.Modify(nd[x],n+m,1);
        (sum+=a[x])%=mod;
        int res=mt.sum[1];
        res=(res+mod-1ll*(n+1)*inv2%mod*sum%mod)%mod;
        printf("%d\n",res);
    }
}
```

///