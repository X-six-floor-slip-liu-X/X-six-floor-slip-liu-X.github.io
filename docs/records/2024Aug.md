---
comments: true
---

# 2024 8 月杂题

感觉耍一个暑假耍废了。

## P2839 [国家集训队] middle

[传送门](https://www.luogu.com.cn/problem/P2839)

> 题意

- 给定一个序列 $s$。
- $q$ 次询问，每次询问给你四个值 $a,b,c,d$，查询左端点在 $[a,b]$ 内，右端点在 $[c,d]$ 内的字串中，中位数最大值。
- 此处大小的偶数的可重集中中位数取较大的那个。
- $1\le n\le 2\times 10^4,1\le q\le 25000$，强制在线。

> 题解

哎哟傻逼题调了一晚上。

容易想到二分答案，那么先考虑如何判断固定区间中位数能否大于 $x$？即大于等于 $x$ 的数的个数减去小于 $x$ 的数的个数大于等于 $0$。换句话说，对于固定的 $x$，将大于等于它的赋值为 $1$，小于的赋值为 $-1$，区间和大于等于 $0$。

对于原问题，容易发现就是 $[b,c]$ 的总和加上 $[a,b-1]$ 的最大后缀和 $[c+1,d]$ 的最大前缀。

这个可以（离散化后）对每个值开线段树维护（可持久化即可），也可以分块。

那么如何分块呢？设块长为 $B$，容易发现对于每一块只有 $B+1$ 种不同的情况，那么分别扫一遍预处理，复杂度 $O(B^2\frac{n}{B})$。

然后二分后 check 可以简单地做到 $O(\frac{n}{B}+B)$。

于是复杂度 $O(n\sqrt{n}+q\sqrt{n}\log n)$，调一调块长说不定能得到更好的复杂度，但是我懒得搞了，反正数据范围那么小。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(i64 i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(i64 i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
#define gc getchar()
i64 read(){
	i64 x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const i64 N=2e4+5;
const i64 B=150;
i64 n,m,a[N],lans;
vector<i64> lsh;
i64 L[155],R[155],blg[N];
i64 sum[155][N],smx[155][N],pmx[155][N];
bool chk(i64 l1,i64 r1,i64 l2,i64 r2,i64 val){
	i64 mx1=0,mx2=0,ss=0;
	if(blg[r1]+1<blg[l2]){
		forup(i,blg[r1]+1,blg[l2]-1){
			ss+=sum[i][val];
		}
		forup(i,r1,R[blg[r1]]){
			ss+=(a[i]>=val?1:-1);
		}
		forup(i,L[blg[l2]],l2){
			ss+=(a[i]>=val?1:-1);
		}
	}else{
		forup(i,r1,l2){
			ss+=(a[i]>=val?1:-1);
		}
	}
	--r1,++l2;
	i64 nw=0;
	if(blg[l1]+1<blg[r1]){
		fordown(i,r1,L[blg[r1]]){
			nw+=(a[i]>=val?1:-1);
			mx1=max(mx1,nw);
		}
		fordown(i,blg[r1]-1,blg[l1]+1){
			mx1=max(mx1,nw+smx[i][val]);
			nw+=sum[i][val];
		}
		fordown(i,R[blg[l1]],l1){
			nw+=(a[i]>=val?1:-1);
			mx1=max(mx1,nw);
		}		
	}else{
		fordown(i,r1,l1){
			nw+=(a[i]>=val?1:-1);
			mx1=max(mx1,nw);
		}
	}
	nw=0;
	if(blg[l2]+1<blg[r2]){
		forup(i,l2,R[blg[l2]]){
			nw+=(a[i]>=val?1:-1);
			mx2=max(mx2,nw);
		}
		forup(i,blg[l2]+1,blg[r2]-1){
			mx2=max(mx2,nw+pmx[i][val]);
			nw+=sum[i][val];
		}
		forup(i,L[blg[r2]],r2){
			nw+=(a[i]>=val?1:-1);
			mx2=max(mx2,nw);
		}
	}else{
		forup(i,l2,r2){
			nw+=(a[i]>=val?1:-1);
			mx2=max(mx2,nw);
		}
	}
	return ss+mx1+mx2>=0;
}
signed main(){
	n=read();
	forup(i,1,n){
		a[i]=read();
		lsh.push_back(a[i]);
	}
	sort(lsh.begin(),lsh.end());
	lsh.erase(unique(lsh.begin(),lsh.end()),lsh.end());
	forup(i,1,n){
		a[i]=lower_bound(lsh.begin(),lsh.end(),a[i])-lsh.begin();
	}
	i64 T=n/B;
	forup(i,1,T){
		L[i]=R[i-1]+1,R[i]=i*B;
		forup(j,L[i],R[i]){
			blg[j]=i;
		}
	}
	if(R[T]!=n){
		++T;
		L[T]=R[T-1]+1;R[T]=n;
		forup(j,L[T],R[T]){
			blg[j]=T;
		}
	}
	forup(i,1,T){
		forup(j,0,n){
			smx[i][j]=pmx[i][j]=sum[i][j]=-(R[i]-L[i]+1);
		}
		forup(j,L[i],R[i]){
			i64 x=a[j];
			i64 mmx=0,nw=0;
			fordown(k,R[i],L[i]){
				nw+=(a[k]>=x?1:-1);
				mmx=max(mmx,nw);
			}
			smx[i][x]=mmx;
			mmx=0,nw=0;
			forup(k,L[i],R[i]){
				nw+=(a[k]>=x?1:-1);
				mmx=max(mmx,nw);
			}
			pmx[i][x]=mmx;
			sum[i][x]=nw;
		}
		fordown(j,n-1,0){
			smx[i][j]=max(smx[i][j+1],smx[i][j]);
			pmx[i][j]=max(pmx[i][j+1],pmx[i][j]);
			sum[i][j]=max(sum[i][j+1],sum[i][j]);
		}
	}
	m=read();
	forup(i,1,m){
		vector<i64> q;
		forup(j,1,4){
			i64 p=read();
			q.push_back((p+lans)%n+1);
		}
		sort(q.begin(),q.end());
		i64 l1=q[0],r1=q[1],l2=q[2],r2=q[3];
		i64 ll=0,rr=n,mm;
		while(ll<rr){
			mm=(ll+rr+1)>>1;
			if(chk(l1,r1,l2,r2,mm)) ll=mm;
			else rr=mm-1;
		}
		lans=lsh[ll];
		printf("%lld\n",lans);
	}
}
```

///

## UOJ#164 V

[传送门](https://vjudge.net.cn/problem/UniversalOJ-164)

> 题意

- 初始给定长度为 $n$ 的序列 $a_i$，维护五个操作共 $q$ 次：
    - 区间 $[l,r]$ 赋值为 $a_i+x\;(x\ge 0)$。
    - 区间 $[l,r]$ 赋值为 $\max(0,a[i]-x)\;(x<0)$。
    - 区间 $[l,r]$ 赋值为 $x\;(x\ge 0)$。
    - 查询单点值。
    - 查询单点历史最值。
- $1\le n,q\le 5\times 10^5$，所有输入的数在 $10^9$ 以内。

> 题解

还是比较有启发性吧。

考虑三个操作都能概括为 $a_i\gets \max(a_i+v,b)$，于是用 $(v,b)$ 二元组表示一个操作。

考虑两操作 $(v_1,b_1),(v_2,b_2)$ 的复合，容易发现 $\max(\max(a_i+v_1,b_1)+v_2,b_2)=\max(a_i+v_1+v_2,\max(b_1+v_2,b_2))$，显然这玩意有结合律，所以可以直接扔到线段树上维护懒标记。

那么单点查值是简单的，然后查历史最值由于查询和操作都是 $\max$，所以直接分别维护 $v,b$ 的最大值即可在叶子处得到答案。

复杂度 $O(n\log n)$。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(i64 i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(i64 i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<i64,i64>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
i64 read(){
	i64 x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const i64 N=5e5+5,inf=1e18;
i64 n,a[N],m;
struct SegTree{
	#define mid ((l+r)>>1)
	#define lson l,mid,id<<1
	#define rson mid+1,r,id<<1|1
	pii tag[N<<2],htag[N<<2];
	void work(i64 id,pii val,pii hval){
		htag[id].fi=max(htag[id].fi,tag[id].fi+hval.fi);
		htag[id].se=max(htag[id].se,max(hval.se,tag[id].se+hval.fi));
		tag[id].fi=max(-inf,tag[id].fi+val.fi);
		tag[id].se=max(tag[id].se+val.fi,val.se);
	}
	void PushDown(i64 id){
		work(id<<1,tag[id],htag[id]);
		work(id<<1|1,tag[id],htag[id]);
		tag[id]=htag[id]=mkp(0,0);
	}
	void Build(i64 l=1,i64 r=n,i64 id=1){
		tag[id]=htag[id]=mkp(0,0);
		if(l==r) return;
		Build(lson);Build(rson);
	}
	void Update(i64 L,i64 R,pii X,i64 l=1,i64 r=n,i64 id=1){
		if(L<=l&&r<=R){
			work(id,X,X);
			return;
		}
		PushDown(id);
		if(L<=mid) Update(L,R,X,lson);
		if(mid< R) Update(L,R,X,rson);
	}
	pii Query(i64 P,i64 l=1,i64 r=n,i64 id=1){
		if(l==r){
			return mkp(max(a[l]+tag[id].fi,tag[id].se),max(a[l]+htag[id].fi,htag[id].se));
		}
		PushDown(id);
		if(P<=mid) return Query(P,lson);
		else       return Query(P,rson);
	}
}mt;
signed main(){
	n=read();
	m=read();
	forup(i,1,n){
		a[i]=read();
	}
	mt.Build();
	forup(i,1,m){
		i64 op=read();
		if(op==1){
			i64 l=read(),r=read(),v=read();
			mt.Update(l,r,mkp(v,0));
		}else if(op==2){
			i64 l=read(),r=read(),v=read();
			mt.Update(l,r,mkp(-v,0));
		}else if(op==3){
			i64 l=read(),r=read(),v=read();
			mt.Update(l,r,mkp(-inf,v));
		}else if(op==4){
			i64 p=read();
			printf("%lld\n",mt.Query(p).fi);
		}else{
			i64 p=read();
			printf("%lld\n",mt.Query(p).se);
		}
	}
}
```

///

## LOJ#6029 「雅礼集训 2017 Day1」市场

[传送门](https://loj.ac/p/6029)

> 题意

- 给定义一个长度为 $n$ 的序列 $a$，维护四个操作共 $q$ 次：
    - 区间加 $c\;(|c|\le 10^4)$.
    - 区间除以 $d$ 向下取整 $(2\le d\le 10^9)$。
    - 区间询问最小值。
    - 区间询问总和。
- $1\le n,q\le 10^5$，注意这道题下标从 $0$ 开始。

> 题解

神秘。

首先看到维护除法容易想到势能分析线段树，但是有区间加，怎么办。

因为有区间加，所以考虑对区间内数的相对大小做文章。

设 $f(x,d)=x-\left\lfloor\frac{x}{d}\right\rfloor$，容易发现对于一个区间，若 $f(mx,d)=f(mn,d)$（其中 $mx$ 是区间最大值，$mn$ 是区间最小值），那么操作二相当与区间减去 $f(mx,d)$。若不是就向下递归。

容易发现 $f(mx,d)=f(mn,d)$ 当且仅当 $mx=mn$ 或两者恰好在以 $d$ 的倍数分块的两块交界（即最大值和最小值的差比较小时），而区间加显然不会影响区间内最大值和最小值的差，那么它只会影响 $O(\log)$ 个区间，每个区间显然至多操作 $O(\log)$ 次这玩意就等于 $0$ 了，于是复杂度 $O(n\log^2 n)$（$q,n$ 同阶就不管了）。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(i64 i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(i64 i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
#define gc getchar()
i64 read(){
	i64 x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const i64 N=1e5+5,inf=0x3f3f3f3f;
i64 n,m,a[N];
i64 calcdel(i64 x,i64 d){
	if(x>=0){
		return x-(x/d);
	}else{
		x=-x;
		return ((x+d-1)/d)-x;
	}
} 
struct SegTree{
	#define mid ((l+r)>>1)
	#define lson l,mid,id<<1
	#define rson mid+1,r,id<<1|1
	i64 mx[N<<2],mn[N<<2],sum[N<<2],mark[N<<2];
	void PushUp(i64 id){
		mx[id]=max(mx[id<<1],mx[id<<1|1]);
		mn[id]=min(mn[id<<1],mn[id<<1|1]);
		sum[id]=sum[id<<1]+sum[id<<1|1];
	}
	void work(i64 id,i64 val,i64 len){
		mx[id]+=val;
		mn[id]+=val;
		mark[id]+=val;
		sum[id]+=val*len;
	}
	void PushDown(i64 id,i64 l,i64 r){
		work(id<<1,mark[id],mid-l+1);
		work(id<<1|1,mark[id],r-mid);
		mark[id]=0;
	}
	void Build(i64 l=1,i64 r=n,i64 id=1){
		mark[id]=0;
		if(l==r){
			sum[id]=mx[id]=mn[id]=a[l];
			return;
		}
		Build(lson);Build(rson);
		PushUp(id);
	}
	void Update(i64 L,i64 R,i64 X,i64 l=1,i64 r=n,i64 id=1){
		if(L<=l&&r<=R){
			work(id,X,r-l+1);
			return;
		}
		if(mark[id]) PushDown(id,l,r);
		if(L<=mid) Update(L,R,X,lson);
		if(mid< R) Update(L,R,X,rson);
		PushUp(id);
	}
	void Modify(i64 L,i64 R,i64 D,i64 l=1,i64 r=n,i64 id=1){
		if(L<=l&&r<=R&&calcdel(mx[id],D)==calcdel(mn[id],D)){
			work(id,-calcdel(mx[id],D),r-l+1);
			return;
		}
		if(mark[id]) PushDown(id,l,r);
		if(L<=mid) Modify(L,R,D,lson);
		if(mid< R) Modify(L,R,D,rson);
		PushUp(id);
	}
	i64 Querymn(i64 L,i64 R,i64 l=1,i64 r=n,i64 id=1){
		if(L<=l&&r<=R){
			return mn[id];
		}
		i64 res=inf;
		if(mark[id]) PushDown(id,l,r);
		if(L<=mid) res=min(res,Querymn(L,R,lson));
		if(mid< R) res=min(res,Querymn(L,R,rson));
		return res;
	}
	i64 Querysum(i64 L,i64 R,i64 l=1,i64 r=n,i64 id=1){
		if(L<=l&&r<=R){
			return sum[id];
		}
		i64 res=0;
		if(mark[id]) PushDown(id,l,r);
		if(L<=mid) res+=Querysum(L,R,lson);
		if(mid< R) res+=Querysum(L,R,rson);
		return res;
	}
}mt;
signed main(){
	n=read();m=read();
	forup(i,1,n){
		a[i]=read();
	}
	mt.Build();
	forup(i,1,m){
		i64 op=read(),l=read()+1,r=read()+1;
		if(op==1){
			i64 v=read();
			mt.Update(l,r,v);
		}else if(op==2){
			i64 d=read();
			mt.Modify(l,r,d);
		}else if(op==3){
			printf("%lld\n",mt.Querymn(l,r));
		}else{
			printf("%lld\n",mt.Querysum(l,r));
		}
	}
}
```

///

## P5618 [SDOI2015] 道路修建

[传送门](https://www.luogu.com.cn/problem/P5618)

这么版的题怎么都没人写 DDP（动态动态规划）做法啊。

> 题意

- 有一个两行 $n$ 列的网格图，四联通连边，每条边有边权。
- 有两个操作共 $q$ 次：
    - 修改某条边的边权。
    - 查询区间 $[l,r]$ 内两行共 $2(r-l+1)$ 个点的最小生成树。
- $1\le n,q\le 60000$，边权不超过 $10^4$

> 题解

晚自习 20min 切了，但是唐诗错误 WA 一发，但是洛谷最优解。

考虑静态问题（即没有修改，只有一次全局查询），容易想到 DP（因为只能相邻连边，所以这一列想和之前的连边必须和上一列连，那么可以对每一列设状态，从上一列转移）。

具体来说，设 $dp_{i,0/1}$ 表示考虑前 $i$ 列，第 $i$ 列两个点是否已经联通的最小代价。

转移很显然，具体如下（$d1$ 表示这一列第一行与上一列连边的边权，$d2$ 表示第二行，$d3$ 表示这一类的纵向连边）：

$$
dp_{i,0}=\min(dp_{i-1,1}+\min(d1,d2),dp_{i-1,0}+d1+d2)
$$
$$
dp_{i,1}=\min(dp_{i-1,1}+\min(d1+d2,d1+d3,d2+d3),dp_{i-1,0}+d1+d2+d3)
$$

初始状态为 $dp_{1,0}=0,dp_{1,1}=d3$。

然后用 $\min,+$ 的广义矩阵扔到线段树上维护一下就做完了。

具体来说，一般矩阵乘法（$A\times B=C$，此处以 $2\times 2$ 矩阵为例）的定义是 $C_{i,j}=\sum_{k=0}^1A_{i,k}\times B_{k,j}$，$\oplus,\otimes$（这代指两种运算）的广义矩阵乘法定义是 $C_{i,j}=\bigoplus A_{i,k}\otimes B_{k,j}$，容易证明只要 $\oplus$ 有交换律，$\otimes$ 有结合律和交换律，$\otimes$ 对 $\oplus$ 有分配率即可得到有结合律的矩阵乘法，具体证明考虑将 $(A\times B)\times C$ 和 $A\times(B\times C)$ 分别暴力拆开，此处略过。

然后容易发现用 $\min$ 代替 $\oplus$，用加法代替 $\otimes$ 即可完美地概括此题的 DP 转移，具体矩阵请自行构造，转移已给出。

复杂度 $O(n\log nk^3)$，其中 $k=2$，为矩阵边长。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
#define gc getchar()
int read(){
	int x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const int N=6e4+5,inf=0x3f3f3f3f;
struct Matrix{
	int c[2][2];
	Matrix(int a1=0,int a2=0,int a3=0,int a4=0){
		c[0][0]=a1;
		c[0][1]=a2;
		c[1][0]=a3;
		c[1][1]=a4;
	}
	Matrix operator *(const Matrix &r){//广义矩阵乘法
		Matrix res;
		forup(i,0,1){
			forup(j,0,1){
				res.c[i][j]=inf;
				forup(k,0,1){
					res.c[i][j]=min(res.c[i][j],c[i][k]+r.c[k][j]);
				}
			}
		}
		return res;
	}
};
int n,m,d1[N],d2[N],d3[N];
Matrix tr(int l){//转移矩阵
	return Matrix(d1[l]+d2[l],d1[l]+d2[l]+d3[l],min(d1[l],d2[l]),min({d1[l]+d2[l],d1[l]+d3[l],d2[l]+d3[l]}));
}
struct SegTree{//线段树维护区间矩阵广义积
	#define mid ((l+r)>>1)
	#define lson l,mid,id<<1
	#define rson mid+1,r,id<<1|1
	Matrix mat[N<<2];
	void PushUp(int id){
		mat[id]=mat[id<<1]*mat[id<<1|1];
	}
	void Build(int l=1,int r=n,int id=1){//初始化
		if(l==r){
			mat[id]=tr(l);
			return;
		}
		Build(lson);Build(rson);
		PushUp(id);
	}
	void Update(int P,int l=1,int r=n,int id=1){//单点修改
		if(l==r){
			mat[id]=tr(l);
			return;
		}
		if(P<=mid) Update(P,lson);
		else       Update(P,rson);
		PushUp(id);
	}
	Matrix Query(int L,int R,int l=1,int r=n,int id=1){//区间查询
		if(L<=l&&r<=R){
			return mat[id];
		}
		Matrix res(0,inf,inf,0);
		if(L<=mid) res=res*Query(L,R,lson);
		if(mid< R) res=res*Query(L,R,rson);
		return res;
	}
}mt;
char str[5];
signed main(){
	n=read();m=read();
	forup(i,2,n) d1[i]=read();
	forup(i,2,n) d2[i]=read();
	forup(i,1,n) d3[i]=read();
	mt.Build();//记得初始化
	forup(i,1,m){
		scanf(" %s",str);
		if(str[0]=='C'){
			int x1=read(),y1=read(),x2=read(),y2=read(),w=read();
			if(x1>x2) swap(x1,x2);
			if(y1>y2) swap(y1,y2);
			if(x1==1){
				if(x2==1){
					d1[y2]=w;
				}else{
					d3[y2]=w;
				}
			}else{
				d2[y2]=w;
			}
			mt.Update(y2);
		}else{
			int l=read(),r=read();
			Matrix res=mt.Query(l+1,r);
			res=Matrix(0,d3[l],-inf,-inf)*res;
			printf("%d\n",res.c[0][1]);//最后答案显然必须连通。
		}
	}
}
```

///

## [ABC236G] Good Vertices

[传送门](https://www.luogu.com.cn/problem/AT_abc236_g)

> 题意

- 有一张 $n$ 个点的有向图，初始没有边。
- 有 $t$ 次加边操作，每次加入一条有向边，可能有自环。
- 求每个点从哪次操作开始存在一条从 $1$ 开始**恰好**经过 $l$ 条边的路径到达它。
- $1\le n\le 100,1\le t\le n^2,1\le L\le 10^9$。

> 题解

广义矩阵快速幂加速递推好题。

容易想到一个 DP，设 $f_{i,j}$ 表示从 $1$ 开始经过恰好 $i$ 条边到达 $j$ 的路径上边权（即加入时间，一直没加入即为正无穷）最大值最小是多少，转移就枚举每一条边即可从 $f_{i,u}$ 转移到 $f_{i+1,v}$。

转移式子为 $f_{i+1,v}= \min_{u=1}^n\left\{\max(f_{i,u},w(u,v))\right\}$，其中 $w(u,v)$ 为 $u,v$ 间的边权。

这个长的就很像矩阵乘法的 $C_{i,j}=\bigoplus A_{i,k}\otimes B_{k,j}$，那么能不能设计广义矩阵乘法呢？

然后瞪一下容易发现 $\min$ 对 $\max$ 有分配律（显然 $\min(\max(a,b),\max(a,c))=\max(a,\min(b,c))$，分类讨论即可），其它需要的运算律都是经典的。

然后这个转移就能用矩阵概括了，复杂度 $O(n^3\log L)$。

注意在 $\min,\max$ 意义下的单位矩阵和全 $0$ 矩阵长什么样。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
	int x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const int N=105,inf=0x3f3f3f3f;
int n,t,m;
struct Matrix{
	int c[N][N];
	Matrix operator *(const Matrix &r){
		Matrix res;
		forup(i,0,n-1){
			forup(j,0,n-1){
				res.c[i][j]=inf;
				forup(k,0,n-1){
					res.c[i][j]=min(res.c[i][j],max(c[i][k],r.c[k][j]));
				}
			}
		}
		return res;
	}
}tr;
Matrix ksm(Matrix a,int b){
	Matrix c;
	forup(i,0,n-1){
		forup(j,0,n-1){
			c.c[i][j]=inf;
		}
	}
	forup(i,0,n-1){
		c.c[i][i]=-inf;
	}
	while(b){
		if(b&1) c=c*a;
		a=a*a;
		b>>=1;
	}
	return c;
}
signed main(){
	n=read();t=read();m=read();
	forup(i,0,n-1){
		forup(j,0,n-1){
			tr.c[i][j]=inf;
		}
	}
	forup(i,1,t){
		int u=read()-1,v=read()-1;
		tr.c[u][v]=i;
	}
	Matrix res=ksm(tr,m);
	forup(i,0,n-1){
		if(res.c[0][i]!=inf){
			printf("%d ",res.c[0][i]);
		}else{
			printf("-1 ");
		}
	}
}
```

///

## P5298 [PKUWC2018] Minimax

[传送门](https://www.luogu.com.cn/problem/P5298)

唉，我是线段树合并低手。

> 题意

- 有一颗以 $1$ 为根的树，最初只有叶子有值 $w_u$，非叶子结点均有一个概率 $p$，表示该结点的权值有 $p$ 的概率是儿子中的最大值，$1-p$ 的概率是最小值。
- 因为 $0 < p < 1$，所以显然根节点有可能取到所有叶子，设根节点的权值是第 $i$ 小的叶子的概率为 $D_i$，第 $i$ 小的叶子权值为 $V_i$，输出 $\sum i\times V_i\times D_i^2$。
- $1\le n\le 3\times 10^5,w_u\in[1,10^9],p\in(0,1)$，**每个结点至多有两个儿子**，叶子权值互不相同。

> 题解

首先可以对权值离散化方便处理。

因为每个点只和自己的直接儿子有关，容易想到树形 DP。

设 $f_{u,i}$ 表示点 $u$ 的权值取到 $i$ 的概率，当 $u$ 只有一个儿子显然可以直接继承，若 $u$ 有两个儿子情况则略有变化。

设两个儿子分别是 $l,r$，不妨设 $u$ 的权值从 $l$ 继承过来（$r$ 是一样的），那么假如是取“最小值”取到 $l$，则有 $w_r>w_l$，那么 $w_u=x$ 的概率就是 $(1-p)f_{l,x}\sum_{i=x+1}^nf_{r,i}$，同理若取最大值取到 $l$ 则有 $pf_{l,x}\sum_{i=1}^{x-1}f_{r,i}$.

综上，$f_{u,i}=(f_{l,i}\times ((1-p)\sum_{i=x+1}^nf_{r,i}+p\sum_{i=1}^{x-1}f_{r,i}))+(f_{r,i}\times ((1-p)\sum_{i=x+1}^nf_{l,i}+p\sum_{i=1}^{x-1}f_{l,i}))$。

容易发现转移都是单点乘前后缀和，于是可以线段树合并优化（注意只有一边有值时会变成一个区间乘，打乘法 tag 即可），复杂度 $O(n\log n)$。

注意最后还原离散化的细节问题。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
	int x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const int N=3e5+5,inf=0x3f3f3f3f,mod=998244353;
int ksm(int a,int b){
	int c=1;
	while(b){
		if(b&1) c=1ll*a*c%mod;
		a=1ll*a*a%mod;
		b>>=1;
	}
	return c;
}
int n,inv,sz;
vector<int> e[N];
int val[N];
vector<int> lsh;
struct SegTree{
	#define mid ((l+r)>>1)
	#define lson l,mid,ls[u]
	#define rson mid+1,r,rs[u]
	int sum[N*20],ls[N*20],rs[N*20],tag[N*20],cntn,root[N];
	void PushUp(int u){
		sum[u]=0;
		if(ls[u]) (sum[u]+=sum[ls[u]])%=mod;
		if(rs[u]) (sum[u]+=sum[rs[u]])%=mod;
	}
	void PushDown(int u){
		if(ls[u]){
			sum[ls[u]]=1ll*sum[ls[u]]*tag[u]%mod;
			tag[ls[u]]=1ll*tag[ls[u]]*tag[u]%mod;
		}
		if(rs[u]){
			sum[rs[u]]=1ll*sum[rs[u]]*tag[u]%mod;
			tag[rs[u]]=1ll*tag[rs[u]]*tag[u]%mod;
		}
		tag[u]=1;
	}
	int New(){
		int nw=++cntn;
		ls[nw]=rs[nw]=sum[nw]=0;
		tag[nw]=1;
		return nw;
	}
	void Update(int P,int l,int r,int &u){
		if(!u) u=New();
		if(l==r){
			sum[u]=1;
			return;
		}
		if(P<=mid) Update(P,lson);
		else       Update(P,rson);
		PushUp(u);
	}
	int Merge(int valu,int valv,int p,int l,int r,int u,int v){
		if(!u||!v){
			if(!v){
				tag[u]=1ll*tag[u]*valv%mod;
				sum[u]=1ll*sum[u]*valv%mod;
				return u;
			}else{
				tag[v]=1ll*tag[v]*valu%mod;
				sum[v]=1ll*sum[v]*valu%mod;
				return v;
			}
		}
		if(tag[u]!=1) PushDown(u);
		if(tag[v]!=1) PushDown(v);
		int nvalu=(valu+mod-1ll*sum[ls[u]]*(mod+1-p)%mod+1ll*sum[ls[u]]*p%mod)%mod;
		if(!ls[u]) nvalu=valu;
		int nvalv=(valv+mod-1ll*sum[ls[v]]*(mod+1-p)%mod+1ll*sum[ls[v]]*p%mod)%mod;
		if(!ls[v]) nvalv=valv;
		ls[u]=Merge(valu,valv,p,lson,ls[v]);
		rs[u]=Merge(nvalu,nvalv,p,rson,rs[v]);
		PushUp(u);
		return u;
	}
	int Get(int l,int r,int u){
		if(!u) return 0;
		if(l==r){
			return 1ll*(l+1)*lsh[l]%mod*sum[u]%mod*sum[u]%mod;
		}
		if(tag[u]!=1) PushDown(u);
		int res=0;
		(res+=Get(lson))%=mod;
		(res+=Get(rson))%=mod;
		return res;
	}
	#undef mid
	#undef lson
	#undef rson
}mt;
void dfs(int u){
	if(e[u].empty()) return;
	if(e[u].size()==1){
		dfs(e[u][0]);
		mt.root[u]=mt.root[e[u][0]];
	}else{
		dfs(e[u][0]);dfs(e[u][1]);
		int np=val[u],rp=(mod+1-np)%mod;
		mt.root[u]=mt.Merge(1ll*mt.sum[mt.root[e[u][0]]]*rp%mod,1ll*mt.sum[mt.root[e[u][1]]]*rp%mod,np,0,sz-1,mt.root[e[u][0]],mt.root[e[u][1]]);
	}
}
signed main(){
	n=read();
	forup(i,1,n){
		int f=read();
		if(i>1){
			e[f].push_back(i);
		}
	}
	inv=ksm(10000,mod-2);
	forup(i,1,n){
		val[i]=read();
		if(e[i].size()){
			val[i]=1ll*val[i]*inv%mod;
		}else{
			lsh.push_back(val[i]);
		}
	}
	sort(lsh.begin(),lsh.end());
	lsh.erase(unique(lsh.begin(),lsh.end()),lsh.end());
	sz=lsh.size();
	forup(i,1,n){
		if(e[i].empty()){
			val[i]=lower_bound(lsh.begin(),lsh.end(),val[i])-lsh.begin();
			mt.Update(val[i],0,sz-1,mt.root[i]);
		}
	}
	dfs(1);
	printf("%d\n",mt.Get(0,sz-1,mt.root[1]));
}
```

///

## P3899 [湖南集训] 更为厉害

[传送门](https://www.luogu.com.cn/problem/P3899)

> 题意

- 给定一棵 $n$ 个点，以 $1$ 为根的树。
- 称一个有序三元组 $(a,b,c)$ 是“$k$ 合法的”当且仅当 $a,b,c$ 互不相同，且 $a,b$ 之间距离小于等于 $k$ 且 $a,b$ 均为 $c$ 的祖先。
- $q$ 次询问，每次给定 $p,k$，求有多少个有序三元组 $(p,b,c)$ 是“$k$ 合法的”。
- $1\le n,q\le 3\times 10^5$，其余数据在合理范围内。

> 题解

容易发现其实就两种情况，一种是 $b$ 是 $p$ 的祖先，$c$ 是 $p$ 子树内任意一点，另一种是 $b$ 是 $p$ 的后代，$c$ 是 $b$ 子树内任意一点。

前者是简单的，记录 $p$ 子树大小和 $p$ 的深度即可。后者相当于 dfn 上区间询问深度小于某个数的所有点子树大小之和（相当于平面直角坐标系矩形求和），主席树秒了。

复杂度 $O(n\log n+q\log n)$。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(i64 i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(i64 i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<i64,i64>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
i64 read(){
	i64 x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const i64 N=3e5+5,inf=1e18;
i64 n,q;
vector<i64> e[N];
struct SegTree{
	#define mid ((l+r)>>1)
	#define lson l,mid,ls[id]
	#define rson mid+1,r,rs[id]
	i64 ls[N*40],rs[N*40],sum[N*40],root[N],cntn;
	void Build(i64 l,i64 r,i64 &id){
		if(!id) id=++cntn;
		if(l==r) return;
		Build(lson);Build(rson);
	}
	void Update(i64 P,i64 X,i64 l,i64 r,i64 &id,i64 pre){
		id=++cntn;
		ls[id]=ls[pre];rs[id]=rs[pre];
		sum[id]=sum[pre]+X;
		if(l==r) return;
		if(P<=mid) Update(P,X,lson,ls[pre]);
		else       Update(P,X,rson,rs[pre]);
	}
	i64 Query(i64 L,i64 R,i64 l,i64 r,i64 id,i64 pre){
		if(L<=l&&r<=R){
			return sum[id]-sum[pre];
		}
		i64 res=0;
		if(L<=mid) res+=Query(L,R,lson,ls[pre]);
		if(mid< R) res+=Query(L,R,rson,rs[pre]);
		return res;
	}
}mt;
i64 dfn[N],mp[N],sz[N],dpt[N],Tm;
void dfs(i64 x,i64 fa){
	dpt[x]=dpt[fa]+1;
	dfn[x]=++Tm;
	mp[dfn[x]]=x;
	sz[x]=1;
	for(auto i:e[x]){
		if(i==fa) continue;
		dfs(i,x);
		sz[x]+=sz[i];
	}
}
signed main(){
	n=read();q=read();
	forup(i,1,n-1){
		i64 u=read(),v=read();
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(1,0);
	mt.Build(1,n,mt.root[0]);
	forup(i,1,n){
		i64 u=mp[i];
		mt.Update(dpt[u],sz[u]-1,1,n,mt.root[i],mt.root[i-1]);
	}
	forup(i,1,q){
		i64 p=read(),k=read();
		i64 res=mt.Query(dpt[p],dpt[p]+k,1,n,mt.root[dfn[p]+sz[p]-1],mt.root[dfn[p]]);
		res+=min(dpt[p]-1,k)*(sz[p]-1);
		printf("%lld\n",res);
	}
}
```

///

## P8496 [NOI2022] 众数

[传送门](https://www.luogu.com.cn/problem/P8496)

> 题意

- 有 $n$ 个序列，第 $i$ 个序列长度为 $l_i$，维护四种操作共 $q$ 次：
	- 在某个序列末尾插入一个数字。
	- 删除某个序列尾部的数字。
	- 将两个序列接在一起成为一个新的序列，删除原来的两个序列。
	- 将一个大小为 $m$ 的序列可重集（出现多次需要算多次）拼在一起求绝对众数。
- 此处绝对众数指出现次数严格大于 $\left\lfloor\frac{M}{2}\right\rfloor$ 的数，$M$ 是序列长度。
- $1\le n,q,\sum m,\sum l_i\le 5\times 10^5$，序列中所有数为小于等于 $n+q$ 的正整数。

> 题解

看起来容易想到一些数据结构（比如线段树）的合并，那么显然最难的就是操作 $4$。

容易发现绝对众数必然是中位数，那么可以把可重集内的线段树放在一起进行线段树上二分（大概就是线段树二分的时候传一个点集进去，因为 $\sum m\le 5\times 10^5$ 所以复杂度还是对的），最后看中位数出现次数是否足够即可。

于是线段树和链表即可维护四个操作，复杂度 $O(\sum l\log n+q\log n+\sum m\log n)$。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,i64>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
	int x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const int N=1e6+5,inf=0x3f3f3f3f;
int n,q;
struct SegTree{
	#define mid ((l+r)>>1)
	int ls[N*20],rs[N*20],sum[N*20],root[N],cntn;
	void Update(int P,int X,int l,int r,int &id){
		if(!id) id=++cntn;
		sum[id]+=X;
		if(l==r) return;
		if(P<=mid) Update(P,X,l,mid,ls[id]);
		else       Update(P,X,mid+1,r,rs[id]);
	}
	i64 calc(vector<int> &vec){
		i64 res=0;
		for(auto i:vec){
			if(!i) continue;
			res+=sum[i];
		}
		return res;
	}
	vector<int> gls(vector<int>& vec){
		vector<int> res;
		for(auto i:vec){
			res.push_back(ls[i]);
		}
		return res;
	}
	vector<int> grs(vector<int>& vec){
		vector<int> res;
		for(auto i:vec){
			res.push_back(rs[i]);
		}
		return res;
	}
	pii Query(i64 P,int l,int r,vector<int> nd){
		if(l==r){
			return mkp(l,calc(nd));
		}
		vector<int> LS=gls(nd);
		i64 cnt=calc(LS);
		if(cnt>=P){
			return Query(P,l,mid,LS);
		}else{
			return Query(P-cnt,mid+1,r,grs(nd));
		}
	}
	int Merge(int l,int r,int u,int v){
		if(!u||!v){
			return u|v;
		}
		sum[u]+=sum[v];
		if(l==r) return u;
		ls[u]=Merge(l,mid,ls[u],ls[v]);
		rs[u]=Merge(mid+1,r,rs[u],rs[v]);
		return u;
	}
}mt;
int st[N],head[N],val[N],nxt[N],num[N],cnte;
void add(int x,int y){
	++cnte;
	val[cnte]=y;
	nxt[cnte]=head[x];
	if(!num[x]){
		st[x]=cnte;
	}
	++num[x];
	head[x]=cnte;
	mt.Update(y,1,1,n+q,mt.root[x]);
}
void del(int x){
	mt.Update(val[head[x]],-1,1,n+q,mt.root[x]);
	head[x]=nxt[head[x]];
	--num[x];
	if(!num[x]) st[x]=0;
}
signed main(){
	n=read();q=read();
	forup(i,1,n){
		int l=read();
		forup(j,1,l){
			int a=read();
			add(i,a);
		}
	}
	forup(i,1,q){
		int op=read();
		if(op==1){
			int x=read(),y=read();
			add(x,y);
		}else if(op==2){
			int x=read();
			del(x);
		}else if(op==3){
			int m=read();
			vector<int> vec;
			i64 sum=0;
			forup(i,1,m){
				int a=read();
				vec.push_back(mt.root[a]);
				sum+=num[a];
			}
			pii res=mt.Query((sum+1)/2,1,n+q,vec);
			if(res.se>sum/2){
				printf("%d\n",res.fi);
			}else{
				puts("-1");
			}
		}else{
			int x1=read(),x2=read(),x3=read();
			if(!num[x1]){
				mt.root[x3]=mt.root[x2];
				st[x3]=st[x2];head[x3]=head[x2];
				num[x3]=num[x2];
			}else if(!num[x2]){
				mt.root[x3]=mt.root[x1];
				st[x3]=st[x1];head[x3]=head[x1];
				num[x3]=num[x1];
			}else{
				mt.root[x3]=mt.Merge(1,n+q,mt.root[x1],mt.root[x2]);
				nxt[st[x2]]=head[x1];
				head[x3]=head[x2];st[x3]=st[x1];
				num[x3]=num[x1]+num[x2];
			}
		}
	}
}
```

///

## [AGC002D] Stamp Rally

[传送门](https://www.luogu.com.cn/problem/AT_agc002_d)

> 题意

- 有一张 $n$ 个点 $m$ 条边的无向图，边的边权即为它读入时的编号。
- $q$ 次询问，每次询问给定两点 $x,y$ 和正整数 $z$，问你从 $x,y$ 出发经过总共恰好 $z$ 个不同的点所需经过的边权最大值最小是多少。
- $3\le n\le 10^5,n-1\le m\le 10^5,1\le q\le 10^5$，其它数据在合理范围内。

> 题解

首先容易想到二分答案，于是转化为求只经过边权不超过 $mid$ 的边能到达多少个点。

容易想到 Kruskal 重构树。一个问题是有两个点，容易发现若两个点通过边权不超过 $mid$ 的边能连通那么两个点必定会倍增跳到同一个点，只需要算一遍，否则就是两个不同连通块，直接加起来即可。

复杂度 $O(n\log n+q\log^2 n)$。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
	int x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const int N=1e5+5,inf=0x3f3f3f3f;
int n,m,q,cntn;
int fa[N],rt[N];
int getfa(int x){return x==fa[x]?x:fa[x]=getfa(fa[x]);}
int f[N<<1][18],val[N<<1],sz[N<<1];
vector<int> e[N<<1];
void dfs(int x){
	if(x<=n) sz[x]=1;
	forup(i,1,17){
		f[x][i]=f[f[x][i-1]][i-1];
	}
	for(auto i:e[x]){
		f[i][0]=x;
		dfs(i);
		sz[x]+=sz[i];
	}
}
int calc(int x,int y,int mm){
	fordown(i,17,0){
		if(f[x][i]&&val[f[x][i]]<=mm) x=f[x][i];
		if(f[y][i]&&val[f[y][i]]<=mm) y=f[y][i];
	}
	if(x==y){
		return sz[x];
	}else{
		return sz[x]+sz[y];
	}
}
signed main(){
	n=read();m=read();
	forup(i,1,n) fa[i]=rt[i]=i;
	cntn=n;
	forup(i,1,m){
		int u=read(),v=read();
		u=getfa(u);v=getfa(v);
		if(u==v) continue;
		++cntn;
		val[cntn]=i;
		e[cntn].push_back(rt[u]);
		e[cntn].push_back(rt[v]);
		fa[u]=v;
		rt[v]=cntn;
	}
	dfs(cntn);
	q=read();
	forup(i,1,q){
		int x=read(),y=read(),z=read();
		int ll=0,rr=m,mm;
		while(ll<rr){
			mm=(ll+rr)>>1;
			if(calc(x,y,mm)>=z) rr=mm;
			else ll=mm+1;
		}
		printf("%d\n",ll);
	}
}
```

///

## P9196 [JOI Open 2016] 销售基因链

[传送门](https://www.luogu.com.cn/problem/P9196)

> 题意

- 给定一个大小为 $n$ 的字符串集合。
- $q$ 次询问，每次给定两字符串 $s,t$，问集合中有多少字符串既存在前缀等于 $s$ 又存在后缀等于 $t$。
- $1\le n,q\le 10^5,\sum|s|,\sum |t|\le 2\times 10^6$，集合内字符串总长度小于等于 $2\times 10^6$。

> 题解

一眼正反分别扔到 Trie 上转化为二维数点，复杂度 $O(\sum |s|+\sum |t|+(n+q)\log S)$，其中 $S$ 是集合内字符串总长。

然后看题解发现有更优的做法。

首先一个 $O(\sum |s|+\sum |t|)$ 的做法是在第一颗 Trie 上跑完之后发现是区间查询第二棵 Trie，可以可持久化 Trie。

另一个 $O(\sum |s|+\sum |t|)$ 的做法是将所有字符串拼成形如 $s_1\#s_1\& s_2\#s_2\& s_3\#s_3\& s_4\#s_4\dots$ 的样子（$\&,\#$ 是两个没出现过的特殊字符），然后查询 $t\# s$ 的出现次数，这个可以用 ACAM 或者 SAM。

代码是最上面那个二维数点做法的。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
	int x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const int N=2e6+5,inf=0x3f3f3f3f;
int n,m,ans[N];
char str[N];
int get(char c){
	if(c=='A'){
		return 0;
	}else if(c=='U'){
		return 1;
	}else if(c=='G'){
		return 2;
	}else{
		return 3;
	}
}
int x[N],y[N];
struct Trie{
	int tr[N][4],cntn,st[N],ed[N],Tm;
	int insert(int len){
		int p=0;
		forup(i,1,len){
			int c=get(str[i]);
			if(!tr[p][c]) tr[p][c]=++cntn;
			p=tr[p][c];
		}
		return p;
	}
	int find(int len){
		int p=0;
		forup(i,1,len){
			int c=get(str[i]);
			if(!tr[p][c]) return -1;
			p=tr[p][c];
		}
		return p;
	}
	void dfs(int x){
		st[x]=++Tm;
		forup(i,0,3){
			if(!tr[x][i]) continue;
			dfs(tr[x][i]);
		}
		ed[x]=Tm;
	}
};
Trie t1,t2;
struct BIT{
	int c[N];
	void upd(int x,int k){for(;x<=t2.Tm;x+=x&-x)c[x]+=k;}
	int sum(int x){int res=0;for(;x>0;x-=x&-x)res+=c[x];return res;}
}mt;
struct Query{
	int l,r,pos,val;
};
vector<Query> q[N];
signed main(){
	n=read();m=read();
	forup(i,1,n){
		scanf(" %s",str+1);
		int len=strlen(str+1);
		x[i]=t1.insert(len);
		reverse(str+1,str+len+1);
		y[i]=t2.insert(len);
	}
	t1.dfs(0);t2.dfs(0);
	forup(i,1,n){
		int px=t1.st[x[i]],py=t2.st[y[i]];
		q[px].push_back(Query{py,0,0,0});
	}
	forup(i,1,m){
		int x1=-1,y1=-1,x2=-1,y2=-1;
		scanf(" %s",str+1);
		int len=strlen(str+1);
		int u=t1.find(len);
		if(u!=-1){
			x1=t1.st[u];x2=t1.ed[u];
		}
		scanf(" %s",str+1);
		len=strlen(str+1);
		reverse(str+1,str+len+1);
		u=t2.find(len);
		if(u!=-1){
			y1=t2.st[u],y2=t2.ed[u];
		}
		if(~x1&&~y1){
			q[x1-1].push_back(Query{y1,y2,i,-1});
			q[x2].push_back(Query{y1,y2,i,1});
		}
	}
	forup(i,1,t1.Tm){
		for(auto j:q[i]){
			if(j.pos==0){
				mt.upd(j.l,1);
			}else{
				ans[j.pos]+=j.val*(mt.sum(j.r)-mt.sum(j.l-1));
			}
		}
	}
	forup(i,1,m){
		printf("%d\n",ans[i]);
	}
}
```

///

## P3285 [SCOI2014] 方伯伯的OJ

[传送门](https://www.luogu.com.cn/problem/P3285)

> 题意

- 有 $n$ 个人排成一排，初始编号为 $1\sim n$，且递增排列，维护四个操作共 $m$ 次：
	- 查询从前往后第 $k$ 个人的编号。
	- 将编号为 $k$ 的人挪到队伍开头。
	- 将编号为 $k$ 的人挪到队伍末尾。
	- 将编号为 $k$ 的人的编号修改为 $p$。
- 保证所有操作的编号存在，并且无论何时都不会有两个人编号相同。
- $1\le n\le 10^8,1\le q\le 10^5$，无论何时所有编号在 $2\times 10^8$ 以内。

> 题解

平衡树板题，但是写起来比较复杂（如果用 FHQ 的话需要维护一些新的操作）。

容易发现只要能找到某个编号的排名剩下的就是平衡树板子操作了。

这个怎么办呢，可以用一个 map 维护每个编号在平衡树上对应结点，然后每次从结点往上跳即可找到排名。

这个在 Splay 好像是经典的，但是我不咋熟悉 Splay，就搞了个神秘 FHQ。

复杂度 $O(m\log m)$，注意把所有点都维护出来空间会炸，考虑维护点的连续段即可。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
	int x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const int N=5e5+5,inf=0x3f3f3f3f;
int n,m,lans;
map<pii,int> mp;
using mit=map<pii,int>::iterator;
mt19937 mr(time(0));
struct FHQTreap{
	int ls[N],rs[N],lp[N],rp[N],hv[N],fa[N],sum[N],root,cntn;
	stack<int> stk;
	int New(int L,int R){
		int nw;
		if(stk.size()){
			nw=stk.top();stk.pop();
		}else{
			nw=++cntn;
		}
		ls[nw]=rs[nw]=fa[nw]=0;
		lp[nw]=L;rp[nw]=R;
		mp[mkp(L,R)]=nw;
		hv[nw]=mr();
		sum[nw]=R-L+1;
		return nw;
	}
	void Del(int id){
		stk.push(id);
		mp.erase(mkp(lp[id],rp[id]));
	}
	void PushUp(int id){
		sum[id]=sum[ls[id]]+sum[rs[id]]+rp[id]-lp[id]+1;
		fa[id]=0;//可以在 pushup 的时候更新 fa
		if(ls[id]) fa[ls[id]]=id;
		if(rs[id]) fa[rs[id]]=id;
	}
	void Split(int id,int key,int &x,int &y){
		if(!id){
			x=y=0;
			return;
		}
		if(sum[ls[id]]>=key){
			y=id;
			Split(ls[id],key,x,ls[y]);
		}else{
			x=id;
			Split(rs[id],key-(sum[id]-sum[rs[id]]),rs[x],y);
		}
		PushUp(id);
	}
	int Merge(int x,int y){
		if(!x||!y){
			return x|y;
		}
		if(hv[x]>hv[y]){
			rs[x]=Merge(rs[x],y);
			PushUp(x);
			return x;
		}else{
			ls[y]=Merge(x,ls[y]);
			PushUp(y);
			return y;
		}
	}
	void insert(int L,int R){
		root=Merge(root,New(L,R));
	}
	pii findrank(int id){
		int res=sum[ls[id]],len=rp[id]-lp[id]+1;
		while(fa[id]){
			if(id==rs[fa[id]]){
				res+=(sum[fa[id]]-sum[id]);
			}
			id=fa[id];
		}
		return mkp(res+1,res+len);
	}
	int SplitNode(int p,int &x,int &y,int &z){
		mit it=prev(mp.upper_bound(mkp(p,inf)));
		int l=it->fi.fi,r=it->fi.se;
		pii rg=findrank(it->se);
		Split(root,rg.fi-1,x,y);Split(y,rg.se-rg.fi+1,y,z);
		Del(y);
		if(p!=l) x=Merge(x,New(l,p-1));
		y=New(p,p);
		if(p!=r) z=Merge(New(p+1,r),z);
		return rg.fi+p-l;
	}
	int Tomax(int p){
		int x,y,z;
		int res=SplitNode(p,x,y,z);
		root=Merge(Merge(x,z),y);
		return res;
	}
	int Tomin(int p){
		int x,y,z;
		int res=SplitNode(p,x,y,z);
		root=Merge(y,Merge(x,z));
		return res;
	}
	int Modify(int p,int v){
		int x,y,z;
		int res=SplitNode(p,x,y,z);
		Del(y);
		root=Merge(Merge(x,New(v,v)),z);
		return res;
	}
	int At(int key,int id){
		if(ls[id]&&sum[ls[id]]>=key){
			return At(key,ls[id]);
		}else if(key-sum[ls[id]]<=rp[id]-lp[id]+1){
			return lp[id]+key-sum[ls[id]]-1;
		}else{
			return At(key-(sum[id]-sum[rs[id]]),rs[id]);
		}
	}
}mt;
signed main(){
	n=read();m=read();
	mt.insert(1,n);
	forup(i,1,m){
		int op=read();
		if(op==1){
			int x=read(),y=read();
			x-=lans;y-=lans;
			lans=mt.Modify(x,y);
			printf("%d\n",lans);
		}else if(op==2){
			int x=read();
			x-=lans;
			lans=mt.Tomin(x);
			printf("%d\n",lans);
		}else if(op==3){
			int x=read();
			x-=lans;
			lans=mt.Tomax(x);
			printf("%d\n",lans);
		}else{
			int k=read();
			k-=lans;
			lans=mt.At(k,mt.root);
			printf("%d\n",lans);
		}
	}
}
```

///

## CF19E Fairy 加强版

[传送门](https://www.luogu.com.cn/problem/CF19E)

> 题意

- 有一张 $n$ 个点 $m$ 条边的无向图，可能有重边和自环，不一定连通，问有哪些边删掉后这张图是二分图。
- $1\le n,m\le 10^6$

> 题解

呃呃被重边自环气晕。

先特判本来就是二分图的情况。

首先容易想到在 dfs 生成树上搞。

然后称仅包含一条非树边的环为简单环，显然需要删掉的边必定是所有简单奇环的交（不然简单环都没删完怎么可能搞完）。

并且容易发现删掉的边不可能属于简单偶环，不然它显然不可能把奇环删完。

然后再分类讨论一下可以发现能删的边就是**所有简单奇环，且不属于任意简单偶环**的边。

然后特判只有一个奇环的情况，此时那条非树边是可以删的。

可以树上差分维护，复杂度 $O(n+m)$。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
	int x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const int N=1e6+5;
int n,m,u[N],v[N];
vector<int> e[N],e2[N];
vector<pii> sv;
int dpt[N],sum[2][N],vis[N],cnt;
void dfs(int x,int fa){
	vis[x]=1;
	dpt[x]=dpt[fa]+1;
	for(auto i:e[x]){
		if(vis[i]){
			if(dpt[i]>=dpt[x]) sv.push_back(mkp(i,x));
			continue;
		}
		e2[x].push_back(i);
		dfs(i,x);
	}
}
void dfs2(int x){
	for(auto i:e2[x]){
		dfs2(i);
		sum[0][x]+=sum[0][i];
		sum[1][x]+=sum[1][i];
	}
}
signed main(){
	n=read();m=read();
	forup(i,1,m){
		u[i]=read();v[i]=read();
		e[u[i]].push_back(v[i]);
		if(v[i]!=u[i]) e[v[i]].push_back(u[i]);
	}
	vector<int> rt;
	forup(i,1,n){
		if(!vis[i]){
			rt.push_back(i);
			dfs(i,0);
		}
	}
	vector<int> ans;
	for(auto i:sv){
		int u=i.fi,v=i.se;
		sum[(dpt[u]-dpt[v]+1)&1][u]+=1;
		sum[(dpt[u]-dpt[v]+1)&1][v]-=1;
		cnt+=(dpt[u]-dpt[v]+1)&1;
	}
	if(cnt==0){
		printf("%d\n",m);
		forup(i,1,m){
			printf("%d ",i);
		}
		return 0;
	}
	for(auto i:rt){
		dfs2(i);
	}
	forup(i,1,m){
		int a=u[i],b=v[i];
		if(dpt[a]>dpt[b]) swap(a,b);
		if(dpt[b]==dpt[a]+1){
			if(sum[1][b]==cnt&&!sum[0][b]){
				ans.push_back(i);
			}
		}else{
			if(cnt==1&&(dpt[b]-dpt[a])%2==0){
				ans.push_back(i);
			}
		}
	}
	printf("%d\n",(int)ans.size());
	sort(ans.begin(),ans.end());
	for(auto i:ans){
		printf("%d ",i);
	}
}
```

///

## P4219 [BJOI2014] 大融合

[传送门](https://www.luogu.com.cn/problem/P4219)

> 题意

- 有一个 $n$ 个点的森林，初始没有边。
- 维护 $2$ 种操作共 $q$ 次：
	- 加边 $(u,v)$，保证此前 $u,v$ 不连通。
	- 询问 $f(u,v)$，其中 $f(u,v)$ 指经过边 $(u,v)$ 的简单路径数量，保证此前边 $(u,v)$ 已经加入。
- $1\le n,q\le 10^5$

> 题解

简单题，但是想复杂了。

这个询问就是相当于询问对应连通块的点数以及该连通块中某个子树的点数。

设某连通块有 $c$ 个点，容易发现只要在每个点处维护一个 $1$，每个连通块根节点父亲处维护一个 $-c$，这样每个点的子树和就是它所在连通块中它的子树大小。

用并查集 $+$ 树状数组即可维护（需要离线预处理 dfn），复杂度 $O(n\log n)$。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(i64 i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(i64 i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<i64,i64>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
i64 read(){
	i64 x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const i64 N=1e5+5,inf=0x3f3f3f3f;
i64 n,m;
i64 fa[N];
i64 dfn[N],Tm,sz[N],dpt[N],ff[N];
struct Query{
	i64 u,v,op;
}q[N];
char str[5];
vector<i64> e[N];
void dfs(i64 x,i64 fa){
	dfn[x]=++Tm;
	sz[x]=1;
	dpt[x]=dpt[fa]+1;
	ff[x]=fa;
	for(auto i:e[x]){
		if(i==fa) continue;
		dfs(i,x);
		sz[x]+=sz[i];
	}
}
struct BIT{
	i64 c[N];
	void upd(i64 x,i64 k){for(;x<=Tm;x+=x&-x)c[x]+=k;}
	i64 sum(i64 x){i64 res=0;for(;x>0;x-=x&-x)res+=c[x];return res;}
}mt;
i64 getfa(i64 x){return x==fa[x]?x:fa[x]=getfa(fa[x]);}
void merge(i64 u,i64 v){
	u=getfa(u);v=getfa(v);
	if(dpt[u]>dpt[v]) swap(u,v);
	i64 val=mt.sum(dfn[v]+sz[v]-1)-mt.sum(dfn[v]-1);
	if(ff[v]) mt.upd(dfn[ff[v]],val);
	if(ff[u]) mt.upd(dfn[ff[u]],-val);
	fa[v]=u;
}
signed main(){
	n=read();m=read();
	forup(i,1,m){
		scanf(" %s",str);
		i64 u=read(),v=read();
		if(str[0]=='A'){
			e[u].push_back(v);
			e[v].push_back(u);
			q[i]=Query{u,v,1};
		}else{
			q[i]=Query{u,v,0};
		}
	}
	forup(i,1,n){//注意可能不连通
		if(!dfn[i]){
			dfs(i,0);
		}
	}
	forup(i,1,n) fa[i]=i;
	forup(i,1,n){
		mt.upd(dfn[i],1);
		if(ff[i]) mt.upd(dfn[ff[i]],-1);
	}
	forup(i,1,m){
		if(q[i].op){
			merge(q[i].u,q[i].v);
		}else{
			i64 u=q[i].u,v=q[i].v;
			if(dpt[u]>dpt[v]) swap(u,v);
			i64 rt=getfa(v);
			i64 sz1=mt.sum(dfn[v]+sz[v]-1)-mt.sum(dfn[v]-1),sz2=mt.sum(dfn[rt]+sz[rt]-1)-mt.sum(dfn[rt]-1);
			printf("%lld\n",(sz2-sz1)*sz1);
		}
	}
}
```

///

## 「JOISC 2017 Day 2」火车旅行

[传送门](https://www.luogu.com.cn/problem/AT_joisc2017_f)

> 题意

- 有一条铁路线，其上有 $n$ 个站点，每个站点有权值 $a_i$。
- 有 $k$ 种列车（双向运行），第 $i$ 种列车编号为 $i$，表示它会在所有编号大于等于 $i$ 的站点停靠。
- 有 $q$ 名旅客，第 $i$ 名旅客要从 $u_i$ 坐车到 $v_i$（保证 $u_i\ne v_i$），允许走回头路，问最少停靠几站，不算起点终点。
- $2\le n\le 10^5,1\le q\le 10^5,1\le k\le n$

> 题解

很神秘的倍增题，日本人出题都这样吗。

首先下文叙述停靠站点算终点不算起点，这样比较符合直觉。

一个显然的观察是路线具有可逆性，即如果能从 $u$ 开始停靠 $p$ 站到达 $v$，那么必然能从 $v$ 开始顺着走 $p$ 站到达 $u$，每次坐同样的列车就好了。于是考虑能不能从起点和终点走到同一个点。

另一个观察是若 $u$ 停 $p$ 站能走到的最左右端点分别是 $l_u,r_u$，$v$ 停 $q$ 站的左右端点分别是 $l_v,r_v$，那么假如 $[l_u,r_u]$ 和 $[l_v,r_v]$ 有交，则必定存在从 $u$ 停 $p+q$ 站到达 $v$ 的路线。（先钦定 $u < v$）容易发现假如 $u$ 停 $p$ 站不能到达 $l_v$，那么必然有 $a_{r_u} > a_{l_v}$，于是 $v$ 停至多 $q$ 站必定能到达 $r_u$。

那么容易想到倍增，因为允许走回头路，所以倍增预处理要分别考虑从左右走，并且预处理和查询都要分别从左右转移取最值，然后查询和 LCA 一样找到“再走一步就会有交”的位置，具体见代码。

复杂度 $O(n\log n+q\log n)$。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
	int x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const int N=1e5+5,inf=0x3f3f3f3f;
int n,m,q,fl[20][N],fr[20][N],a[N];
signed main(){
	n=read();m=read();q=read();
	forup(i,1,n){
		a[i]=read();
	}
	stack<int> stk;
	stk.push(1);
	fl[0][1]=1;
	forup(i,2,n){
		while(a[stk.top()]<a[i]) stk.pop();
		fl[0][i]=stk.top();
		stk.push(i);
	}
	while(stk.size()) stk.pop();
	stk.push(n);
	fr[0][n]=n;
	fordown(i,n-1,1){
		while(a[stk.top()]<a[i]) stk.pop();
		fr[0][i]=stk.top();
		stk.push(i);
	}
	forup(i,1,19){
		forup(j,1,n){
			fl[i][j]=min(fl[i-1][fl[i-1][j]],fl[i-1][fr[i-1][j]]);
			fr[i][j]=max(fr[i-1][fl[i-1][j]],fr[i-1][fr[i-1][j]]);
		}
	}
	forup(i,1,q){
		int u=read(),v=read();
		if(u>v) swap(u,v);
		int pl=u,pr=u,ans=0;
		fordown(i,19,0){
			int nl=min(fl[i][pl],fl[i][pr]),nr=max(fr[i][pl],fr[i][pr]);
			if(nr<v){
				pl=nl;pr=nr;
				ans+=(1<<i);
			}
		}
		u=pr;
		pr=pl=v;
		fordown(i,19,0){
			int nl=min(fl[i][pl],fl[i][pr]),nr=max(fr[i][pl],fr[i][pr]);
			if(nl>u	){
				pl=nl;pr=nr;
				ans+=(1<<i);
			}
		}
		printf("%d\n",ans);
	}
}
```

///

## P1084 [NOIP2012 提高组] 疫情控制

[传送门](https://www.luogu.com.cn/problem/P1084)

> 题意

- 有一棵 $n$ 个点的树，树上有 $m$ 个黑色棋子，每个点上可能有多个黑子，每条边有长度。
- 你现在需要移动每个棋子使得任意叶子至少有一个非根的祖先上有黑子，求移的最远的棋子移了多远。
- $1\le n,m\le 5\times 10^4$。

> 题解

一眼二分答案，考虑如何 check。

首先显然无解当且仅当根结点的度数大于 $m$。

容易想到每个点暴力往上跳是不劣的，那么每个点就有能到根和不能到根两种情况。

不能到根的就站在那里不动，能到根的还能跨过根去支援其它子树。

于是容易想到二分图匹配，每个黑子向自己的子树和某按距离排序的前缀连边，直接拍前缀和优化建图的 dinic 有 90pts，被菊花图卡了。

有一个贪心，将所有能到根的黑子按剩余距离从小到大排，然后每个黑子分给还没有黑子的的距离最大的子树（包括它自己的），正确性显然，使用一点调整法即可。

复杂度 $O(n\log^2 n)$，因为需要倍增找每个点停在哪里，但是这个 $\log$ 好像可以压掉，怎么回事呢。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(i64 i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(i64 i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
using i64=long long;
using pii=pair<i64,i64>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
i64 read(){
	i64 x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const i64 N=5e4+5,inf=1e18;
i64 n,m,a[N],sum;
vector<pii> e[N];
i64 f[17][N],dpt[N],rt[N],val[N];
void dfs(i64 x,i64 fa){
	f[0][x]=fa;
	if(fa==1||x==1){
		rt[x]=x;
	}else{
		rt[x]=rt[fa];
	}
	forup(i,1,16){
		f[i][x]=f[i-1][f[i-1][x]];
	}
	for(auto i:e[x]){
		i64 v=i.fi,w=i.se;
		if(v==fa) continue;
		dpt[v]=dpt[x]+w;
		val[v]=w;
		dfs(v,x);
	}
}
i64 vis[N];
vector<pii> ed;
bool dfs2(i64 x,i64 fa){
	if(vis[x]) return false;
	if(e[x].size()==1){
		return true;
	}
	for(auto i:e[x]){
		i64 v=i.fi;
		if(v==fa) continue;
		if(dfs2(v,x)){
			return true;
		}
	}
	return false;
}
bool chk(i64 mm){
	forup(i,1,n) vis[i]=0;
	vector<pii> vec;
	set<pii> ss;
	forup(i,1,m){
		i64 u=a[i];
		if(mm>=dpt[u]){
			vec.push_back(mkp(mm-dpt[u],u));
		}else{
			i64 dd=dpt[u]-mm;
			fordown(j,16,0){
				if(dpt[f[j][u]]>=dd){
					u=f[j][u];
				}
			}
			vis[u]=1;
		}
	}
	for(auto i:e[1]){
		i64 v=i.fi;
		if(dfs2(v,1)){
			ss.insert(mkp(val[v],v));
		}
	}
	sort(vec.begin(),vec.end());
	for(auto i:vec){
		int u=i.se,rr=rt[u];;
		if(val[rr]>i.fi&&ss.count(mkp(val[rr],rr))){
			ss.erase(mkp(val[rr],rr));
			continue;
		}
		set<pii>::iterator p=ss.upper_bound(mkp(i.fi,inf));
		if(p!=ss.begin()){
			ss.erase(prev(p));
		}
	}
	return ss.empty();
}
signed main(){
	n=read();
	forup(i,1,n-1){
		i64 u=read(),v=read(),w=read();
		e[u].push_back(mkp(v,w));
		e[v].push_back(mkp(u,w));
		sum+=w;
	}
	m=read();
	forup(i,1,m){
		a[i]=read();
	}
	if(m<(i64)e[1].size()){
		puts("-1");
		return 0;
	}
	dfs(1,0);
	i64 ll=0,rr=sum,mm;
	while(ll<rr){
		mm=(ll+rr)>>1;
		if(chk(mm)) rr=mm;
		else ll=mm+1;
	}
	printf("%lld\n",ll);
}
```

///

## [ARC173D] Bracket Walk

[传送门](https://www.luogu.com.cn/problem/AT_arc173_d)

> 题意

- 有一张 $n$ 个点 $m$ 条边的有向图，每条边上有一个 `(` 或 `)` 字符，保证图强连通。
- 问存不存在一条路径，使得：
	- 这条路径上的字符恰好构成一个合法括号序列。
	- 这条路径经过每条边至少一次。
	- 这条路径的起点和终点相同。
- $1\le n\le 4000,n\le m\le 8000$。

> 题解

猜了个结论，没想到对了。

容易发现把左括号设为 $+1$ 右括号视为 $-1$ 那么就是问存不存在总和恰为 $0$ 的环。

首先考虑如何构造经过每条边至少一次，有一个平凡构造是先随便选一个点 $p$，枚举每条边 $u\to v$，走 $p\to u\to v\to p$，因为图强连通这是显然能构造出来的。

那么设这样构造出来的环总和为 $C$，若 $C>0$ 则找一个 $C'<0$ 的环取最小公倍数抵消掉（因为每条边都被经过了一次所以可以顺路搞），$C<0$ 同理。

那么容易猜出有解的充要条件：**图中既有正环又有负环或图中既没有正环又没有负环**。

充分性比较好证，前者能根据之前的构造得出，后者也是显然的，因为图中任意环总和都是 $0$ 故 $C=0$。

然后考虑必要性，可证否命题**若图中有且仅有两者之一则必定无解**。

~~想一想感觉构造不出来于是直接交然后就过了~~

考虑反证法，以只有正环的情况为例，假设这样的情况能得到一组合法解。那么显然其中必定包含了至少一个正环（因为经过了所有边至少一次），那么把它删掉后剩下的还是一个环（因为一个环的起点终点显然相同），因为原先的环和是 $0$，剩下的就是一个负环，与假设矛盾。只有负环的情况同理。

于是跑两遍 SPFA 判负环（全取反即可判正环）即可，复杂度 $O(nm)$。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
	int x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const int N=4005,inf=0x3f3f3f3f;
int n,m;
struct edge{
	int v,w;
};
vector<edge> e[N];
char str[5];
int dis[N],cnt[N],vis[N];
bool spfa(int p){
	forup(i,1,n){
		dis[i]=inf;
		cnt[i]=vis[i]=0;
	}
	queue<int> q;
	dis[1]=0;q.push(1);
	vis[1]=1;
	while(q.size()){
		int u=q.front();q.pop();
		vis[u]=0;
		for(auto i:e[u]){
			int v=i.v,w=i.w*p;
			if(dis[v]<=dis[u]+w) continue;
			++cnt[v];
			dis[v]=dis[u]+w;
			if(!vis[v]){
				vis[v]=1;
				q.push(v);
			}
			if(cnt[v]>=n) return true;
		}
	}
	return false;
}
signed main(){
	n=read();m=read();
	forup(i,1,m){
		int u=read(),v=read();
		scanf(" %s",str);
		int w=(str[0]=='('?1:-1);
		e[u].push_back(edge{v,w});
	}
	int c1=spfa(1),c2=spfa(-1);
	msg("%d %d|\n",c1,c2);
	puts((c1&&c2)||(!c1&&!c2)?"Yes":"No");
}
```

///

## P2680 [NOIP2015 提高组] 运输计划

[传送门](https://www.luogu.com.cn/problem/P2680)

> 题意

- 有一棵 $n$ 个点的树，边有边权。另有 $m$ 条简单路径。
- 你可以将任意一条边权值修改为 $0$，求路径长度最大值最小是多少。
- $1\le n,m \le 3\times 10^5$。

> 题解

单 $\log$ 过 $3\times 10^5$ 的一秒要卡常，怎么回事呢。

显然答案就是对每条边计算**断掉的最长链**与**没断掉的最长链**取 $\max$。

考虑显然必须断最长路径，否则必定不优。

然后断掉的最长链就是全局最长路径，于是只需要对这条路径上的每条边计算不经过它的最长路径。

每条路径与最长路径的交显然是一段区间，所以不包含它的必定是一段前缀和一段后缀，随便维护一下即可。

复杂度 $O(n\log n)$。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
	int x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const int N=3e5+5,inf=0x3f3f3f3f;
int n,m;
struct edge{
	int v,w;
};
vector<edge> e[N];
int f[19][N],dpt[N],dis[N],Tm,co[N],fv[N];
int dfn[N],st[19][N];
void dfs1(int x,int fa){
	dfn[x]=++Tm;
	st[0][dfn[x]]=fa;
	for(auto i:e[x]){
		if(i.v==fa) continue;
		dis[i.v]=dis[x]+i.w;
		dfs1(i.v,x);
	}
}
void initst(){
	forup(i,0,17){
		forup(j,1,n-(1<<(i+1))+1){
			st[i+1][j]=dfn[st[i][j]]<dfn[st[i][j+(1<<i)]]?st[i][j]:st[i][j+(1<<i)];
		}
	}
}
void dfs2(int x,int fa){
	f[0][x]=fa;
	forup(i,1,18){
		f[i][x]=f[i-1][f[i-1][x]];
	}
	dpt[x]=dpt[fa]+1;
	for(auto i:e[x]){
		if(i.v==fa) continue;
		fv[i.v]=i.w;
		dfs2(i.v,x);
	}
}
int lca(int u,int v){
	if(u==v) return u;
	u=dfn[u];v=dfn[v];
	if(u>v) swap(u,v);
	++u;
	int len=31^__builtin_clz(v-u+1);
	return dfn[st[len][u]]<dfn[st[len][v-(1<<len)+1]]?st[len][u]:st[len][v-(1<<len)+1];
}
int len[N],p[N],q[N];
vector<int> del[N],add[N];
multiset<int> ss;
signed main(){
//	freopen("P2680_13.in","r",stdin);
	n=read();m=read();
	forup(i,1,n-1){
		int u=read(),v=read(),w=read();
		e[u].push_back(edge{v,w});
		e[v].push_back(edge{u,w});
	}
	dfs1(1,0);
	initst();
	int mx=-1;
	forup(i,1,m){
		p[i]=read();q[i]=read();
		int l=lca(p[i],q[i]);
		len[i]=dis[p[i]]+dis[q[i]]-2*dis[l];
		ss.insert(len[i]);
		if(mx==-1||len[i]>len[mx]) mx=i;
	}
	ss.erase(ss.find(len[mx]));
	Tm=0;
	dfs2(p[mx],0);
	for(int i=q[mx];i;i=f[0][i]){
		co[i]=1;
	}
	forup(i,1,m){
		if(i==mx) continue;
		int u=p[i],v=q[i];
		fordown(i,18,0) if(f[i][u]&&!co[f[i][u]]) u=f[i][u];
		fordown(i,18,0) if(f[i][v]&&!co[f[i][v]]) v=f[i][v];
		u=f[0][u];v=f[0][v];
		if(u==p[mx]&&v==p[mx]) continue;
		if(dpt[u]>dpt[v]) swap(u,v);
		del[v].push_back(len[i]);
		add[u].push_back(len[i]);
	}
	int ans=len[mx];
	for(int i=q[mx];i!=p[mx];i=f[0][i]){
		for(auto j:add[i]){
			ss.insert(j);
		}
		for(auto j:del[i]){
			ss.erase(ss.find(j));
		}
		if(ss.size()) ans=min(ans,max(*prev(ss.end()),len[mx]-fv[i]));
		else ans=min(ans,len[mx]-fv[i]);
	}
	printf("%d\n",ans);
}
```

///

## CF1659E AND-MEX Walk

[传送门](https://www.luogu.com.cn/problem/CF1659E)

> 题意

- 有一张 $n$ 个点的无向联通图，边有边权。
- 对于一条可经过重复边的路径，设它顺次经过的边权值分别为 $w_1,w_2,\dots$，定义它的权值为 $\mathrm{mex}(w_1,w_1\And w_2,w_1\And w_2\And w_3,\dots)$，其中 $\And$ 指按位与。
- $q$ 次询问，每次给定点 $u,v$ 求从 $u$ 出发到达 $v$ 的路径权值最小是多少。
- $1\le n,q\le 10^5+5,1\le w< 2^{30}$

> 题解

首先容易发现答案只可能是 $0,1,2$，因为序列中不可能同时出现 $1,2$。

何时答案为 $0$？即 $u,v$ 只经过某一位为 $1$ 的边能联通，可以开 $30$ 个并查集解决。

何时答案为 $1$？首先答案不为 $0$，并且序列的最低位在其它位不为 $0$ 的情况下变为 $0$，那么在上面的联通块下再维护每个联通块中有没有末位为 $0$ 的边即可。

否则答案为 $2$。

复杂度 $O(n\log V\alpha (n))$。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
	int x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const int N=2e5+5,inf=0x3f3f3f3f;
int n,m,q;
struct dsu{
	int fa[N],has0[N];
	void init(){
		forup(i,1,n){
			fa[i]=i;
			if(!(i&1)) has0[i]=0;
		}
	}
	int getfa(int x){return x==fa[x]?x:fa[x]=getfa(fa[x]);}
	void merge(int u,int v){
		u=getfa(u);v=getfa(v);
		if(u==v) return;
		fa[u]=v;
		has0[v]=has0[u]|has0[v];
	}
}t[30];
signed main(){
	n=read();m=read();
	forup(i,0,29) t[i].init();
	forup(i,1,m){
		int u=read(),v=read(),w=read();
		forup(j,0,29){
			if((w>>j)&1){
				t[j].merge(u,v);
			}
		}
		if(!(w&1)){
			forup(j,0,29){
				t[j].has0[t[j].getfa(u)]=1;
				t[j].has0[t[j].getfa(v)]=1;
			}
		}
	}
	q=read();
	while(q--){
		int u=read(),v=read();
		bool f1=false,f2=false;
		forup(i,0,29){
			int fu=t[i].getfa(u),fv=t[i].getfa(v);
			if(fu==fv){
				f1=true;
				break;
			}
			if(i!=0&&t[i].has0[fu]){
				f2=true;
			}
		}
		if(f1){
			puts("0");
		}else if(f2){
			puts("1");
		}else{
			puts("2");
		}
		
	}
}
```

///