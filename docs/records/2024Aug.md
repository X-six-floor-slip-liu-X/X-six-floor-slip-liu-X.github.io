---
comments: true
---

# 2024 8 月杂题

感觉耍一个暑假耍废了。

## P2839 [国家集训队] middle

[传送门](https://www.luogu.com.cn/problem/P2839)

> 题意

- 给定一个序列 $s$。
- $q$ 次询问，每次询问给你四个值 $a,b,c,d$，查询左端点在 $[a,b]$ 内，右端点在 $[c,d]$ 内的字串中，中位数最大值。
- 此处大小的偶数的可重集中中位数取较大的那个。
- $1\le n\le 2\times 10^4,1\le q\le 25000$，强制在线。

> 题解

哎哟傻逼题调了一晚上。

容易想到二分答案，那么先考虑如何判断固定区间中位数能否大于 $x$？即大于等于 $x$ 的数的个数减去小于 $x$ 的数的个数大于等于 $0$。换句话说，对于固定的 $x$，将大于等于它的赋值为 $1$，小于的赋值为 $-1$，区间和大于等于 $0$。

对于原问题，容易发现就是 $[b,c]$ 的总和加上 $[a,b-1]$ 的最大后缀和 $[c+1,d]$ 的最大前缀。

这个可以（离散化后）对每个值开线段树维护（可持久化即可），也可以分块。

那么如何分块呢？设块长为 $B$，容易发现对于每一块只有 $B+1$ 种不同的情况，那么分别扫一遍预处理，复杂度 $O(B^2\frac{n}{B})$。

然后二分后 check 可以简单地做到 $O(\frac{n}{B}+B)$。

于是复杂度 $O(n\sqrt{n}+q\sqrt{n}\log n)$。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(i64 i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(i64 i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
#define gc getchar()
i64 read(){
	i64 x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const i64 N=2e4+5;
const i64 B=150;
i64 n,m,a[N],lans;
vector<i64> lsh;
i64 L[155],R[155],blg[N];
i64 sum[155][N],smx[155][N],pmx[155][N];
bool chk(i64 l1,i64 r1,i64 l2,i64 r2,i64 val){
	i64 mx1=0,mx2=0,ss=0;
	if(blg[r1]+1<blg[l2]){
		forup(i,blg[r1]+1,blg[l2]-1){
			ss+=sum[i][val];
		}
		forup(i,r1,R[blg[r1]]){
			ss+=(a[i]>=val?1:-1);
		}
		forup(i,L[blg[l2]],l2){
			ss+=(a[i]>=val?1:-1);
		}
	}else{
		forup(i,r1,l2){
			ss+=(a[i]>=val?1:-1);
		}
	}
	--r1,++l2;
	i64 nw=0;
	if(blg[l1]+1<blg[r1]){
		fordown(i,r1,L[blg[r1]]){
			nw+=(a[i]>=val?1:-1);
			mx1=max(mx1,nw);
		}
		fordown(i,blg[r1]-1,blg[l1]+1){
			mx1=max(mx1,nw+smx[i][val]);
			nw+=sum[i][val];
		}
		fordown(i,R[blg[l1]],l1){
			nw+=(a[i]>=val?1:-1);
			mx1=max(mx1,nw);
		}		
	}else{
		fordown(i,r1,l1){
			nw+=(a[i]>=val?1:-1);
			mx1=max(mx1,nw);
		}
	}
	nw=0;
	if(blg[l2]+1<blg[r2]){
		forup(i,l2,R[blg[l2]]){
			nw+=(a[i]>=val?1:-1);
			mx2=max(mx2,nw);
		}
		forup(i,blg[l2]+1,blg[r2]-1){
			mx2=max(mx2,nw+pmx[i][val]);
			nw+=sum[i][val];
		}
		forup(i,L[blg[r2]],r2){
			nw+=(a[i]>=val?1:-1);
			mx2=max(mx2,nw);
		}
	}else{
		forup(i,l2,r2){
			nw+=(a[i]>=val?1:-1);
			mx2=max(mx2,nw);
		}
	}
	return ss+mx1+mx2>=0;
}
signed main(){
	n=read();
	forup(i,1,n){
		a[i]=read();
		lsh.push_back(a[i]);
	}
	sort(lsh.begin(),lsh.end());
	lsh.erase(unique(lsh.begin(),lsh.end()),lsh.end());
	forup(i,1,n){
		a[i]=lower_bound(lsh.begin(),lsh.end(),a[i])-lsh.begin();
	}
	i64 T=n/B;
	forup(i,1,T){
		L[i]=R[i-1]+1,R[i]=i*B;
		forup(j,L[i],R[i]){
			blg[j]=i;
		}
	}
	if(R[T]!=n){
		++T;
		L[T]=R[T-1]+1;R[T]=n;
		forup(j,L[T],R[T]){
			blg[j]=T;
		}
	}
	forup(i,1,T){
		forup(j,0,n){
			smx[i][j]=pmx[i][j]=sum[i][j]=-(R[i]-L[i]+1);
		}
		forup(j,L[i],R[i]){
			i64 x=a[j];
			i64 mmx=0,nw=0;
			fordown(k,R[i],L[i]){
				nw+=(a[k]>=x?1:-1);
				mmx=max(mmx,nw);
			}
			smx[i][x]=mmx;
			mmx=0,nw=0;
			forup(k,L[i],R[i]){
				nw+=(a[k]>=x?1:-1);
				mmx=max(mmx,nw);
			}
			pmx[i][x]=mmx;
			sum[i][x]=nw;
		}
		fordown(j,n-1,0){
			smx[i][j]=max(smx[i][j+1],smx[i][j]);
			pmx[i][j]=max(pmx[i][j+1],pmx[i][j]);
			sum[i][j]=max(sum[i][j+1],sum[i][j]);
		}
	}
	m=read();
	forup(i,1,m){
		vector<i64> q;
		forup(j,1,4){
			i64 p=read();
			q.push_back((p+lans)%n+1);
		}
		sort(q.begin(),q.end());
		i64 l1=q[0],r1=q[1],l2=q[2],r2=q[3];
		i64 ll=0,rr=n,mm;
		while(ll<rr){
			mm=(ll+rr+1)>>1;
			if(chk(l1,r1,l2,r2,mm)) ll=mm;
			else rr=mm-1;
		}
		lans=lsh[ll];
		printf("%lld\n",lans);
	}
}
```

///

## UOJ#164 V

[传送门](https://vjudge.net.cn/problem/UniversalOJ-164)

> 题意

- 初始给定长度为 $n$ 的序列 $a_i$，维护五个操作共 $q$ 次：
    - 区间 $[l,r]$ 赋值为 $a_i+x\;(x\ge 0)$。
    - 区间 $[l,r]$ 赋值为 $\max(0,a[i]-x)\;(x<0)$。
    - 区间 $[l,r]$ 赋值为 $x\;(x\ge 0)$。
    - 查询单点值。
    - 查询单点历史最值。
- $1\le n,q\le 5\times 10^5$，所有输入的数在 $10^9$ 以内。

> 题解

还是比较有启发性吧。

考虑三个操作都能概括为 $a_i\gets \max(a_i+v,b)$，于是用 $(v,b)$ 二元组表示一个操作。

考虑两操作 $(v_1,b_1),(v_2,b_2)$ 的复合，容易发现 $\max(\max(a_i+v_1,b_1)+v_2,b_2)=\max(a_i+v_1+v_2,\max(b_1+v_2,b_2))$，显然这玩意有结合律，所以可以直接扔到线段树上维护懒标记。

那么单点查值是简单的，然后查历史最值由于查询和操作都是 $\max$，所以直接分别维护 $v,b$ 的最大值即可在叶子处得到答案。

复杂度 $O(n\log n)$。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(i64 i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(i64 i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
using pii=pair<i64,i64>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
i64 read(){
	i64 x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const i64 N=5e5+5,inf=1e18;
i64 n,a[N],m;
struct SegTree{
	#define mid ((l+r)>>1)
	#define lson l,mid,id<<1
	#define rson mid+1,r,id<<1|1
	pii tag[N<<2],htag[N<<2];
	void work(i64 id,pii val,pii hval){
		htag[id].fi=max(htag[id].fi,tag[id].fi+hval.fi);
		htag[id].se=max(htag[id].se,max(hval.se,tag[id].se+hval.fi));
		tag[id].fi=max(-inf,tag[id].fi+val.fi);
		tag[id].se=max(tag[id].se+val.fi,val.se);
	}
	void PushDown(i64 id){
		work(id<<1,tag[id],htag[id]);
		work(id<<1|1,tag[id],htag[id]);
		tag[id]=htag[id]=mkp(0,0);
	}
	void Build(i64 l=1,i64 r=n,i64 id=1){
		tag[id]=htag[id]=mkp(0,0);
		if(l==r) return;
		Build(lson);Build(rson);
	}
	void Update(i64 L,i64 R,pii X,i64 l=1,i64 r=n,i64 id=1){
		if(L<=l&&r<=R){
			work(id,X,X);
			return;
		}
		PushDown(id);
		if(L<=mid) Update(L,R,X,lson);
		if(mid< R) Update(L,R,X,rson);
	}
	pii Query(i64 P,i64 l=1,i64 r=n,i64 id=1){
		if(l==r){
			return mkp(max(a[l]+tag[id].fi,tag[id].se),max(a[l]+htag[id].fi,htag[id].se));
		}
		PushDown(id);
		if(P<=mid) return Query(P,lson);
		else       return Query(P,rson);
	}
}mt;
signed main(){
	n=read();
	m=read();
	forup(i,1,n){
		a[i]=read();
	}
	mt.Build();
	forup(i,1,m){
		i64 op=read();
		if(op==1){
			i64 l=read(),r=read(),v=read();
			mt.Update(l,r,mkp(v,0));
		}else if(op==2){
			i64 l=read(),r=read(),v=read();
			mt.Update(l,r,mkp(-v,0));
		}else if(op==3){
			i64 l=read(),r=read(),v=read();
			mt.Update(l,r,mkp(-inf,v));
		}else if(op==4){
			i64 p=read();
			printf("%lld\n",mt.Query(p).fi);
		}else{
			i64 p=read();
			printf("%lld\n",mt.Query(p).se);
		}
	}
}
```

///

## LOJ#6029 「雅礼集训 2017 Day1」市场

[传送门](https://loj.ac/p/6029)

> 题意

- 给定义一个长度为 $n$ 的序列 $a$，维护四个操作共 $q$ 次：
    - 区间加 $c\;(|c|\le 10^4)$.
    - 区间除以 $d$ 向下取整 $(2\le d\le 10^9)$。
    - 区间询问最小值。
    - 区间询问总和。
- $1\le n,q\le 10^5$，注意这道题下标从 $0$ 开始。

> 题解

神秘。

首先看到维护除法容易想到势能分析线段树，但是有区间加，怎么办。

因为有区间加，所以考虑对区间内数的相对大小做文章。

设 $f(x,d)=x-\left\lfloor\frac{x}{d}\right\rfloor$，容易发现对于一个区间，若 $f(mx,d)=f(mn,d)$（其中 $mx$ 是区间最大值，$mn$ 是区间最小值），那么操作二相当与区间减去 $f(mx,d)$。若不是就向下递归。

容易发现 $f(mx,d)=f(mn,d)$ 当且仅当 $mx=mn$ 或两者恰好在以 $d$ 的倍数分块的两块交界（即最大值和最小值的差比较小时），而区间加显然不会影响区间内最大值和最小值的差，那么它只会影响 $O(\log)$ 个区间，每个区间显然至多操作 $O(\log)$ 次这玩意就等于 $0$ 了，于是复杂度 $O(n\log^2 n)$（$q,n$ 同阶就不管了）。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(i64 i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(i64 i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
#define gc getchar()
i64 read(){
	i64 x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const i64 N=1e5+5,inf=0x3f3f3f3f;
i64 n,m,a[N];
i64 calcdel(i64 x,i64 d){
	if(x>=0){
		return x-(x/d);
	}else{
		x=-x;
		return ((x+d-1)/d)-x;
	}
} 
struct SegTree{
	#define mid ((l+r)>>1)
	#define lson l,mid,id<<1
	#define rson mid+1,r,id<<1|1
	i64 mx[N<<2],mn[N<<2],sum[N<<2],mark[N<<2];
	void PushUp(i64 id){
		mx[id]=max(mx[id<<1],mx[id<<1|1]);
		mn[id]=min(mn[id<<1],mn[id<<1|1]);
		sum[id]=sum[id<<1]+sum[id<<1|1];
	}
	void work(i64 id,i64 val,i64 len){
		mx[id]+=val;
		mn[id]+=val;
		mark[id]+=val;
		sum[id]+=val*len;
	}
	void PushDown(i64 id,i64 l,i64 r){
		work(id<<1,mark[id],mid-l+1);
		work(id<<1|1,mark[id],r-mid);
		mark[id]=0;
	}
	void Build(i64 l=1,i64 r=n,i64 id=1){
		mark[id]=0;
		if(l==r){
			sum[id]=mx[id]=mn[id]=a[l];
			return;
		}
		Build(lson);Build(rson);
		PushUp(id);
	}
	void Update(i64 L,i64 R,i64 X,i64 l=1,i64 r=n,i64 id=1){
		if(L<=l&&r<=R){
			work(id,X,r-l+1);
			return;
		}
		if(mark[id]) PushDown(id,l,r);
		if(L<=mid) Update(L,R,X,lson);
		if(mid< R) Update(L,R,X,rson);
		PushUp(id);
	}
	void Modify(i64 L,i64 R,i64 D,i64 l=1,i64 r=n,i64 id=1){
		if(L<=l&&r<=R&&calcdel(mx[id],D)==calcdel(mn[id],D)){
			work(id,-calcdel(mx[id],D),r-l+1);
			return;
		}
		if(mark[id]) PushDown(id,l,r);
		if(L<=mid) Modify(L,R,D,lson);
		if(mid< R) Modify(L,R,D,rson);
		PushUp(id);
	}
	i64 Querymn(i64 L,i64 R,i64 l=1,i64 r=n,i64 id=1){
		if(L<=l&&r<=R){
			return mn[id];
		}
		i64 res=inf;
		if(mark[id]) PushDown(id,l,r);
		if(L<=mid) res=min(res,Querymn(L,R,lson));
		if(mid< R) res=min(res,Querymn(L,R,rson));
		return res;
	}
	i64 Querysum(i64 L,i64 R,i64 l=1,i64 r=n,i64 id=1){
		if(L<=l&&r<=R){
			return sum[id];
		}
		i64 res=0;
		if(mark[id]) PushDown(id,l,r);
		if(L<=mid) res+=Querysum(L,R,lson);
		if(mid< R) res+=Querysum(L,R,rson);
		return res;
	}
}mt;
signed main(){
	n=read();m=read();
	forup(i,1,n){
		a[i]=read();
	}
	mt.Build();
	forup(i,1,m){
		i64 op=read(),l=read()+1,r=read()+1;
		if(op==1){
			i64 v=read();
			mt.Update(l,r,v);
		}else if(op==2){
			i64 d=read();
			mt.Modify(l,r,d);
		}else if(op==3){
			printf("%lld\n",mt.Querymn(l,r));
		}else{
			printf("%lld\n",mt.Querysum(l,r));
		}
	}
}
```

///

## P5618 [SDOI2015] 道路修建

[传送门](https://www.luogu.com.cn/problem/P5618)

这么版的题怎么都没人写 DDP（动态动态规划）做法啊。

> 题意

- 有一个两行 $n$ 列的网格图，四联通连边，每条边有边权。
- 有两个操作共 $q$ 次：
    - 修改某条边的边权。
    - 查询区间 $[l,r]$ 内两行共 $2(r-l+1)$ 个点的最小生成树。
- $1\le n,q\le 60000$，边权不超过 $10^4$

> 题解

晚自习 20min 切了，但是唐诗错误 WA 一发，但是洛谷最优解。

考虑静态问题（即没有修改，只有一次全局查询），容易想到 DP（因为只能相邻连边，所以这一列想和之前的连边必须和上一行连，那么可以对每一列设状态，从上一列转移）。

具体来说，设 $dp_{i,0/1}$ 表示考虑前 $i$ 列，第 $i$ 列两个点是否已经联通的最小代价。

转移很显然，具体如下（$d1$ 表示这一列第一行与上一列连边的边权，$d2$ 表示第二行，$d3$ 表示这一类的纵向连边）：

$$
dp_{i,0}=\min(dp_{i-1,1}+\min(d1,d2),dp_{i-1,0}+d1+d2)
$$
$$
dp_{i,1}=\min(dp_{i-1,1}+\min(d1+d2,d1+d3,d2+d3),dp_{i-1,0}+d1+d2+d3)
$$

初始状态为 $dp_{1,0}=0,dp_{1,1}=d3$。

然后用 $\min,+$ 的广义矩阵扔到线段树上维护一下就做完了。

具体来说，一般矩阵乘法（$A\times B=C$，此处以 $2\times 2$ 矩阵为例）的定义是 $C_{i,j}=\sum_{k=0}^1A_{i,k}\times B_{k,j}$，$\oplus,\otimes$（这代指两种运算）的广义矩阵乘法定义是 $C_{i,j}=\bigoplus A_{i,k}\otimes B_{k,j}$，容易证明只要 $\oplus$ 有交换律，$\otimes$ 有结合律和交换律，$\otimes$ 对 $\oplus$ 有分配率即可得到有结合律的矩阵乘法，具体证明考虑将 $(A\times B)\times C$ 和 $A\times(B\times C)$ 分别暴力拆开，此处略过。

然后容易发现用 $\min$ 代替 $\oplus$，用加法代替 $\otimes$ 即可完美地概括此题的 DP 转移，具体矩阵请自行构造，转移已给出。

复杂度 $O(n\log nk^3)$，其中 $k=2$，为矩阵边长。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
#define gc getchar()
int read(){
	int x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const int N=6e4+5,inf=0x3f3f3f3f;
struct Matrix{
	int c[2][2];
	Matrix(int a1=0,int a2=0,int a3=0,int a4=0){
		c[0][0]=a1;
		c[0][1]=a2;
		c[1][0]=a3;
		c[1][1]=a4;
	}
	Matrix operator *(const Matrix &r){//广义矩阵乘法
		Matrix res;
		forup(i,0,1){
			forup(j,0,1){
				res.c[i][j]=inf;
				forup(k,0,1){
					res.c[i][j]=min(res.c[i][j],c[i][k]+r.c[k][j]);
				}
			}
		}
		return res;
	}
};
int n,m,d1[N],d2[N],d3[N];
Matrix tr(int l){//转移矩阵
	return Matrix(d1[l]+d2[l],d1[l]+d2[l]+d3[l],min(d1[l],d2[l]),min({d1[l]+d2[l],d1[l]+d3[l],d2[l]+d3[l]}));
}
struct SegTree{//线段树维护区间矩阵广义积
	#define mid ((l+r)>>1)
	#define lson l,mid,id<<1
	#define rson mid+1,r,id<<1|1
	Matrix mat[N<<2];
	void PushUp(int id){
		mat[id]=mat[id<<1]*mat[id<<1|1];
	}
	void Build(int l=1,int r=n,int id=1){//初始化
		if(l==r){
			mat[id]=tr(l);
			return;
		}
		Build(lson);Build(rson);
		PushUp(id);
	}
	void Update(int P,int l=1,int r=n,int id=1){//单点修改
		if(l==r){
			mat[id]=tr(l);
			return;
		}
		if(P<=mid) Update(P,lson);
		else       Update(P,rson);
		PushUp(id);
	}
	Matrix Query(int L,int R,int l=1,int r=n,int id=1){//区间查询
		if(L<=l&&r<=R){
			return mat[id];
		}
		Matrix res(0,inf,inf,0);
		if(L<=mid) res=res*Query(L,R,lson);
		if(mid< R) res=res*Query(L,R,rson);
		return res;
	}
}mt;
char str[5];
signed main(){
	n=read();m=read();
	forup(i,2,n) d1[i]=read();
	forup(i,2,n) d2[i]=read();
	forup(i,1,n) d3[i]=read();
	mt.Build();//记得初始化
	forup(i,1,m){
		scanf(" %s",str);
		if(str[0]=='C'){
			int x1=read(),y1=read(),x2=read(),y2=read(),w=read();
			if(x1>x2) swap(x1,x2);
			if(y1>y2) swap(y1,y2);
			if(x1==1){
				if(x2==1){
					d1[y2]=w;
				}else{
					d3[y2]=w;
				}
			}else{
				d2[y2]=w;
			}
			mt.Update(y2);
		}else{
			int l=read(),r=read();
			Matrix res=mt.Query(l+1,r);
			res=Matrix(0,d3[l],-inf,-inf)*res;
			printf("%d\n",res.c[0][1]);//最后答案显然必须连通。
		}
	}
}
```

///