---
comments: true
---

# 2024 七月杂题

怎么今年都过了一半了还是这么菜。

## P10220 [省选联考 2024] 迷宫守卫

[传送门](https://www.luogu.com.cn/problem/P10220)

> 题意

- 有一棵 $2^{n+1}-1$ 个结点的满二叉树。叶结点权值构成一个排列。
- 现在 Bob 要 dfs 这棵树，他在每个结点可以选择先进入左儿子或右儿子，最小化 dfs 序上叶结点权值的字典序。对于每个非叶结点 $u$，Alice 可以花费 $w_u$ 的代价将其涂色使得 Bob 必须先进入左儿子。Alice 一共可以花费 $K$ 的代价。她想最大化 Bob dfs 序上叶结点权值的字典序。
- Alice 操作完毕后 Bob 再操作，在双方都采取最优策略的情况下，求最终叶结点序列。
- $1\le n\le 16$，整个操作过程中所有数不会爆 `long long`。

> 题解

幽默 sfsl 没想清楚就写怒调一上午。

首先“最小化/最大化字典序”是经典贪心，每次可以不计后效的最小化/最大化第一个没确定的。

那么先考虑 Bob 如何在 Alice 的影响下最小化第一个叶子。容易想到一个 DP。设 $dp_{i,j}$ 表示在结点 $i$ 的子树中，要让 Bob 走到当前子树大于等于第 $j$ 小的叶子 Alice 需要花费的最小代价是多少。对于内存问题，可以将每一层存成长度为 $2^n$ 的数组，空间复杂度就是 $O(n2^n)$。考虑如何转移。

若 Bob 进入左儿子，只有两种可能，一是 Alice 给当前结点涂了色，二是进左儿子更优一点。

设左儿子中的第 $j$ 大是当前结点的第 $j^{\ast}$ 大，于是找到右儿子第一个大于 $j$ 的点 $j'$，有：

$$
dp_{i,j^{\ast}}=dp_{ls,j}+\min(dp_{rs,j'},w_i)
$$

对于右儿子转移到当前结点，容易发现只可能是右儿子更优一点，因为 Alice 不能要求 Bob 先进右儿子。转移略。

那么就能找到 Bob 进入的第一个叶结点了，简单二分即可。一个显然的想法是从这个点一层一层往上跳，每次走进另一个分支做一遍相同的子问题（如果是从 $w_i$ 转移就完全相同，否则考虑能不能从更大的 $j''$ 转移过来）。但是这个有点问题啊，有可能最小值是从 $w_i$ 转移过来的，但是 $m$ 足够从一个 $j'$ 转移过来。这种时候从 $j'$ 转移反而会更优一点。这种情况特殊考虑一下即可。

每个结点只会访问 $O(1)$ 次，结点内操作是 $O(\log n)$ 的，所以瓶颈在预处理，复杂度 $O(n2^n)$。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(i64 i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(i64 i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
using i64=long long;
using pii=pair<i64,i64>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
i64 read(){
	i64 x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const i64 N=1<<16|5,inf=1e18;
i64 n,m,w[N],q[N];
i64 dp[17][N];
pii p[17][N],pre[17][N];
void work(i64 l,i64 r,i64 dpt,i64 id){
	if(l==r){
		dp[dpt][l]=0;
		return;
	}
	i64 mid=(l+r)>>1;
	work(l,mid,dpt+1,id<<1);work(mid+1,r,dpt+1,id<<1|1);
	i64 pl=l,pr=mid+1;
	forup(i,l,r){
		if(pr>r||(pl<=mid&&p[dpt+1][pl].fi<p[dpt+1][pr].fi)){
			if(pr<=r&&dp[dpt+1][pr]<=w[id]){
				dp[dpt][i]=dp[dpt+1][pl]+dp[dpt+1][pr];
				pre[dpt][i]=mkp(pl,pr);
			}else{
				dp[dpt][i]=dp[dpt+1][pl]+w[id];
				pre[dpt][i]=mkp(pl,-pr);
			}
			++pl;
		}else{
			if(pl==mid+1){
				dp[dpt][i]=inf;
				pre[dpt][i]=mkp(0,0);
			}else{
				dp[dpt][i]=dp[dpt+1][pr]+dp[dpt+1][pl];
				pre[dpt][i]=mkp(pl,pr);
			}
			++pr;
		}
	}
	fordown(i,r,l){
		if(dp[dpt][i]>inf) dp[dpt][i]=inf;
		if(i<r) dp[dpt][i]=min(dp[dpt][i],dp[dpt][i+1]);
	}
	merge(p[dpt+1]+l,p[dpt+1]+mid+1,p[dpt+1]+mid+1,p[dpt+1]+r+1,p[dpt]+l);
}
vector<i64> ans;
void gans(i64 l,i64 r,i64 dpt,i64 tp){
	if(l==r){
		ans.push_back(q[l]);
		return;
	}
	i64 L;
	if(tp==-1){
		L=upper_bound(dp[dpt]+l,dp[dpt]+r+1,m)-dp[dpt]-1;
		m-=dp[dpt][L];
	}else{
		m+=dp[dpt][tp];
		L=upper_bound(dp[dpt]+l,dp[dpt]+r+1,m)-dp[dpt]-1;
		m-=dp[dpt][L];
	}
	ans.push_back(q[p[dpt][L].se]);
	stack<pair<i64,pii> > stk;
	forup(d,dpt,n-1){
		i64 mid=(l+r)>>1;
		stk.push(mkp(L,mkp(l,r)));
		if(p[d][L].se>mid){
			l=mid+1;L=pre[d][L].se;
		}else{
			if(pre[d][L].se<0){
				r=mid;L=pre[d][L].fi;
			}else{
				r=mid;L=pre[d][L].fi;
			}
		}
	}
	i64 d=n-1;
	while(stk.size()){
		i64 L=stk.top().fi,l=stk.top().se.fi,r=stk.top().se.se,mid=(l+r)>>1;stk.pop();
		if(p[d][L].se>mid){
			gans(l,mid,d+1,pre[d][L].fi);
		}else{
			if(pre[d][L].se<0){
				if(-pre[d][L].se<=r&&dp[d+1][pre[d][L].fi]+dp[d+1][-pre[d][L].se]-dp[d][L]<=m){
					m-=(dp[d+1][pre[d][L].fi]+dp[d+1][-pre[d][L].se]-dp[d][L]);
					gans(mid+1,r,d+1,-pre[d][L].se);
				}else{
					gans(mid+1,r,d+1,0);
				}
			}else{
				gans(mid+1,r,d+1,pre[d][L].se);
			}
		}
		--d;
	}
}
void solve(){
	n=read();m=read();
	forup(i,1,(1<<n)-1){
		w[i]=read();
	}
	forup(i,0,(1<<n)-1){
		p[n][i].fi=q[i]=read();
		p[n][i].se=i;
	}
	work(0,(1<<n)-1,0,1);
	ans.clear();
	gans(0,(1<<n)-1,0,0);
	for(auto i:ans){
		printf("%lld ",i);
	}puts("");
}
signed main(){
	i64 t=read();
	while(t--){
		solve();
	}
}
```

///

## P10537 [APIO2024] 九月

[传送门](https://www.luogu.com.cn/problem/P10537)

> 题意

- 有一棵 $n$ 个结点，以 $0$ 为根的树，每天会重复若干次“删掉一个叶子”的操作，最终删的只剩下根节点。
- 有 $m$ 个序列，都是将每天删掉的叶子乱序排列后并排放在一起得到的。问最多有多少天。
- $1\le n\le 10^5,1\le m\le 5$，带多测，但是函数交互。

> 题解

纯水题，但有唐人 WA 一发。

首先每个序列中一天占的下标区间肯定是一样的。那么每个点出现在序列中的最前位置和最后位置之间肯定是同一天。

因为每个点只能在它的后代删完之后删，所以一个点与它子树内的最后位置肯定也是同一天。

然后随便维护一下就好了，我用的并查集，复杂度 $O(n\alpha(n))$。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
	int x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const int N=1e5+5,inf=0x3f3f3f3f;
int l[N],r[N];
vector<int> e[N];
void dfs(int x){
	for(auto i:e[x]){
		dfs(i);
		r[x]=max(r[x],r[i]);
	}
}
int fa[N];
int getfa(int x){return x==fa[x]?x:fa[x]=getfa(fa[x]);}
int solve(int n,int m,vector<int> f,vector<vector<int>> s){
	forup(i,0,n-1){
		l[i]=n;r[i]=-1;
		e[i].clear();
		fa[i]=i;
	}
	forup(i,1,n-1){
		e[f[i]].push_back(i);
	}
	forup(i,0,m-1){
		forup(j,0,n-2){
			l[s[i][j]]=min(l[s[i][j]],j);
			r[s[i][j]]=max(r[s[i][j]],j);
		}
	}
	dfs(0);
	forup(i,1,n-1){
		for(int j=getfa(l[i]);j<r[i];j=getfa(j)){
			fa[j]=getfa(j+1);
		}
	}
	int res=0;
	forup(i,0,n-2){
		if(fa[i]==i) ++res;
	}
	return res;
}
//signed main(){
//	int t=read();
//	while(t--){
//		int n=read(),m=read();
//		vector<int> f(n);
//		vector<vector<int>> s(m,vector<int>(n));
//		f[0]=-1;
//		forup(i,1,n-1) f[i]=read();
//		forup(i,0,m-1){
//			forup(j,0,n-2){
//				s[i][j]=read();
//			}
//		}
//		printf("%d\n",solve(n,m,f,s));
//	}
//}
```

///

## P9481 [NOI2023] 贸易

[传送门](https://www.luogu.com.cn/problem/P9481)

> 题意

- 有一 $2^n-1$ 个点的满二叉树，每条边都是指向父亲的带权有向边。
- 另有 $m$ 条带权有向非树边，每条非树边都从 $u$ 指向它子树内的某个 $v$。
- 令 $dis(u,v)$ 表示 $u$ 到 $v$ 的最短路径长度，若 $u$ 不可达 $v$ 则取 $0$。求 $\sum_{i=0}^{2^n-1}\sum_{j=0}^{2^n-1}dis(i,j)$。
- $2\le n\le 18,1\le m\le 2^n$，所有边权在 $10^9$ 以内。

> 题解

由于非树边都是前向边（即无横叉边），那么显然任意两点间的路径都要经过其 $\mathrm{lca}$，那么容易想到枚举 $\mathrm{lca}$ 统计跨子树的答案。下面考虑从点 $u$ 的左子树经过点 $u$ 到达点 $u$ 右子树的路径。（下文没提，但是注意统计以 $u$ 为起点/终点的路径）。

容易发现，任意一条路径必定形如 $x\rightsquigarrow u\rightsquigarrow a\to b\rightsquigarrow y$，即从 $x$ 出发到达一个深度小于等于 $u$ 的点（这一段必定只走树边，不然显然就有环），经过一条非树边 $a\to b$ 进入 $u$ 的右子树，再经过若干条树边或非树边到达 $y$。

容易发现对于所有 $x$ 和一个固定的 $y$，$u\rightsquigarrow a\to b\rightsquigarrow y$ 的长度都是相同的，否则全都可以换成最短的那个。于是求出 $u$ 到右子树所有点的最短路就能统计了。具体细节略。

但是注意到复杂度问题，如果每次都在全图上跑最短路肯定复杂度会爆（大概是 $O(4^nn)$ 的），一个显然的想法是每次只在 $u$ 的子树内跑最短路。对于 $u\rightsquigarrow a\to b$ 的部分，如果直接在跑的时候加入 $u$ 的祖先，那么每次就会访问一堆没用的边，复杂度会炸掉。一个想法每次枚举 $b$，然后直接找 $b$ 的入边。这样每条边最多被访问 $2n$ 次（在出边和入边时各 $n$ 次，因为每个点至多属于 $n$ 个子树）。

复杂度 $O(n^22^n)$。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
	int x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const int N=3e5+5,mod=998244353;
const i64 inf=1e18;
int n,m,f[N],sum[N],ans;
i64 len[N];
struct edge{
	int v,w;
};
vector<edge> e1[N],e[N];
void dfs(int id,int dpt){
	sum[id]=len[id]%mod;
	if(dpt==n) return;
	len[id<<1]=len[id]+f[id<<1];
	len[id<<1|1]=len[id]+f[id<<1|1];
	dfs(id<<1,dpt+1);dfs(id<<1|1,dpt+1);
	(sum[id]+=sum[id<<1])%=mod;
	(sum[id]+=sum[id<<1|1])%=mod;
}
int vis[N];
i64 dis[N];
priority_queue<pair<i64,int>,vector<pair<i64,int>>,greater<pair<i64,int>>> q;
void Get(int dpt,int id,int rt){
	vis[id]=0;
	if(id!=rt){
		dis[id]=inf;
		for(auto i:e1[id]){
			int v=i.v,w=i.w;
			if(v<=rt) dis[id]=min(dis[id],len[rt]-len[v]+w);
		}
		if(dis[id]!=inf&&id!=rt) q.push(mkp(dis[id],id));
	}
	if(dpt==n) return;
	Get(dpt+1,id<<1,rt);
	Get(dpt+1,id<<1|1,rt);
}
void dijkstra(int s){
	while(q.size()) q.pop();
	dis[s]=0;vis[s]=1;
	Get((31^__builtin_clz(s))+1,s,s);
	while(q.size()){
		int u=q.top().se;q.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(auto i:e[u]){
			int v=i.v,w=i.w;
			if(dis[v]>dis[u]+w){
				dis[v]=dis[u]+w;
				q.push(mkp(dis[v],v));
			}
		}
		if(u!=s){
			int v=(u>>1),w=f[u];
			if(dis[v]>dis[u]+w){
				dis[v]=dis[u]+w;
				q.push(mkp(dis[v],v));
			}
		}
	}
}
pii calc(int id,int dpt){
	pii rr=(dis[id]==inf?mkp(0,0):mkp(int(dis[id]%mod),1));
	if(dpt==n) return rr;
	pii r1=calc(id<<1,dpt+1);
	(rr.fi+=r1.fi)%=mod;
	(rr.se+=r1.se)%=mod;
	r1=calc(id<<1|1,dpt+1);
	(rr.fi+=r1.fi)%=mod;
	(rr.se+=r1.se)%=mod;
	return rr;
}
signed main(){
	n=read();m=read();
	forup(i,2,(1<<n)-1){
		f[i]=read();
	}
	forup(i,1,m){
		int u=read(),v=read(),w=read();
		e[u].push_back(edge{v,w});
		e1[v].push_back(edge{u,w});
	}
	dfs(1,1);
	forup(i,1,(1<<(n-1))-1){
		dijkstra(i);
		int d=(31^__builtin_clz(i))+1,cnt=(1<<(n-d))-1;
		pii rr=calc(i<<1|1,d+1);
		(ans+=1ll*rr.fi*(cnt+1)%mod)%=mod;
		(ans+=1ll*(rr.se+1)*(sum[i<<1]-1ll*len[i]*cnt%mod+mod)%mod)%=mod;
		rr=calc(i<<1,d+1);
		(ans+=1ll*rr.fi*(cnt+1)%mod)%=mod;
		(ans+=1ll*(rr.se+1)*(sum[i<<1|1]-1ll*len[i]*cnt%mod+mod)%mod)%=mod;
	}
	printf("%d\n",ans);
}
```

///

## P3705 [SDOI2017] 新生舞会

[传送门](https://www.luogu.com.cn/problem/P3705)

> 题意

- 给定一完全二分图，左右部点均为 $n$ 个。每条边有 $a,b$ 两权值。
- 求出一个最大匹配，最大化匹配中的 $\frac{\sum a_{i,j}}{\sum b_{i,j}}$。
-  $1\le n\le 100,1\le a_{i,j},b_{i,j}\le 10^4$。

> 题解

看到最大化某分数考虑一些类似 $01$ 分数规划的东西，二分答案。

设二分出来的答案为 $mid$，简单推式子可得：

$$
\begin{aligned}
\frac{\sum a_{i,j}}{\sum b_{i,j}}&\ge mid\\\\
\sum a_{i,j}&\ge \sum (b_{i,j}\times mid)\\\\
0&\ge \sum (b_{i,j}\times mid-a_{i,j})
\end{aligned}
$$

然后就转化成了带权二分图最大匹配使得匹配边权值最小。直接费用流即可。

复杂度 $O(n^3 k\log V)$，其中 $k$ 是 SPFA 复杂度里面的那个“通常不大于二 $2$”的常数。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
using ld=long double;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
	int x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const int N=105,inf=0x3f3f3f3f;
const ld eps=1e-7;
int n,a[N][N],b[N][N];
namespace flow{
	struct edge{
		int v,rst;
		ld w;
		int nxt;
	}e[N*N*8];
	int head[N*2],incf[N*2],pre[N*2],vis[N*2],cnte,s,t;
	ld dis[N*N];
	void init(){
		forup(i,1,t){
			head[i]=0;
		}
		cnte=1;
	}
	void adde(int u,int v,int rst,ld w){
		e[++cnte]=edge{v,rst,w,head[u]};head[u]=cnte;
		e[++cnte]=edge{u,0,-w,head[v]};head[v]=cnte;
	}
	bool spfa(){
		forup(i,1,t){
			dis[i]=1e18;
		}
		incf[s]=inf;incf[t]=0;
		queue<int> q;dis[s]=0;
		q.push(s);vis[s]=1;
		while(q.size()){
			int u=q.front();q.pop();
			vis[u]=0;
			for(int i=head[u];i;i=e[i].nxt){
				int v=e[i].v,rst=e[i].rst;
				ld w=e[i].w;
				if(!rst||dis[v]<=dis[u]+w) continue;
				dis[v]=dis[u]+w;
				incf[v]=min(incf[u],rst);
				pre[v]=i;
				if(!vis[v]){
					q.push(v);
					vis[v]=1;
				}
			}
		}
		return incf[t]!=0;
	}
	pair<int,ld> SSP(){
		ld mnc=0;
		int mxf=0;
		while(spfa()){
			mxf+=incf[t];
			for(int i=t;i!=s;i=e[pre[i]^1].v){
				mnc+=e[pre[i]].w*incf[t];
				e[pre[i]].rst-=incf[t];
				e[pre[i]^1].rst+=incf[t];
			}
		}
		return mkp(mxf,mnc);
	}
}
signed main(){
	n=read();
	flow::s=n*2+1;flow::t=n*2+2;
	forup(i,1,n){
		forup(j,1,n){
			a[i][j]=read();
		}
	}
	forup(i,1,n){
		forup(j,1,n){
			b[i][j]=read();
		}
	}
	ld ll=1,rr=10000,mm;
	forup(i,1,50){
		mm=(ll+rr)/2;
		flow::init();
		forup(i,1,n){
			forup(j,1,n){
				flow::adde(i,j+n,1,mm*b[i][j]-a[i][j]);
			}
		}
		forup(i,1,n){
			flow::adde(flow::s,i,1,0);
			flow::adde(i+n,flow::t,1,0);
		}
		pair<int,ld> res=flow::SSP();
		if(res.se<=0) ll=mm;
		else rr=mm;
	}
	printf("%.6Lf",ll);
}
```

///

## P1712 [NOI2016] 区间

基础知识掌握不完全，进阶知识完全没掌握。

> 题意

- 给定 $n$ 个区间 $[l_i,r_i]$，选择一个大小为 $m$ 的区间集合使其全都覆盖某个点（端点也算覆盖）。
- 最小化其中最长区间减去最短区间。
- $1\le n\le 5\times 10^5,1\le m\le 2\times 10^5$，其余数据在 $10^9$ 以内。

> 题解

妈的好傻逼啊正确思路想到一半给自己否决了去想神秘诡异思路。

首先题意完全能转化成选择至少 $m$ 个区间使得其中至少 $m$ 个覆盖同一个点，然后用大的减小的。这两种问题的最优情况是完全等价的。

显然选择按长度排序后连续的若干个区间是不劣的（对于固定的最短和最长，跳过中间若干个对答案没有影响，还会使得覆盖同一个点的区间数变少）。容易发现对于一个最长区间，选择最长的合法最短区间显然是最优的，并且容易发现对于两最长区间长度 $len_j>len_i$，最长的合法左端点也必有 $len_{j'}\ge len_{i'}$（因为 $i'\sim j$ 的区间集合完全包含 $i'\sim i$ 的区间集合，必然合法）。

那么直接双指针就完了，可以用线段树维护是否有 $m$ 个区间覆盖同一个点。

复杂度 $O(n\log n)$。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
	int x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const int N=5e5+5,inf=0x3f3f3f3f;
int n,m,sz,len[N];
pii rg[N];
struct SegTree{
	#define mid ((l+r)>>1)
	#define lson l,mid,id<<1
	#define rson mid+1,r,id<<1|1
	int mx[N<<3],mark[N<<3];
	void PushUp(int id){
		mx[id]=max(mx[id<<1],mx[id<<1|1]);
	}
	void PushDown(int id){
		mx[id<<1]+=mark[id];
		mx[id<<1|1]+=mark[id];
		mark[id<<1]+=mark[id];
		mark[id<<1|1]+=mark[id];
		mark[id]=0;
	}
	void Update(int L,int R,int X,int l=1,int r=sz,int id=1){
		if(L<=l&&r<=R){
			mark[id]+=X;
			mx[id]+=X;
			return;
		}
		if(mark[id]) PushDown(id);
		if(L<=mid) Update(L,R,X,lson);
		if(mid< R) Update(L,R,X,rson);
		PushUp(id);
	}
	int Query(){
		return mx[1];
	}
}mt;
signed main(){
	n=read();m=read();
	vector<int> lsh;
	forup(i,1,n){
		rg[i].fi=read();rg[i].se=read();
		lsh.push_back(rg[i].fi);lsh.push_back(rg[i].se);
	}
	sort(rg+1,rg+n+1,[&](pii a,pii b){
		return a.se-a.fi<b.se-b.fi;
	});
	sort(lsh.begin(),lsh.end());
	lsh.erase(unique(lsh.begin(),lsh.end()),lsh.end());
	sz=lsh.size();
	forup(i,1,n){
		len[i]=rg[i].se-rg[i].fi;
		rg[i].fi=lower_bound(lsh.begin(),lsh.end(),rg[i].fi)-lsh.begin()+1;
		rg[i].se=lower_bound(lsh.begin(),lsh.end(),rg[i].se)-lsh.begin()+1;
	}
	int pl=1,ans=inf;
	forup(i,1,n){
		mt.Update(rg[i].fi,rg[i].se,1);
		while(mt.Query()>=m){
			ans=min(ans,len[i]-len[pl]);
			mt.Update(rg[pl].fi,rg[pl].se,-1);
			++pl;
		}
	}
	if(ans!=inf){
		printf("%d\n",ans);
	}else{
		puts("-1");
	}
}
```

///

## P4121 [WC2005] 双面棋盘

[传送门](https://www.luogu.com.cn/problem/P4121)

> 题意

- 有一个 $n\times n$ 由黑白格子构成的棋盘，有 $m$ 个操作，每个操作为翻转某个格子（黑变白，白变黑）。
- 每次操作后询问黑色四连通块和白色四连通块的数量。
- $1\le n\le 200,1\le m\le 10^4$

> 题解

挺版的。

首先显然黑白是独立的，那么不妨只看黑色的。那么每个操作就是“加入”或者“删除”某个黑点。

那么就是一个很版的线段树分治了。可撤销并查集维护即可。另外容易发现黑白显然可以一起维护。

复杂度 $O((n^2+m)\log m\log n)$。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
	int x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const int N=205,inf=0x3f3f3f3f;
int n,m,a[N][N],b[N][N];
vector<int> cg[N][N];
#define po(x,y) (((x)-1)*n+(y))
int fa[N*N],sz[N*N],cnt[2];
stack<pair<pii,int>> stk;
int getfa(int x){return x==fa[x]?x:getfa(fa[x]);}
void merge(int u,int v,int co){
	u=getfa(u);v=getfa(v);
	if(u==v) return;
	if(sz[u]>sz[v]) swap(u,v);
	fa[u]=v;sz[v]+=sz[u];
	--cnt[co];
	stk.push(mkp(mkp(u,v),co));
}
void rback(int Tm){
	while((int)stk.size()>Tm){
		int u=stk.top().fi.fi,v=stk.top().fi.se,co=stk.top().se;stk.pop();
		fa[u]=u;sz[v]-=sz[u];++cnt[co];
	}
}
int nxt[4][2]={
	{0,1},{1,0},{0,-1},{-1,0}
};
struct SegTree{
	#define mid ((l+r)>>1)
	#define lson l,mid,id<<1
	#define rson mid+1,r,id<<1|1
	vector<pair<pii,int> > node[50000];
	void Update(int L,int R,pair<pii,int> nd,int l=1,int r=m,int id=1){
		if(L>R) return;
		if(L<=l&&r<=R){
			node[id].push_back(nd);
			return;
		}
		if(L<=mid) Update(L,R,nd,lson);
		if(mid< R) Update(L,R,nd,rson);
	}
	void Solve(int l=1,int r=m,int id=1){
		int nt=stk.size();
		for(auto i:node[id]){
			int x=i.fi.fi,y=i.fi.se,co=i.se;
			b[x][y]=co;++cnt[co];
			forup(j,0,3){
				int nx=x+nxt[j][0],ny=y+nxt[j][1];
				if(nx<1||ny<1||nx>n||ny>n||b[nx][ny]!=co) continue;
				merge(po(x,y),po(nx,ny),co);
			}
		}
		if(l==r){
			printf("%d %d\n",cnt[1],cnt[0]);
		}else{
			Solve(lson);Solve(rson);
		}
		rback(nt);
		for(auto i:node[id]){
			int x=i.fi.fi,y=i.fi.se,co=i.se;
			b[x][y]=-1;--cnt[co];
		}
	}
};
SegTree mt;
signed main(){
	n=read();
	forup(i,1,n){
		forup(j,1,n){
			a[i][j]=read();
			b[i][j]=-1;
			fa[po(i,j)]=po(i,j);sz[po(i,j)]=1;
			cg[i][j].push_back(1);
		}
	}
	m=read();
	forup(i,1,m){
		int x=read(),y=read();
		cg[x][y].push_back(i);
	}
	forup(i,1,n){
		forup(j,1,n){
			cg[i][j].push_back(m+1);
			int sz=cg[i][j].size(),c=a[i][j];
			forup(k,0,sz-2){
				mt.Update(cg[i][j][k],cg[i][j][k+1]-1,mkp(mkp(i,j),c));
				c^=1;
			}
		}
	}
	mt.Solve();
}
```

///

## CF1221F Choose a Square

[传送门](https://www.luogu.com.cn/problem/CF1221F)

> 题意

- 有一平面，其上有 $n$ 个点，每个点有权值。
- 现在你需要选择一个矩形 $(x_1,y_1,x_2,y_2)$，要求 $x_1=y_1,x_2=y_2$。令一个矩形的权值为其覆盖（包含边缘）的点权值和减去其边长。最大化权值，输出方案。
- $1\le n\le 5\times 10^5$，坐标在 $[0,10^9]$ 中，点权在 $[-10^6,10^6]$ 中。

> 题解

容易发现这个选矩形就是个幌子，实际上可以看做是在 $y=x$ 这条直线上选一个区间。那么用 $[l,r]$ 表示直线 $y=x$ 上横坐标在 $[l,r]$ 区间内的一段。

容易发现一个点 $(x,y)$（设 $x\le y$）会对 $l\le x,r\ge y$ 的区间 $[l,r]$ 产生贡献。于是就转化成了“$[l,r]$ 的权值是其覆盖的区间权值和减去 $r-l$”的问题。

这个很显然可以把所有区间挂到右端点，每个区间就是一个前缀加（这个需要离散化）。对于“减去 $r-l$”的问题，每次再做一个前缀减即可。复杂度 $O(n\log n)$。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(i64 i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(i64 i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
using i64=long long;
using pii=pair<i64,i64>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
i64 read(){
	i64 x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const i64 N=5e5+5,inf=1e18;
i64 n,x[N],y[N],v[N],sz,ans,ax,ay;
vector<i64> lsh;
vector<pii> nd[N<<1];
struct SegTree{
	#define mid ((l+r)>>1)
	#define lson l,mid,id<<1
	#define rson mid+1,r,id<<1|1
	i64 mx[N<<3],po[N<<3],mark[N<<3];
	void PushUp(i64 id){
		if(mx[id<<1]>mx[id<<1|1]){
			mx[id]=mx[id<<1];
			po[id]=po[id<<1];
		}else{
			mx[id]=mx[id<<1|1];
			po[id]=po[id<<1|1];
		}
	}
	void Build(i64 l=0,i64 r=sz,i64 id=1){
		if(l==r){
			po[id]=l;
			mx[id]=0;
			return;
		}
		Build(lson);Build(rson);
		PushUp(id);
	}
	void PushDown(i64 id){
		mx[id<<1]+=mark[id];
		mx[id<<1|1]+=mark[id];
		mark[id<<1]+=mark[id];
		mark[id<<1|1]+=mark[id];
		mark[id]=0;
	}
	void Update(i64 L,i64 R,i64 X,i64 l=0,i64 r=sz,i64 id=1){
		if(L<=l&&r<=R){
			mx[id]+=X;
			mark[id]+=X;
			return;
		}
		if(mark[id]) PushDown(id);
		if(L<=mid) Update(L,R,X,lson);
		if(mid< R) Update(L,R,X,rson);
		PushUp(id);
	}
	pii Query(int L,int R,int l=0,int r=sz,int id=1){
		if(L<=l&&r<=R){
			return mkp(mx[id],po[id]);
		}
		if(mark[id]) PushDown(id);
		pii res=mkp(0,-1);
		if(L<=mid) res=max(res,Query(L,R,lson));
		if(mid< R) res=max(res,Query(L,R,rson));
		return res;
	}
}mt;
signed main(){
	n=read();
	forup(i,1,n){
		x[i]=read(),y[i]=read(),v[i]=read();
		lsh.push_back(x[i]);lsh.push_back(y[i]);
	}
	sort(lsh.begin(),lsh.end());
	lsh.erase(unique(lsh.begin(),lsh.end()),lsh.end());
	sz=lsh.size()-1;
	forup(i,1,n){
		x[i]=lower_bound(lsh.begin(),lsh.end(),x[i])-lsh.begin();
		y[i]=lower_bound(lsh.begin(),lsh.end(),y[i])-lsh.begin();
		if(x[i]<=y[i]){
			nd[y[i]].push_back(mkp(x[i],v[i]));
		}else{
			nd[x[i]].push_back(mkp(y[i],v[i]));
		}
	}
	mt.Build();
	ans=0;
	ax=ay=lsh[sz]+1;
	forup(i,0,sz){
		for(auto j:nd[i]){
			mt.Update(0,j.fi,j.se);
		}
		if(i) mt.Update(0,i-1,lsh[i-1]-lsh[i]);
		pii res=mt.Query(0,i);
		if(res.se!=-1&&res.fi>ans){
			ans=res.fi;
			ax=lsh[res.se];ay=lsh[i];
		}
	}
	printf("%lld\n",ans);
	printf("%lld %lld %lld %lld\n",ax,ax,ay,ay);
}
```

///

## P5468 [NOI2019] 回家路线

[传送门](https://www.luogu.com.cn/problem/P5468)

> 题意

- 有 $n$ 个站台 $m$ 个航班，第 $i$ 个航班从 $x_i$ 站台到 $y_i$ 站台，$p_i$ 时刻出发并且 $q_i$ 时刻到达。
- 称一个航班序列 $s_1,s_2\dots s_k$ 为一个合法的回家路线当且仅当：
	- $x_{s_1}=1,y_{s_k}=n$
	- 对于所有 $j\in [1,k),y_j=x_{j+1}$，并且 $q_j\le p_{j+1}$
- 对于一个合法的回家路线，它的代价为（$A,B,C$ 均在数据开头给定）：

$$
q_{s_k}+\sum_{j=1}^{k}\left(A\times(p_{s_j}-q_{s_{j-1}})^2+B\times (p_{s_j}-q_{s_{j-1}})+C\right)
$$

- 此处钦定 $q_{s_0}=0$。
- 找到代价最小的回家路线，保证有解。
- $1\le n\le 10^5,1\le m\le 2\times 10^5$，其它数据大致在答案不爆 `long long` 的范围内。

> 题解

决策单调性做法。

首先以点为状态是不好做的，因为一个点可能有多条入边，很难概括全部信息。不妨以边为状态。

容易想到代价中的 $q_{s_k}$ 可以不管它，最后枚举以 $y_i=n$ 的边 $i$ 统计答案即可。

设 $f_i$ 表示走到边 $i$ 的最小代价。那么转移就形如 $f_i=f_j+w(j,i)$，其中 $w(j,i)=A\times(p_i-q_j)^2+B\times (p_i-q_{s_j})+C$。注意到这个满足四边形不等式，具体证明直接拆式子即可，此处略。于是可以用决策单调性优化。

具体来说，对每个点维护入边序列 $ed_i$ 和出边序列 $pos_i$（别问为什么这样叫，问就是马蜂问题），分别按结束时间 $q_j$ 和开始时间 $p_j$ 排序。决策单调性体现在若两出边 $i_1,i_2$ 满足 $p_{i_1}\le p_{i_2}$，那么它们对应的转移边 $j_1,j_2$ 必定满足 $q_{j_1}\le q_{j_2}$。于是套路地，对每个点用 `deque` 维护每个入边转移到的出边区间（对出边离散化）即可。

复杂度 $O(m\log m)$，但是写丑了常数巨大。

另外代码里面开的是加强版的数据范围。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(i64 i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(i64 i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
using i64=long long;
using pii=pair<i64,i64>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
i64 read(){
	i64 x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const i64 N=1e5+5,inf=1e18;
int n,m;
i64 ans=inf,A,B,C;
i64 calc(int len){
	return A*len*len+B*len+C;
}
struct edge{
	int x,y,s,e,pos;
}seq[1000005];
struct Node{
	int l,r,j;
};
deque<Node> q[N];
vector<int> pos[N];
queue<int> ed[N];
int mp[1000005],vis[1000005];
i64 dp[1000005];
i64 tr(int j,int i){
	if(j==-1) return inf;
	if(seq[j].e>seq[i].s) return inf;
	return dp[j]+calc(seq[i].s-seq[j].e);
}
signed main(){
	n=read();m=read();A=read();B=read();C=read();
	forup(i,1,m){
		seq[i].x=read();seq[i].y=read();seq[i].s=read();seq[i].e=read();
		dp[i]=inf;
	}
	sort(seq+1,seq+m+1,[&](edge a,edge b){
		if(a.s!=b.s) return a.s<b.s;
		return a.e<b.e;
	});
	forup(i,1,m){
		pos[seq[i].x].push_back(i);
		mp[i]=pos[seq[i].x].size()-1;
		seq[i].pos=i;
	}
	sort(seq+1,seq+m+1,[&](edge a,edge b){
		return a.e<b.e;
	});
	forup(i,1,m){
		ed[seq[i].y].push(seq[i].pos);
	}
	sort(seq+1,seq+m+1,[&](edge a,edge b){
		return a.pos<b.pos;
	});
	dp[0]=0;
	seq[0]=edge{1,1,0,0,0};
	q[1].push_back(Node{0,(int)pos[1].size()-1,0});
	forup(i,2,n){
		if(pos[i].size()) q[i].push_back(Node{0,(int)pos[i].size()-1,-1});
	}
	forup(i,1,m){
		int x=seq[i].x,y=seq[i].y,e=seq[i].e;
		while(q[x].front().r<mp[i]) q[x].pop_front();
		int j=q[x].front().j;
		if(j!=-1){
			dp[i]=tr(j,i);
		}
		vis[i]=1;
		if(y!=n){
			while(ed[y].size()&&vis[ed[y].front()]){
				int p=ed[y].front();ed[y].pop();
				int L=pos[y].size(),R=pos[y].size()-1;
				while(q[y].size()&&tr(p,pos[y][q[y].back().l])<tr(q[y].back().j,pos[y][q[y].back().l])){
					L=q[y].back().l;
					q[y].pop_back();
				}
				if(q[y].size()&&tr(p,pos[y][q[y].back().r])<tr(q[y].back().j,pos[y][q[y].back().r])){
					i64 ll=q[y].back().l,rr=q[y].back().r,mm;
					while(ll<rr){
						mm=(ll+rr)>>1;
						if(tr(p,pos[y][mm])<tr(q[y].back().j,pos[y][mm])) rr=mm;
						else ll=mm+1;
					}
					L=ll;
					q[y].back().r=L-1;
				}
				if(L<=R) q[y].push_back(Node{L,R,p});
			}
		}else{
			ans=min(ans,dp[i]+e);
		}
	}
	printf("%lld\n",ans);
}
```

///

## P4761 [CERC2014] Vocabulary

[传送门](https://www.luogu.com.cn/problem/P4761)

> 题意

- 给定三个由小写字母和 `?` 组成的字符串 $s_1,s_2,s_3$。
- 将问号替换成任意小写字母，问有多少种替换方式使得对于字典序，有 $s_1<s_2<s_3$。
- 有多测，字符串总长小于等于 $10^6$

> 题解

容易想到 DP，设 $dp_{i,0/1,0/1}$ 表示考虑前 $i$ 位，$s_1$ 是否小于 $s_2$，$s_2$ 是否小于 $s_3$ 的方案数。显然二三维可以状压。

对于转移，别暴力搞，会出人命的。容易想到用矩阵概括，预处理枚举三个数是多少，简单分讨即可得到矩阵中的每一格，然后分别换成 `?` 加到（此处指矩阵的线性加）对应的转移里即可。

对于空字符，视为一个比所有字符均小的字符即可，注意 `?` 不能替换为空字符。

复杂度 $O(27^3+n\times 4^3)$，但是其实可以压掉一个 $4$，懒得写了。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
using i64=long long;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
int read(){
	int x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const int N=1e6+5,inf=0x3f3f3f3f,mod=1e9+9;
char str[N];
int n[3],a[3][N];
struct Matrix{
	int c[4][4];
	Matrix(){
		mem(c,0);
	}
	Matrix operator *(const Matrix &r){
		Matrix res;
		forup(i,0,3){
			forup(j,0,3){
				forup(k,0,3){
					(res.c[i][j]+=1ll*c[i][k]*r.c[k][j]%mod)%=mod;
				}
			}
		}
		return res;
	}
	void operator +=(const Matrix &r){
		forup(i,0,3){
			forup(j,0,3){
				(c[i][j]+=r.c[i][j])%=mod;
			}
		}
	}
};
map<pair<pii,int>,Matrix> trans;
void solve(){
	forup(i,0,2){
		scanf(" %s",str+1);
		n[i]=strlen(str+1);
		forup(j,1,n[i]){
			if(str[j]!='?'){
				a[i][j]=str[j]-'a'+1;
			}else{
				a[i][j]=-1;
			}
		}
	}
	int nn=max({n[0],n[1],n[2]});
	forup(i,0,2){
		forup(j,n[i]+1,nn){
			a[i][j]=0;
		}
	}
	Matrix res;
	res.c[0][0]=1;
	forup(i,1,nn){
		res=res*trans[mkp(mkp(a[0][i],a[1][i]),a[2][i])];
	}
	printf("%d\n",res.c[0][3]);
}
signed main(){
	forup(i,0,26){
		forup(j,0,26){
			forup(k,0,26){
				Matrix nw;
				if(i==j){
					if(j==k){
						nw.c[0][0]=nw.c[1][1]=nw.c[2][2]=nw.c[3][3]=1;
					}else if(j<k){
						nw.c[0][2]=nw.c[1][3]=nw.c[2][2]=nw.c[3][3]=1;
					}else{
						nw.c[2][2]=nw.c[3][3]=1;
					}
				}else if(i<j){
					if(j==k){
						nw.c[0][1]=nw.c[1][1]=nw.c[2][3]=nw.c[3][3]=1;
					}else if(j<k){
						nw.c[0][3]=nw.c[1][3]=nw.c[2][3]=nw.c[3][3]=1;
					}else{
						nw.c[2][3]=nw.c[3][3]=1;
					}
				}else{
					if(j==k){
						nw.c[1][1]=nw.c[3][3]=1;
					}else if(j<k){
						nw.c[1][3]=nw.c[3][3]=1;
					}else{
						nw.c[3][3]=1;
					}
				}
				trans[mkp(mkp(i,j),k)]+=nw;
				if(k) trans[mkp(mkp(i,j),-1)]+=nw;//-1 即 ?
				if(j) trans[mkp(mkp(i,-1),k)]+=nw;
				if(k&&j) trans[mkp(mkp(i,-1),-1)]+=nw;
				if(i) trans[mkp(mkp(-1,j),k)]+=nw;
				if(i&&k) trans[mkp(mkp(-1,j),-1)]+=nw;
				if(i&&j) trans[mkp(mkp(-1,-1),k)]+=nw;
				if(i&&j&&k) trans[mkp(mkp(-1,-1),-1)]+=nw;
			}
		}
	}
	int t=read();
	while(t--){
		solve();
	}
}
```

///