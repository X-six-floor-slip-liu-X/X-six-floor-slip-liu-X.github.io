---
comments: true
---

# 2024 5 月杂题

## P4690 [Ynoi2016] 镜中的昆虫

[传送门](https://www.luogu.com.cn/problem/P4690)

### 题意

- 初始给定一个长度为 $n$ 的序列 $a_i$，有两个操作。
- 操作 $1$ 是区间涂色。
- 操作 $2$ 是查询区间内有多少种不同颜色。
- $1\le n\le 10^5$，颜色可以离散化。

### 题解

神秘 cdq 题。

这道题因为带修改所以很难直接用主席树（主席树修改过于困难了）或者扫描线（这个贡献很难拆啊）做，那么考虑一个简单的转化，容易发现区间数颜色相当于区间内每种颜色若出现多次只计算一次。那不妨认为计算的是**某种颜色在区间内第一次出现**。这就非常有意思了，考虑“ $[l,r]$ 内第一次出现”应该如何维护。由于是在区间内第一次出现，那么它在整个序列上上一次出现的位置（设 $a_i$ 上一次出现位置为 $pre_i$，若没有则设为 $0$）必定在 $[0,l)$ 中。那么这个问题就转化成了一个二维数点。具体来说，设 $a_i$ 在某坐标系上对应的点为 $(i,pre_i)$，那么对 $[l,r]$ 的询问就是查询 $[l,r]\times [0,l)$ 的这个矩形中有多少个点。这个可以把询问离线下来跑扫描线。虽然又绕回扫描线了，但是容易发现现在点的贡献变独立了。

然后考虑单点修改应该怎么做。容易发现单点修改颜色只会改变至多两个 $pre_i$，即删两个点（相当于加两个权值为 $-1$ 的点）加两个点，具体改了哪两个 $pre$ 可以对每种眼色开个 `set` 维护。由于点的贡献是独立的所以这个问题就相当于加了一个时间维度，变成了空间里的点。那么就可以用 cdq 分治维护了。

然后考虑区间修改，这个区间颜色覆盖容易想到 odt。考虑 odt 的维护过程，容易发现**每个区间除了第一个数以外，中间的 $pre_i$ 都不会变**，并且修改到的每一个区间至多只会额外影响后面的一个 $pre_i$，而 odt 修改的区间总数量是 $O(n+m)$ 的，那么 $pre_i$ 的变化总次数就是 $O(n+m)$ 的，然后就能做了。

复杂度 $O((n+m)\log(n+m))$，过的还是比较轻松的。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof(a))
#define forup(i,s,e) for(int i=(s);i<=(e);i++)
#define fordown(i,s,e) for(int i=(s);i>=(e);i--)
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
inline int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=1e5+5,inf=0x3f3f3f3f;
int n,m,a[N],ans[N],pre[N];
struct Node{
	int x,y,pos,val;
}modi[N],q[N*8];
int cntq;
map<pii,int> odt;
set<int> seq[N<<1];
using mit=map<pii,int>::iterator;
vector<int> lsh;
mit split(int x){
	if(x>n) return odt.end();
	mit it=odt.upper_bound(mkp(x,0));
	if(it!=odt.end()&&it->fi.fi==x) return it;
	--it;
	int l=it->fi.fi,r=it->fi.se,c=it->se;
	odt.erase(it);
	seq[c].insert(x-1);seq[c].insert(x);
	odt.insert(mkp(mkp(l,x-1),c));
	return odt.insert(mkp(mkp(x,r),c)).fi;
}
void inita(){
	int lst=0;
	forup(i,1,n){
		a[i]=lower_bound(lsh.begin(),lsh.end(),a[i])-lsh.begin();
		if(i!=1&&a[i]!=a[i-1]){
			odt.insert(mkp(mkp(lst+1,i-1),a[i-1]));
			seq[a[i-1]].insert(lst+1);seq[a[i-1]].insert(i-1);
			lst=i-1;
		}
		pre[i]=(a[i]==a[i-1]?i-1:(seq[a[i]].size()?*prev(seq[a[i]].end()):0));
		q[++cntq]=Node{i,pre[i],0,1};
	}
	odt.insert(mkp(mkp(lst+1,n),a[n]));
	seq[a[n]].insert(lst+1);seq[a[n]].insert(n);
}
void initp(){
	forup(i,1,m){
		if(modi[i].pos==0) continue;
		modi[i].val=lower_bound(lsh.begin(),lsh.end(),modi[i].val)-lsh.begin();
		int l=modi[i].x,r=modi[i].y,vv=modi[i].val;
		mit ed=split(r+1),st=split(l);
		for(mit it=st;it!=ed;odt.erase(prev(++it))){
			int x=it->fi.fi;
			q[++cntq]=Node{x,pre[x],i,-1};
			if(x==l){
				pre[x]=(seq[vv].lower_bound(x)==seq[vv].begin()?0:*prev(seq[vv].lower_bound(x)));
			}else{
				pre[x]=x-1;
			}
			q[++cntq]=Node{x,pre[x],i,1};
			if(seq[it->se].upper_bound(r)!=seq[it->se].end()){
				int nxt=*seq[it->se].upper_bound(r);
				if(pre[nxt]>=l){
					q[++cntq]=Node{nxt,pre[nxt],i,-1};
					pre[nxt]=(seq[it->se].lower_bound(l)==seq[it->se].begin()?0:*prev(seq[it->se].lower_bound(l)));
					q[++cntq]=Node{nxt,pre[nxt],i,1};
				}
			}
			seq[it->se].erase(it->fi.fi);
			seq[it->se].erase(it->fi.se);
		}
		if(seq[vv].upper_bound(r)!=seq[vv].end()){
			int nxt=*seq[vv].upper_bound(r);
			q[++cntq]=Node{nxt,pre[nxt],i,-1};
			pre[nxt]=r;
			q[++cntq]=Node{nxt,pre[nxt],i,1};
		}
		odt.insert(mkp(mkp(l,r),vv));
		seq[vv].insert(l);seq[vv].insert(r);
	}
}
struct BIT{
	int c[N];
	void upd(int x,int k){++x;for(;x<=n+1;x+=x&-x)c[x]+=k;}
	int sum(int x){++x;int res=0;for(;x>0;x-=x&-x)res+=c[x];return res;}
}bit;
void cdq(int l,int r){
	if(l>=r) return;
	int mid=(l+r)>>1;
	cdq(l,mid);cdq(mid+1,r);
	int L=l;
	forup(i,mid+1,r){
		if(q[i].val!=0) continue;
		for(;L<=mid&&q[L].y<q[i].y;++L){
			if(q[L].val==0) continue;
			bit.upd(q[L].x,q[L].val);
		}
		ans[q[i].pos]+=(bit.sum(q[i].x)-bit.sum(q[i].y-1));
	}
	forup(i,l,L-1){
		if(q[i].val==0) continue;
		bit.upd(q[i].x,-q[i].val);
	}
	inplace_merge(q+l,q+mid+1,q+r+1,[&](Node a,Node b){
		if(a.y!=b.y) return a.y<b.y;
		return a.val!=0&&b.val==0;
	});
}
signed main(){
	n=read();m=read();
	forup(i,1,n){
		a[i]=read();
		lsh.push_back(a[i]);
	}
	forup(i,1,m){
		int op=read();
		if(op==1){
			int l=read(),r=read(),x=read();
			lsh.push_back(x);
			modi[i]=Node{l,r,i,x};
		}else{
			int l=read(),r=read();
			q[++cntq]=Node{r,l,i,0};
		}
	}
	sort(lsh.begin(),lsh.end());
	lsh.erase(unique(lsh.begin(),lsh.end()),lsh.end());
	inita();
	initp();
	sort(q+1,q+cntq+1,[&](Node a,Node b){
		if(a.pos!=b.pos) return a.pos<b.pos;
		return a.val!=0&&b.val==0;
	});
	cdq(1,cntq);
	forup(i,1,m){
		if(modi[i].pos==0){
			printf("%d\n",ans[i]);
		}
	}
}
```

///

## P6105 [Ynoi2010] y-fast trie

[传送门](https://www.luogu.com.cn/problem/P6105)

神秘题目。

### 题意

- 维护一个集合，有 $n$ 次操作。操作分两种，分别是插入一个 $x$ 和删除一个 $x$，保证集合内不会同时存在两个相同的数。
- 给定 $C$，每次操作后输出 $\max_{x,y\in S}^{x\ne y}\begin{Bmatrix}(x+y)\bmod C\end{Bmatrix}$
- $1\le n\le 5\times 10^5,0\le x\le 1073741823,1\le C\le 1073741823$

### 题解

首先容易发现插入是简单的，考虑对 $C$ 取模后再加入，那么答案只有 $x+y$ 或 $x+y-C$ 两种。后者显然 $x,y$ 取最大值和次大值即可。前者可以对于新加入的 $x$ 找到满足 $x+y<C$ 的最大的 $y$，这个可以随便用一些前驱后继数据结构。

考虑为什么删除是困难的，令 $f(x)$ 为满足 $x+y<C$ 的最大的 $y$。容易发现若删除 $x$，那么可能有多个 $f(x')=x$，这些全都要修改，于是复杂度就炸了。

然后正常思路是考虑用某些数据结构优化（事实上我最开始也是这样想的）。

但是这道题考虑寻找性质。容易发现若 $x+y$ 是方案一的最优解，那么 $f(x)=y,f(y)=x$（不然必定不是最优）。所以只维护双向的 $f$ 关系。这样每次加入删除都只需要修改一次了。

复杂度 $O(n\log n)$，注意 $x\bmod C$ 可能会重复，实现时记得用 `multiset`。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof(a))
#define forup(i,s,e) for(int i=(s);i<=(e);i++)
#define fordown(i,s,e) for(int i=(s);i>=(e);i--)
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
#define gc getchar()
inline int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=5e5+5,inf=0x3f3f3f3f;
int n,mod,lans;
multiset<int> mx,ss;
map<int,int> bst;
int find(int x){
	set<int>::iterator it=ss.lower_bound(mod-x);
	if(it==ss.begin()) return -1;
	if(*prev(it)==x){
		--it;
		if(it==ss.begin()) return -1;
	}
	return *prev(it);
}
signed main(){
	n=read();mod=read();
	forup(i,1,n){
		int op=read(),x=read();
		x^=lans;
		x%=mod;
		if(op==1){
			int y=find(x);
			ss.insert(x);
			if(y!=-1&&find(y)==x){
				if(bst.count(y)){
					int t=bst[y];
					mx.erase(mx.find(y+t));
					bst.erase(t);bst.erase(y);
				}
				bst[y]=x;bst[x]=y;
				mx.insert(x+y);
			}
		}else{
			if(bst.count(x)){
				int y=bst[x];
				bst.erase(x);bst.erase(y);
				mx.erase(mx.find(x+y));
				ss.erase(ss.find(x));
				int t=find(y);
				if(t!=-1&&find(t)==y){
					bst[y]=t;bst[t]=y;
					mx.insert(t+y);
				}
			}else{
				ss.erase(ss.find(x));
			}
		}
		if(ss.size()<2){
			puts("EE");
			lans=0;
		}else{
			lans=(*prev(ss.end())+*prev(prev(ss.end())))%mod;
			if(mx.size()) lans=max(lans,*prev(mx.end()));
			printf("%d\n",lans);
		}
	}
	
}
```

///