---
comments: true
---

# 2024 5 月杂题

## P4690 [Ynoi2016] 镜中的昆虫

[传送门](https://www.luogu.com.cn/problem/P4690)

### 题意

- 初始给定一个长度为 $n$ 的序列 $a_i$，有两个操作。
- 操作 $1$ 是区间涂色。
- 操作 $2$ 是查询区间内有多少种不同颜色。
- $1\le n\le 10^5$，颜色可以离散化。

### 题解

神秘 cdq 题。

这道题因为带修改所以很难直接用主席树（主席树修改过于困难了）或者扫描线（这个贡献很难拆啊）做，那么考虑一个简单的转化，容易发现区间数颜色相当于区间内每种颜色若出现多次只计算一次。那不妨认为计算的是**某种颜色在区间内第一次出现**。这就非常有意思了，考虑“ $[l,r]$ 内第一次出现”应该如何维护。由于是在区间内第一次出现，那么它在整个序列上上一次出现的位置（设 $a_i$ 上一次出现位置为 $pre_i$，若没有则设为 $0$）必定在 $[0,l)$ 中。那么这个问题就转化成了一个二维数点。具体来说，设 $a_i$ 在某坐标系上对应的点为 $(i,pre_i)$，那么对 $[l,r]$ 的询问就是查询 $[l,r]\times [0,l)$ 的这个矩形中有多少个点。这个可以把询问离线下来跑扫描线。虽然又绕回扫描线了，但是容易发现现在点的贡献变独立了。

然后考虑单点修改应该怎么做。容易发现单点修改颜色只会改变至多两个 $pre_i$，即删两个点（相当于加两个权值为 $-1$ 的点）加两个点，具体改了哪两个 $pre$ 可以对每种眼色开个 `set` 维护。由于点的贡献是独立的所以这个问题就相当于加了一个时间维度，变成了空间里的点。那么就可以用 cdq 分治维护了。

然后考虑区间修改，这个区间颜色覆盖容易想到 odt。考虑 odt 的维护过程，容易发现**每个区间除了第一个数以外，中间的 $pre_i$ 都不会变**，并且修改到的每一个区间至多只会额外影响后面的一个 $pre_i$，而 odt 修改的区间总数量是 $O(n+m)$ 的，那么 $pre_i$ 的变化总次数就是 $O(n+m)$ 的，然后就能做了。

复杂度 $O((n+m)\log(n+m))$，过的还是比较轻松的。

/// details | 参考代码
    open: False
    type: success

```cpp
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof(a))
#define forup(i,s,e) for(int i=(s);i<=(e);i++)
#define fordown(i,s,e) for(int i=(s);i>=(e);i--)
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
using pii=pair<int,int>;
#define fi first
#define se second
#define mkp make_pair
#define gc getchar()
inline int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=1e5+5,inf=0x3f3f3f3f;
int n,m,a[N],ans[N],pre[N];
struct Node{
	int x,y,pos,val;
}modi[N],q[N*8];
int cntq;
map<pii,int> odt;
set<int> seq[N<<1];
using mit=map<pii,int>::iterator;
vector<int> lsh;
mit split(int x){
	if(x>n) return odt.end();
	mit it=odt.upper_bound(mkp(x,0));
	if(it!=odt.end()&&it->fi.fi==x) return it;
	--it;
	int l=it->fi.fi,r=it->fi.se,c=it->se;
	odt.erase(it);
	seq[c].insert(x-1);seq[c].insert(x);
	odt.insert(mkp(mkp(l,x-1),c));
	return odt.insert(mkp(mkp(x,r),c)).fi;
}
void inita(){
	int lst=0;
	forup(i,1,n){
		a[i]=lower_bound(lsh.begin(),lsh.end(),a[i])-lsh.begin();
		if(i!=1&&a[i]!=a[i-1]){
			odt.insert(mkp(mkp(lst+1,i-1),a[i-1]));
			seq[a[i-1]].insert(lst+1);seq[a[i-1]].insert(i-1);
			lst=i-1;
		}
		pre[i]=(a[i]==a[i-1]?i-1:(seq[a[i]].size()?*prev(seq[a[i]].end()):0));
		q[++cntq]=Node{i,pre[i],0,1};
	}
	odt.insert(mkp(mkp(lst+1,n),a[n]));
	seq[a[n]].insert(lst+1);seq[a[n]].insert(n);
}
void initp(){
	forup(i,1,m){
		if(modi[i].pos==0) continue;
		modi[i].val=lower_bound(lsh.begin(),lsh.end(),modi[i].val)-lsh.begin();
		int l=modi[i].x,r=modi[i].y,vv=modi[i].val;
		mit ed=split(r+1),st=split(l);
		for(mit it=st;it!=ed;odt.erase(prev(++it))){
			int x=it->fi.fi;
			q[++cntq]=Node{x,pre[x],i,-1};
			if(x==l){
				pre[x]=(seq[vv].lower_bound(x)==seq[vv].begin()?0:*prev(seq[vv].lower_bound(x)));
			}else{
				pre[x]=x-1;
			}
			q[++cntq]=Node{x,pre[x],i,1};
			if(seq[it->se].upper_bound(r)!=seq[it->se].end()){
				int nxt=*seq[it->se].upper_bound(r);
				if(pre[nxt]>=l){
					q[++cntq]=Node{nxt,pre[nxt],i,-1};
					pre[nxt]=(seq[it->se].lower_bound(l)==seq[it->se].begin()?0:*prev(seq[it->se].lower_bound(l)));
					q[++cntq]=Node{nxt,pre[nxt],i,1};
				}
			}
			seq[it->se].erase(it->fi.fi);
			seq[it->se].erase(it->fi.se);
		}
		if(seq[vv].upper_bound(r)!=seq[vv].end()){
			int nxt=*seq[vv].upper_bound(r);
			q[++cntq]=Node{nxt,pre[nxt],i,-1};
			pre[nxt]=r;
			q[++cntq]=Node{nxt,pre[nxt],i,1};
		}
		odt.insert(mkp(mkp(l,r),vv));
		seq[vv].insert(l);seq[vv].insert(r);
	}
}
struct BIT{
	int c[N];
	void upd(int x,int k){++x;for(;x<=n+1;x+=x&-x)c[x]+=k;}
	int sum(int x){++x;int res=0;for(;x>0;x-=x&-x)res+=c[x];return res;}
}bit;
void cdq(int l,int r){
	if(l>=r) return;
	int mid=(l+r)>>1;
	cdq(l,mid);cdq(mid+1,r);
	int L=l;
	forup(i,mid+1,r){
		if(q[i].val!=0) continue;
		for(;L<=mid&&q[L].y<q[i].y;++L){
			if(q[L].val==0) continue;
			bit.upd(q[L].x,q[L].val);
		}
		ans[q[i].pos]+=(bit.sum(q[i].x)-bit.sum(q[i].y-1));
	}
	forup(i,l,L-1){
		if(q[i].val==0) continue;
		bit.upd(q[i].x,-q[i].val);
	}
	inplace_merge(q+l,q+mid+1,q+r+1,[&](Node a,Node b){
		if(a.y!=b.y) return a.y<b.y;
		return a.val!=0&&b.val==0;
	});
}
signed main(){
	n=read();m=read();
	forup(i,1,n){
		a[i]=read();
		lsh.push_back(a[i]);
	}
	forup(i,1,m){
		int op=read();
		if(op==1){
			int l=read(),r=read(),x=read();
			lsh.push_back(x);
			modi[i]=Node{l,r,i,x};
		}else{
			int l=read(),r=read();
			q[++cntq]=Node{r,l,i,0};
		}
	}
	sort(lsh.begin(),lsh.end());
	lsh.erase(unique(lsh.begin(),lsh.end()),lsh.end());
	inita();
	initp();
	sort(q+1,q+cntq+1,[&](Node a,Node b){
		if(a.pos!=b.pos) return a.pos<b.pos;
		return a.val!=0&&b.val==0;
	});
	cdq(1,cntq);
	forup(i,1,m){
		if(modi[i].pos==0){
			printf("%d\n",ans[i]);
		}
	}
}
```

///

## P6105 [Ynoi2010] y-fast trie

[传送门](https://www.luogu.com.cn/problem/P6105)

神秘题目。

### 题意

- 维护一个集合，有 $n$ 次操作。操作分两种，分别是插入一个 $x$ 和删除一个 $x$，保证集合内不会同时存在两个相同的数。
- 给定 $C$，每次操作后输出 $\max_{x,y\in S}^{x\ne y}\begin{Bmatrix}(x+y)\bmod C\end{Bmatrix}$
- $1\le n\le 5\times 10^5,0\le x\le 1073741823,1\le C\le 1073741823$

### 题解

首先容易发现插入是简单的，考虑对 $C$ 取模后再加入，那么答案只有 $x+y$ 或 $x+y-C$ 两种。后者显然 $x,y$ 取最大值和次大值即可。前者可以对于新加入的 $x$ 找到满足 $x+y<C$ 的最大的 $y$，这个可以随便用一些前驱后继数据结构。

考虑为什么删除是困难的，令 $f(x)$ 为满足 $x+y<C$ 的最大的 $y$。容易发现若删除 $x$，那么可能有多个 $f(x')=x$，这些全都要修改，于是复杂度就炸了。

然后正常思路是考虑用某些数据结构优化（事实上我最开始也是这样想的）。

但是这道题考虑寻找性质。容易发现若 $x+y$ 是方案一的最优解，那么 $f(x)=y,f(y)=x$（不然必定不是最优）。所以只维护双向的 $f$ 关系。这样每次加入删除都只需要修改一次了。

复杂度 $O(n\log n)$，注意 $x\bmod C$ 可能会重复，实现时记得用 `multiset`。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof(a))
#define forup(i,s,e) for(int i=(s);i<=(e);i++)
#define fordown(i,s,e) for(int i=(s);i>=(e);i--)
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
#define gc getchar()
inline int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=5e5+5,inf=0x3f3f3f3f;
int n,mod,lans;
multiset<int> mx,ss;
map<int,int> bst;
int find(int x){
	set<int>::iterator it=ss.lower_bound(mod-x);
	if(it==ss.begin()) return -1;
	if(*prev(it)==x){
		--it;
		if(it==ss.begin()) return -1;
	}
	return *prev(it);
}
signed main(){
	n=read();mod=read();
	forup(i,1,n){
		int op=read(),x=read();
		x^=lans;
		x%=mod;
		if(op==1){
			int y=find(x);
			ss.insert(x);
			if(y!=-1&&find(y)==x){
				if(bst.count(y)){
					int t=bst[y];
					mx.erase(mx.find(y+t));
					bst.erase(t);bst.erase(y);
				}
				bst[y]=x;bst[x]=y;
				mx.insert(x+y);
			}
		}else{
			if(bst.count(x)){
				int y=bst[x];
				bst.erase(x);bst.erase(y);
				mx.erase(mx.find(x+y));
				ss.erase(ss.find(x));
				int t=find(y);
				if(t!=-1&&find(t)==y){
					bst[y]=t;bst[t]=y;
					mx.insert(t+y);
				}
			}else{
				ss.erase(ss.find(x));
			}
		}
		if(ss.size()<2){
			puts("EE");
			lans=0;
		}else{
			lans=(*prev(ss.end())+*prev(prev(ss.end())))%mod;
			if(mx.size()) lans=max(lans,*prev(mx.end()));
			printf("%d\n",lans);
		}
	}
	
}
```

///

## P3648 [APIO2014] 序列分割

### 题意

- 有一个长度为 $n$ 的非负整数序列 $a_i$，你要切 $k$ 刀把它分成 $k+1$ 份。
- 每一刀能获得这刀切出的两段分别的总和相乘的权值，问最大能获得多少权值。
- $2\le n\le 10^5,1\le k\le \min(n-1,200),0\le a_i\le 10^4$

### 题解

简单题。突然发现做题计划里面有这道题，于是就写了。

这个贡献非常不好算啊，考虑转化。容易发现最后答案就是 $\sum_{1\le i<j\le n}^{b_i\ne b_j}a_i\times a_j$，其中 $b_i$ 是 $i$ 最终所在的块（就是说每一对不在同一块的都会乘起来作贡献）。那么用总的减去多算的，答案就是 $\frac{S^2-\sum_{i=1}^{k+1}c_i^2}{2}$，其中 $S$ 是 $a_i$ 的总和，$c_i$ 是某一块中 $a_j$ 的总和。

其它都是定值，考虑求 $\sum_{i=1}^{k+1}c_i^2$ 的最小值，下文称这个为“代价”。

容易想到一个简单 DP，设 $dp_{l,i}$ 表示将 $[1,i]$ 切成 $l$ 块的最小代价。令 $s_i=\sum_{j=1}^ia_i$ 易得转移：

$$
\begin{aligned}
dp_{l,i}&=\min_{j=l-1}^{i-1}\begin{Bmatrix}dp_{i-1,j}+(s_i-s_j)^2\end{Bmatrix}\\\\
&=\min_{j=l-1}^{i-1}\begin{Bmatrix}dp_{i-1,j}+s_i^2+s_j^2-2s_is_j\end{Bmatrix}\\\\
&=\min_{j=l-1}^{i-1}\begin{Bmatrix}dp_{i-1,j}+s_j^2-2s_is_j\end{Bmatrix}+s_i^2
\end{aligned}
$$

长得就很斜率优化，然后就做完了。

另外由于 $s_i$ 是单调递增的，可以用单调队列 $O(n)$ 维护。这样复杂度就是 $O(nk)$。注意斜优的斜率比较部分可能会爆 `long long`。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof(a))
#define forup(i,s,e) for(int i=(s);i<=(e);i++)
#define fordown(i,s,e) for(int i=(s);i>=(e);i--)
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
using i64=long long;
using i128=__int128;
#define gc getchar()
inline int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=1e5+5,inf=0x3f3f3f3f;
struct Point{
	i64 x,y,pos;
	Point operator -(const Point &r){
		return Point{x-r.x,y-r.y,0};
	}
};
i128 cross(Point a,Point b){
	return (i128)a.x*b.y-(i128)a.y*b.x;
}
int n,k;
i64 dp[205][N],pre[205][N],ans,s[N];
deque<Point> conv;
void print(int l,int i){
	if(l==0) return;
	print(l-1,pre[l][i]);
	if(i!=n) printf("%d ",i);
}
signed main(){
	n=read();k=read();
	forup(i,1,n){
		s[i]=read();
		s[i]+=s[i-1];
		dp[1][i]=s[i]*s[i];
		msg("%lld ",dp[1][i]);
	}
	msg("|\n");
	ans=s[n]*s[n];
	forup(l,2,k+1){
		while(conv.size()) conv.pop_back();
		conv.push_back(Point{2*s[l-1],s[l-1]*s[l-1]+dp[l-1][l-1],l-1});
		forup(i,l,n){
			while(conv.size()>1&&cross(conv[1]-conv[0],Point{1,s[i],0})>=0) conv.pop_front();
			Point nw=Point{2*s[i],s[i]*s[i]+dp[l-1][i],i};
			dp[l][i]=conv.front().y-conv.front().x*s[i]+s[i]*s[i];
			pre[l][i]=conv.front().pos;
			while(conv.size()>1&&cross(conv[conv.size()-1]-conv[conv.size()-2],nw-conv.back())<=0) conv.pop_back();
			conv.push_back(nw);
			msg("%lld ",dp[l][i]);
		}
		msg("|\n");
	}
	ans-=dp[k+1][n];
	printf("%lld\n",ans>>1);
	print(k+1,n);
}
```

///

## CF1616G Just Add an Edge

[传送门](https://www.luogu.com.cn/problem/CF1616G)

### 题意

- 有一个 $N$ 个点 $M$ 条边的 DAG。每条边 $u\to v$ 均有 $v>u$。
- 你要添加一条边 $x\to y(x>y)$，问有多少种方法可以使这张图具有哈密顿路。
- $1\le N\le 150000,1\le M\le \min(\frac{n(n-1)}{2},150000)$

### 题解

考虑怎么样这张图才能有哈密顿路。

首先一个 DAG 什么时候有哈密顿回路，那由于题设的性质，它必然存在一条 $1\to 2\to 3\to \dots \to N$ 的链。此时加边方案数就是 $\binom{n}{2}$。

特判这种情况后，考虑一般情况。容易发现除了加的这条边 $x\to y$，哈密顿回路的其它地方必定是两条**结点编号单调递增**，**点集不相交**的链。考虑 $1\rightsquigarrow x$ 叫“第一条链”，$y\rightsquigarrow n$ 叫“第二条链”。容易发现 $[1,y-1]$ 必定由第一条链填满，$[x+1,n]$ 必定由第二条链填满。

那么最终的哈密顿回路必然形如这样：

$$
(1\to 2\to \dots \to y-1)\rightsquigarrow x\to y \rightsquigarrow (x+1\to x+2\to \dots\to n)
$$

其中两个括起来的部分表示每次 $+1$ 的链，$y-1\rightsquigarrow x$ 和 $y\rightsquigarrow x+1$ 是两条交为 $\varnothing$，并为 $[x,y]$ 的链。

是否存在 $(1\to 2\to \dots \to y-1)$ 和 $(x+1\to x+2\to \dots\to n)$ 的链是好判断的，所以只考虑满足条件的 $y-1\rightsquigarrow x$ 和 $y\rightsquigarrow x+1$ 是否存在即可。

容易发现这个条件形如存在一对 $(y-1,y)\rightsquigarrow (x,x+1)$ 的链，且两条链并起来恰好是 $[y-1,x+1]$。考虑枚举 $y'=y-1$ 然后计算有多少个 $x$ 满足 $(y',y'+1)\rightsquigarrow (x,x+1)$ 的条件。

由于两条链都只能从小到大延伸，想要覆盖一段连续的区间，那么两条链必定形如这样：

![图示 1](../img/2024May_1.png)

那么考虑枚举对颜色交界点 DP，设 $f_{i,0/1}$ 表示从 $(y',y'+1)$ 开始，能否走到 $(i,i+1)$（即第二维为 $0$ 表示左红右蓝）或 $(i+1,i)$（第二维为 $1$ 表示左蓝右红）。

具体转移考虑若 $f_{i,t}=1$，则枚举 $i$ 的出边 $i\to j$，若存在 $(i+1\to i+2\to\dots \to j-1)$，则 $f_{j-1,\lnot t}\gets 1$。这个 $(i+1\to \dots \to j-1)$ 的条件可以考虑存储 $r_i$ 表示 $i$ 能每次加一走到的最大点，那么那个条件就转化成了 $j-1\in [i+1,r_{i+1}]$。

这样就能 $O(nm)$ 的做了。但是这个不好优化啊（而且就算能除以 $\omega$ 也过不了），考虑有没有什么更强力的方法。

容易发现，对于一个 $p\nrightarrow p+1$，$i<p$ 的 $f_i$ 是无法转移到 $j-1>p$ 的 $f_{j-1}$ 的。因为对于 $i<p$，必有 $r_{i+1}\le p$，又因为 $j-1>p$，这显然与 $r_{i+1}> j-1$ 矛盾。

由于需要存在 $(1\to \dots \to y-1)$ 的路径，所以 $1\le y\le r_1+1$，那么对于 $y'=y-1$，必有 $0\le y' \le r_1$。同理由于需要 $(x+1\to \dots \to n)$，所以 $lst-1\le x\le n$，其中 $lst$ 是最小的 $i$ 满足 $r_i=n$。

> 此处暂且断一下，注意到 $f_{0}$ 没有定义，但这里能取到 $0$ 是因为哈密顿路的起点不一定是 $1$，可能根本不存在 $(1\to \dots \to y-1)$ 的路径。不妨建一个虚点，向所有点连边，这样起点就能固定是 $0$ 了。同理建一个虚点 $n+1$，让所有点向它连边，这样终点也能固定了。

回到刚才的思路，由于 $y'\le p$，而 $x>p$（除非 $r_1=n$，但这个在第一步就特判了），所以**对于任何 $y$，DP 的转移必定要经过 $f_{p}$ 这个点**。这就非常强了。

考虑对于 $i<p$，令 $f_{i,0/1}$ 表示能否从 $(i,i+1)$ 走到 $(p,p+1)/(p+1,p)$，对于 $i>p$，令 $f_{i,0/1}$ 表示能否从 $(p,p+1)$ 走到 $(i,i+1)/(i+1,i)$（容易发现这两种定义对于 $i=p$ 是等价的）。

然后路径就转化成了 $(y',y'+1)\rightsquigarrow (p,p+1)/(p+1,p)\rightsquigarrow (x,x+1)$。容易发现这可以枚举 $y'\in[0,p]$ 和 $x\in[lst-1,n]$ 来做，若 $f_{y',0}\land f_{x,0}$ 或 $f_{y',1}\land f_{x,1}$，则说明存在一条那样的路径。

而且这个非常强力，考虑一个简单的容斥，计算满足 $f_{y',0}\land f_{x,0}$ 的 $(y',x)$ 二元组数量加上满足 $f_{y',1}\land f_{x,1}$ 的 $(y',x)$ 的数量再减去两个都满足的即可。具体计算考虑乘法原理。

注意到一个 bug，根据枚举的方式，假如 $p=lst-1$ 就会多算一次 $y'=x=p$ 的情况，特判 $r_{r_{1}+1}=n$ 的情况减掉即可。

复杂度 $O(n)$。注意实际实现加了虚点后的边界情况会发生改变。

/// details | 参考代码
	open: False
	type: success

```cpp
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof(a))
#define forup(i,s,e) for(int i=(s);i<=(e);i++)
#define fordown(i,s,e) for(int i=(s);i>=(e);i--)
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
using i64=long long;
#define gc getchar()
inline int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=150005,inf=0x3f3f3f3f;
int n,m,a[N],r[N];
int dp[N][2];
vector<int> e[N];
void solve(){
	n=read();m=read();
	forup(i,0,n+1){
		e[i].clear();
		r[i]=i;a[i]=0;
		dp[i][0]=dp[i][1]=0;
		if(i>1) e[0].push_back(i);
		if(i<n) e[i].push_back(n+1);
	}
	a[n]=a[0]=1;
	forup(i,1,m){
		int u=read(),v=read();
		if(v==u+1) a[u]=1;
		else e[u].push_back(v);
	}
	fordown(i,n+1,0){
		if(a[i]) r[i]=r[i+1];
	}
	if(r[0]==n+1){
		printf("%lld\n",1ll*n*(n-1)/2);
		return;
	}
	dp[r[0]][0]=1;
	forup(i,r[0],n+1){
		for(auto j:e[i]){
			if(j-1<=r[i+1]){
				dp[j-1][0]|=dp[i][1];
				dp[j-1][1]|=dp[i][0];
			}
		}
	}
	fordown(i,r[0]-1,0){
		for(auto j:e[i]){
			if(j-1<=r[i+1]){
				dp[i][0]|=dp[j-1][1];
				dp[i][1]|=dp[j-1][0];
			}
		}
	}
	int cx0=0,cx1=0,cy0=0,cy1=0,cx01=0,cy01=0;
	forup(i,0,r[0]){
		cy0+=dp[i][0];
		cy1+=dp[i][1];
		cy01+=dp[i][0]&&dp[i][1];
	}
	int lst=n+1;
	while(r[lst]==n+1) --lst;
	forup(i,lst,n){
		cx0+=dp[i][0];
		cx1+=dp[i][1];
		cx01+=dp[i][0]&&dp[i][1];
	}
	i64 ans=1ll*cx0*cy0+1ll*cx1*cy1-1ll*cx01*cy01;
	if(r[r[0]+1]==n+1) --ans;
	printf("%lld\n",ans);
}
signed main(){
	int t=read();
	while(t--){
		solve();
	}
}
```

///